# Рисование. Canvas

## Компонент Canvas и DrawScope

Jetpack Compose предоставляет возможность для отрисовки графики в мобильном приложении. Для этого применяется компонент Canvas. По сути данный компонент предоставляет поверхность для рисования 2D-графики и инструменты для управления состоянием графического контента.

Компонент Canvas имеет следующие формы:

```kt
@Composable
fun Canvas(modifier: Modifier, onDraw: DrawScope.() -> Unit): Unit
 
@Composable
fun Canvas(modifier: Modifier, contentDescription: String, onDraw: DrawScope.() -> Unit): Unit
```

Параметры компонента:

- modifier: применяемые к компоненту функции модификатора

- onDraw: лямбда-выражение, которое будет вызываться для отрисовки графических примитивов. Обратите внимание, что это лямбда-выражение будет вызываться на этапе рисования, а это означает, что вызов функции Composable внутри этого выражения приведет к исключению во время выполнения.

- contentDescription: текст, используемый службами доступности для описания того, что представляет собой этот компонент.

Например, определим простейший компонент Canvas без какой-либо графики:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                // здесь отрисовка графики
            }
        }
    }
}
```
В данном случае для комопнента Canvas определяется прямоугольная область 300х300, окрашенная серым цветом:

![](https://metanit.com/kotlin/jetpack/pics/14.1.png)

### DrawScope
Canvas имеет собственную область действия в виде объекта DrawScope, который предоставляет доступ к свойствам поверхности рисования:

- center: центральная точка поверхности рисования в виде объекта Offset

- drawContext: объект DrawContext, который представляет контекст отрисовки

- layoutDirection: направление отрисовки в виде объекта LayoutDirection

- size: размер поверхности рисования в виде объекта Size

DrawScope также предоставляет функции для рисования фигур и управления графикой. Отмечу только основные из них:

- drawArc(): отрисовывает дугу

- drawCircle(): отрисовывает круг

- drawImage(): выводит изображение

- drawLine(): рисует линию

- drawOval(): отрисовывает овал

- drawPath(): отрисовывает геометрический путь

- drawPoints(): отрисовывает последовательность точек

- drawRect(): рисует прямоугольник

- drawRoundRect(): рисует прямоугольник с закругленными углами

- drawOutline(): отрисовывает контур

- drawText(): выводит текст

- clipPath(): вырезает путь

- clipRect(): вырезает прямоугольник

- rotate(): применяет поворот

- scale(): применяет масштабирование

- translate(): применяет перемещение

Свойства и функции DrawScope мы можем использовать внутри лямбда-выражения из последнего параметра Canvas. Например, получим ширину и высоту Canvas:

```kt
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    val height = size.height
    val width = size.width
}
```
В следущих статьях мы рассмотрим применение функций DrawScope для отрисвки и управления графикой.

# Отрисовка линий

Для отрисовки линий в DrawScope определена функция drawLine():

```kt
fun drawLine(
    color: Color,
    start: Offset,
    end: Offset,
    strokeWidth: Float = Stroke.HairlineWidth,
    cap: StrokeCap = Stroke.DefaultCap,
    pathEffect: PathEffect? = null,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```
Она имеет следующие параметры:

- color: цвет линии

- start: начальная точка линии (значение типа Offset)

- end: конечная точка линии (объект Offset)

- strokeWidth: ширина линии в Float

- cap: тип окончания линии в виде значения типа StrokeCap

- pathEffect: эффект, применяемый к линии

- alpha: прозрачность, применяемая к цвету линии в виде значения из диапазона от 0.0f до 1.0f

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету линии

- blendMode: алгоритм смешивания, применяемый к цвету

Пример линии:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Offset
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val height = size.height
                val width = size.width
                drawLine(
                    start = Offset(x= 0f, y = 0f),
                    end = Offset(x = width, y = height),
                    color = Color.Blue,
                    strokeWidth = 12.0f
                )
            }
        }
    }
}
```
Здесь рисуем синию линию шириной в 12 единиц от точки с координатами (x=0, y=0) до точки в правом нижнем углу.

```kt
https://metanit.com/kotlin/jetpack/pics/14.2.png
```
Стоит учитывать, что для отрисовки линий (как и всех остальных графических примитивов) для определения координат используются не независимые от плотности экрана единицы Dp, а обычные пиксели. Например:

```kt
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    drawLine(
        start = Offset(x= 0f, y = 0f),
        end = Offset(x = 400f, y = 400f),
        color = Color.Blue,
        strokeWidth = 12.0f
    )
}
```

Здесь Canvas имеет размер 300х300, а координата крайней точки линии имеет координаты (x=400, y=400). Казалось бы, линия должна уйти за пределы Canvas, но этого не происходит:

![](https://metanit.com/kotlin/jetpack/pics/14.26.png)

Дело в том, что размер Canvas объявляется в независимых от плотности/устройства пикселях (dp), а координаты для отрисовки указывается в пикселях (px). Независимые от плотности пиксели — это абстрактная величина, которая рассчитывается на основе физической плотности экрана, определяемой в точках на дюйм (dpi). Пиксели, с другой стороны, относятся к реальным физическим пикселям на экране. Чтобы работать исключительно в пикселях (а не в dp), значения dp можно преобразовать в пиксели с помощью функции Px():

```kt
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    drawLine(
        start = Offset(x= 0f, y = 0f),
        end = Offset(x = 200.dp.toPx(), y = 200.dp.toPx()),
        color = Color.Blue,
        strokeWidth = 12.0f
    )
}
```

### Тип линий
С помощью параметра pathEffect, который представляет значение типа PathEffect, можно настроить тип линии. Чтобы создать пунктирную линию, нам нужно вызвать метод DashPathEffect() объекта PathEffect и передать ему массив чисел с плавающей запятой. Числа с плавающей запятой обозначают интервалы в пикселях внутри линии. Должно быть четное количество интервальных значений, минимум 2 значения. Например:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.PathEffect
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val height = size.height
                val width = size.width
                drawLine(
                    start = Offset(x= 0f, y = 0f),
                    end = Offset(x = width, y = height),
                    color = Color.Blue,
                    strokeWidth = 12.0f,
                    pathEffect = PathEffect.dashPathEffect(floatArrayOf(30f, 10f, 10f, 10f), phase = 0f)
                )
            }
        }
    }
}
```

Здесь рисуем линию, которая начинается с длинного штриха в 40 пикселей, после которого идет пробел в 10 пикселей, черточка в 10 пикселей и пробел в 10 пикселей. Далее вся эта комбинация повторяется до конца линии:

![](https://metanit.com/kotlin/jetpack/pics/14.3.png)


# Отрисовка прямоугольников

Для отрисовки прямоугольников применяется функция drawRect():

```kt
fun drawRect(
    color: Color,
    topLeft: Offset = Offset.Zero,
    size: Size = this.size.offsetSize(topLeft),
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Она имеет следующие параметры:

- color: цвет прямоугольника

- topLeft: точка верхнего левого угла (значение типа Offset)

- size: размер прямоугольника

- alpha: прозрачность, применяемая к цвету прямоугольника в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения прямоугольника (значение DrawStyle)

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету прямоугольника

- blendMode: алгоритм смешивания, применяемый к цвету

Пример прямоугольника:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Size
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val size = Size(700f, 300f)
                drawRect(
                    color = Color.Blue,
                    size = size
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.4.png)

Обратите внимание, что в примере выше размеры Canvas составляют 300 x 300, а размер прямоугольника — 700 x 300, и как в случае с отрисовкой линий, которая рассматривалась в прошлой статье, для отрисовки прямоугольников применяются обычные пиксели px

Вместо указания размеров размер прямоугольника также можно определить относительно размера Canvas. Например, следующий код рисует квадрат размером в половину размера Canvas:

```kt
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    drawRect(
        color = Color.Blue,
        size = size / 2f
    )
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.5.png)

## Начальная позиция
Начальная позиция прямоугольника определяется с помощью координат верхнего левого угла через параметр topLeft:

```kt
import androidx.compose.ui.geometry.Offset
.......................
 
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    drawRect(
        color = Color.Blue,
        size = size / 2f,
        topLeft = Offset(x=350f, y = 300f),
    )
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.6.png)

В качестве альтернативы можно использовать функцию inset() для изменения границ внутри Canvas:

```kt
inline fun DrawScope.inset(inset: Float, block: DrawScope.() -> Unit): Unit
 
inline fun DrawScope.inset(
    horizontal: Float = 0.0f,
    vertical: Float = 0.0f,
    block: DrawScope.() -> Unit
): Unit
 
inline fun DrawScope.inset(
    left: Float,
    top: Float,
    right: Float,
    bottom: Float,
    block: DrawScope.() -> Unit
): Unit
```

Первая версия принимает общий отступ в пикселях со всех четырех сторон. Вторая версия устанавливает отдельные отступы по горизонтали и вертикали. И третья версия устанавливает отдельные отступы от каждой из четырех сторон. Например:

```kt
import androidx.compose.ui.graphics.drawscope.inset
.............................................
 
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    inset(350f, 300f, 0f, 0f) {
        drawRect(
            color = Color.Blue,
            size = size / 2f
        )
    }
}
```

### Заполнение прямоугольника
Параметр style отвечает за то, как цвет заполняет прямоугольник. Он представляет объект класса DrawStyle. По умолчанию применяется объект Fill, который заполняет цветом всю площадь фигуры. Но в качестве альтернативы мы также можем использовать подкласс Stroke, который отрисовывает только границу фигуры, не заполняя ее содержимого.

Класс Stroke имеет следущий конструктор:

```kt
Stroke(
    width: Float,
    miter: Float,
    cap: StrokeCap,
    join: StrokeJoin,
    pathEffect: PathEffect?
)
```

Его параметры:

- cap: устанавливает тип начала и конца линий

- join: устанавливает тип соединения линии

- miter: устанавливает форму для соединения линий линий

- pathEffect: устанавливает тип линии

- width: устанавливает ширину линии в пикселях

Например, зададим для прямоугольника только контур в 3.dp без заливки:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.drawscope.Stroke
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                drawRect(
                    color = Color.Blue,
                    size = size / 2f,
                    topLeft = Offset(x=150f, y = 200f),
                    style = Stroke(width = 3.dp.toPx()),
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.8.png)

### Прямоугольник с округленными углами
Аналогично мы можем рисовать прямоугольники с закругленными углами. Для этого применяется функция drawRoundRect()

```kt
fun drawRoundRect(
    color: Color,
    topLeft: Offset = Offset.Zero,
    size: Size = this.size.offsetSize(topLeft),
    cornerRadius: CornerRadius = CornerRadius.Zero,
    style: DrawStyle = Fill,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает все те же параметры, что и drawRoundRect() за тем исключением, что здесь добавляется параметр cornerRadius, который задает радиус закругления углов в виде объекта CornerRadius. Для его создания может применяться одноименная функция:

```kt
fun CornerRadius(x: Float, y: Float = x): CornerRadius
```

В качестве параметров она принимает значения радиуса по оси x и y.

Простейший пример создания закругленного прямоугольника:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
import androidx.compose.ui.geometry.CornerRadius
import androidx.compose.ui.geometry.Offset
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                drawRoundRect(
                    color = Color.Blue,
                    size = size / 2f,
                    topLeft = Offset(x=350f, y = 300f),
                    cornerRadius = CornerRadius(
                        x = 30.dp.toPx(),
                        y = 30.dp.toPx()
                    )
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.7.png)

# Отрисовка кругов и овалов

Для рисования окруженостей применяется функция drawCircle():

```kt
fun drawCircle(
    color: Color,
    radius: Float = size.minDimension / 2.0f,
    center: Offset = this.center,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает следующие параметры:

- color: цвет окружности

- center: точка верхнего левого углацентра окружености (значение типа Offset)

- radius: радиус окружности

- alpha: прозрачность, применяемая к цвету окружности в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения окружности (значение DrawStyle)

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету окружности

- blendMode: алгоритм смешивания, применяемый к цвету

Пример рисования окружности:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                drawCircle(
                    color = Color.DarkGray,
                    center = center,
                    radius = 120.dp.toPx()
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.10.png)

Для отрисовки овалов применяется функция drawOval()

```kt
fun drawOval(
    color: Color,
    topLeft: Offset = Offset.Zero,
    size: Size = this.size.offsetSize(topLeft),
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```
Эта функция принимает следующие параметры:

- color: цвет овала

- topLeft: точка верхнего левого угла (значение типа Offset)

- size: размер овала

- alpha: прозрачность, применяемая к цвету овала в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения овала (значение DrawStyle)

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету овала

- blendMode: алгоритм смешивания, применяемый к цвету

По сути эта функция описывает прямоугольник, в который вписывается овал. Пример отрисовки овала:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                drawOval(
                    color = Color.DarkGray,
                    topLeft = Offset(x = 20.dp.toPx(), y = 60.dp.toPx()),
                    size = Size(
                        width = size.width - 50.dp.toPx(),
                        height = size.height/2
                    ),
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.11.png)

# Отрисовка дуги

Для отрисовки дуги применяется функция drawArc()

```kt
fun drawArc(
    color: Color,
    startAngle: Float,
    sweepAngle: Float,
    useCenter: Boolean,
    topLeft: Offset = Offset.Zero,
    size: Size = this.size.offsetSize(topLeft),
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает следующие параметры:

- color: цвет дуги

- startAngle: начальный угол, где 0 соответствует трем часам

- sweepAngle: размер дуги в градусах, рисуемой по часовой стрелке относительно startAngle.

- useCenter: флаг, который указывает, должна ли дуга замыкать центр границ.

- topLeft: точка верхнего левого угла (значение типа Offset)

- size: размер прямоугольника, в который вписывается дуга

- alpha: прозрачность, применяемая к цвету дуги в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения дуги (значение DrawStyle)

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету дуги

- blendMode: алгоритм смешивания, применяемый к цвету

Например, следующий код рисует дугу, начинающуюся с 20°, с разверткой 90° в прямоугольнике размером 250х250 dp:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Size
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                drawArc(
                    Color.Blue,
                    startAngle = 20f,
                    sweepAngle = 90f,
                    useCenter = true,
                    size = Size(250.dp.toPx(), 250.dp.toPx())
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.15.png)

В примере благодаря параметру useCenter = true концы дуги соединяются с центральной точкой условной окружности, образуя сектор окружности. При значении false концы дуги соединяются между собой:

```kt
Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
    drawArc(
        Color.Blue,
        startAngle = 20f,
        sweepAngle = 90f,
        useCenter = false,
        size = Size(250.dp.toPx(), 250.dp.toPx())
    )
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.16.png)

# Рисование геометрических путей

DrawScope также поддерживает рисование путей. Пути — это, по сути, линии, нарисованные между набором точек. Для отрисовки путей применяется функция drawPath():

```kt
fun drawPath(
    path: Path,
    color: Color,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает следующие параметры:

- path: объект класса Path, который представляет путь

- color: цвет пути

- alpha: прозрачность, применяемая к цвету пути в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения пути

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету пути

- blendMode: алгоритм смешивания, применяемый к цвету

Для создания пути сначала вызывается функция moveTo(), которая определяет начальную точку первой линии. Затем линия рисуется до следующей позиции с помощью функций lineTo() или relativeLineTo() Функция lineTo() принимает координаты x и y следующей позиции относительно верхнего левого угла компонента Canvas. А функция relativeLineTo() принимает координаты относительно предыдущей точки и поэтому могут быть отрицательными или положительными. Класс Path также включает функции для рисования непрямых линий, включая кубические и квадратичные кривые Безье. Например, функция quadraticBezierTo() выводит квадратичную Безье и принимает координаты двух опорных точек. Для завершения пути вызывается функция close()

Пример пути:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Path
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                // определяем путь
                val path = Path().apply {
                    moveTo(0f, 0f)
                    quadraticBezierTo(40.dp.toPx(), 200.dp.toPx(), 300.dp.toPx(), 300.dp.toPx())
                    lineTo(270.dp.toPx(), 100.dp.toPx())
                    quadraticBezierTo(50.dp.toPx(), 80.dp.toPx(), 0f, 0f)
                    close()
                }
                // рисуем путь
                drawPath(path,Color.Blue)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.17.png)

Другой пример - нарисуем треугольник:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.drawscope.Stroke
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                // определяем путь
                val path = Path().apply {
                    moveTo(0f, size.height/2)
                    lineTo(size.width/2, 0f)
                    lineTo(size.width, size.height/2)
                    close()
                }
                // рисуем путь
                drawPath(path,Color.Blue, style= Stroke(width=3f))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.27.png)

# Отрисовка точек

Иногда бывает необходимо отрисовать отдельные точки. Для этого Compose предоставляет функцию drawPoints():

```kt
fun drawPoints(
    points: List<Offset>,
    pointMode: PointMode,
    color: Color,
    strokeWidth: Float = Stroke.HairlineWidth,
    cap: StrokeCap = StrokeCap.Butt,
    pathEffect: PathEffect? = null,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает следующие параметры:

- points: список точек для отрисовки, где каждая точка представляет объект Offset

- pointMode: тип точек. Указывает, будет ли каждая точка отображаться отдельно (режим PointMode.Points) или соединяться линиями с использованием режимов PointMode.Lines и PointMode.Polygon

- color: цвет пути

- strokeWidth: ширина линий между точками

- cap: тип завершения линий между точками

- alpha: прозрачность, применяемая к цвету точек в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения точек

- colorFilter: цветовой фильтр ColorFilter, который применяется к цвету точек

- blendMode: алгоритм смешивания, применяемый к цвету

Например, следующий код отображает синусоидальную волну, состоящую из отдельных точек:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.PointMode
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val height = size.height
                val width = size.width
                val points = mutableListOf<Offset>()
 
                for (x in 0..size.width.toInt()) {
                    val y = (kotlin.math.sin(x * (2f * 3.1415 / width)) * (height / 2) + (height / 2)).toFloat()
                    points.add(Offset(x.toFloat(), y))
                }
 
                drawPoints(
                    points = points,
                    strokeWidth = 4f,
                    pointMode = PointMode.Polygon,
                    color = Color.Blue
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.18.png)

# Вывод текста

Для вывода текста на Canvas применяется функция drawText(). Она имеет ряд версий, рассмотрим одну из них:

```kt
fun DrawScope.drawText(
    textMeasurer: TextMeasurer,
    text: String,
    topLeft: Offset = Offset.Zero,
    style: TextStyle = TextStyle.Default,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    size: Size = Size.Unspecified,
    blendMode: BlendMode = DrawScope.DefaultBlendMode
): Unit
```
Эта функция принимает следующие параметры:

- textMeasurer: объект TextMeasurer, который применяется для расположения текста

- text: выводимый текст

- topLeft: определяет смещение текста от верхней левой точки текущей системы координат

- style: стиль заполнения текста

- overflow: указывает, как следует обрабатывать выход текста за границы контейнера

- softWrap: указывает, должен ли текст разрываться при разрывах строк

- maxLines: максимальное количество строк

- size: размер прямоугольной области, в которую вписывается текст

- blendMode: алгоритм смешивания, применяемый к цвету текста

Еще одна версия:

```kt
fun DrawScope.drawText(
    textLayoutResult: TextLayoutResult,
    color: Color = Color.Unspecified,
    topLeft: Offset = Offset.Zero,
    alpha: Float = Float.NaN,
    shadow: Shadow? = null,
    textDecoration: TextDecoration? = null,
    drawStyle: DrawStyle? = null,
    blendMode: BlendMode = DrawScope.DefaultBlendMode
): Unit
```

Эта версия функции принимает следующие параметры:

- textLayoutResult: параметры расположения текста

- color: цвет пути

- topLeft: определяет смещение текста от верхней левой точки текущей системы координат

- alpha: прозрачность, применяемая к тексту

- shadow: параметры тени текста

- textDecoration: декорации текста (например, подчеркивание)

- drawStyle: стиль заполнения текста

- blendMode: алгоритм смешивания, применяемый к цвету текста

Для установки расположения текста применяется объект TextMeasurer, который применяется для расчета размера текста в зависимости от семейства и размера шрифта. Для получения объекта TextMeasurer применяется функция rememberTextMeasurer():

```kt
val textMeasurer = rememberTextMeasurer()
```

Получив объект TextMeasurer, его можно передать его в функцию drawText() вместе с текстом, который нужно отрисовать:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.rememberTextMeasurer
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val textMeasurer = rememberTextMeasurer()
            Canvas(Modifier.fillMaxSize()) {
                drawText(textMeasurer, "Hello METANIT.COM")
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.21.png)

Однако по умолчанию получается довольно маленький текст. И с помощью TextMeasurer мы можем настроить его параметры с помощью функции TextMeasurer.measure():

```kt
fun measure(
    text: String,
    style: TextStyle = TextStyle.Default,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    constraints: Constraints = Constraints(),
    layoutDirection: LayoutDirection = this.defaultLayoutDirection,
    density: Density = this.defaultDensity,
    fontFamilyResolver: FontFamily.Resolver = this.defaultFontFamilyResolver,
    skipCache: Boolean = false
): TextLayoutResult
```
Эта функция позволяет задать текст, его стиль, семейство шрифтов и т.д. Например:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.rememberTextMeasurer
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val textMeasurer = rememberTextMeasurer()
            val textLayoutResult = textMeasurer.measure(
                text = "Hello METANIT.COM",
                style = TextStyle(fontSize = 28.sp)
            )
            Canvas(Modifier.fillMaxSize()) {
                drawText(textLayoutResult)
            }
        }
    }
}
```
В данном случае для шрифта задается высота в 28 единиц:

![](https://metanit.com/kotlin/jetpack/pics/14.22.png)

Кроме обычного текста drawText() позволяет выводить аннотированные строки с более сложным форматированием отдельных сегментов текста. Для создагния аннотированных строк применяется функция buildAnnotatedString(). Подробнее про аннотированные строки рассказывалось в статье Аннотированные строки. Здесь же рассмотрим их вывод на Canvas:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.rememberTextMeasurer
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val textMeasurer = rememberTextMeasurer()
            val annotatedText = buildAnnotatedString {
                withStyle(
                    style = SpanStyle(
                        fontSize = 38.sp,
                        fontWeight = FontWeight.ExtraBold,
                        color = Color.DarkGray
                    )
                ) { append("Hello ")  }
 
                withStyle(
                    style = SpanStyle(
                        fontSize = 40.sp,
                        fontWeight = FontWeight.ExtraBold,
                        color = Color.Blue
                    )
                ) { append("METANIT.COM") }
            }
            Canvas(modifier = Modifier.fillMaxSize()) {
                drawText(textMeasurer, annotatedText)
            }
        }
    }
}
```
В данном случае определяется два сегмента текста с разным форматированием:

![](https://metanit.com/kotlin/jetpack/pics/14.23.png)

# Отрисовка изображений

Для отрисовки изображений применяется функция drawImage(). Она имеет ряд версий. Простая версия:

```kt
fun drawImage(
    image: ImageBitmap,
    topLeft: Offset = Offset.Zero,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode
): Unit
```

Эта функция принимает следующие параметры:

- image: изображение - объект ImageBitmap для отрисовки

- topLeft: координаты верхнего левого угла на Canvas

- alpha: прозрачность, применяемая к изображению в виде значения из диапазона от 0.0f до 1.0f

- style: стиль заполнения изображения

- colorFilter: цветовой фильтр ColorFilter, который применяется к изображению

- blendMode: алгоритм смешивания, применяемый к изображению

Другая версия функции:

```kt
fun drawImage(
    image: ImageBitmap,
    srcOffset: IntOffset = IntOffset.Zero,
    srcSize: IntSize = IntSize(image.width, image.height),
    dstOffset: IntOffset = IntOffset.Zero,
    dstSize: IntSize = srcSize,
    alpha: @FloatRange(from = 0.0, to = 1.0) Float = 1.0f,
    style: DrawStyle = Fill,
    colorFilter: ColorFilter? = null,
    blendMode: BlendMode = DefaultBlendMode,
    filterQuality: FilterQuality = DefaultFilterQuality
): Unit
```

Здесь добавлется четыре параметра, которые позволяют вывести часть изображения в определенную часть на Canvas:

- srcOffset: смещение на оригинальном изображении, откуда надо взять часть изображения

- srcSize: прямоугольная область, которая берется из оригинального изображения

- dstOffset: смещение верхнего левого угла, на который будет позиционироваться изображение

- dstSize: прямоугольная область, в которую вписывается изображение

Допустим, в папку res/drawable добавлено некоторое изображение. В моем случае это файл "forest.png"

![](https://metanit.com/kotlin/jetpack/pics/14.19.png)

Выведем это изображение на Canvas:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.res.imageResource
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.ImageBitmap
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val image = ImageBitmap.imageResource(R.drawable.forest)
            Canvas(Modifier.size(400.dp, 300.dp).background(Color.LightGray)) {
                drawImage(
                    image = image,
                    topLeft = Offset(x = 0f, y = 0f)
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.20.png)

# Трансформации

### Вращение
Любой нарисованный на Canvas элемент можно повернуть с помощью функции rotate():

```kt
fun rotate(degrees: Float, pivot: Offset = center, block: DrawScope.() -> Unit): Unit
```

Она принимает три параметра:

- degrees: угол поворота по часовой стрелки в виде значения Float

- pivot: точка поворота, по умолчанию представляет центр Canvas

- block: функция типа DrawScope.() -> Unit, внутри которой происходит отрисовка на повернутой плоскости

Например, повернем прямоугольник на 45°:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.rotate
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.fillMaxWidth().height(300.dp).background(Color.LightGray)) {
                rotate(45f) {
                    drawRect(
                        color = Color.Blue,
                        topLeft = Offset(200f, 200f),
                        size = size / 2f
                    )
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.9.png)

### Масштабирование
Для масштабирования элементов на Canvas применяется функция scale():

```kt
fun scale(scale: Float, pivot: Offset = center, block: DrawScope.() -> Unit): Unit
 
fun scale(
    scaleX: Float,
    scaleY: Float,
    pivot: Offset = center,
    block: DrawScope.() -> Unit
): Unit
```

Первая версия принимает три параметра:

- scale: коэффициент масштабирования

- pivot: точка масштабирования, по умолчанию представляет центр Canvas

- block: функция типа DrawScope.() -> Unit, внутри которой происходит отрисовка на отмасштабированной плоскости

Вторая версия позволяет задать отдельные коэффициенты для масштабирования по оси X и Y.

Например, увеличим прямоугольник в полтора раза:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.drawscope.scale
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.fillMaxWidth().height(300.dp).background(Color.LightGray)) {
                scale(1.5f) {
                    drawRect(
                        color = Color.Blue,
                        topLeft = Offset(260f, 200f),
                        size = size / 2f
                    )
                }
                drawRect(
                    color = Color.DarkGray,
                    topLeft = Offset(260f, 200f),
                    size = size / 2f
                )
            }
        }
    }
}
```

В данном случае темно-сервым цветом отображен прямоугольник с оригинальными размерами, а синим цветом - с отмасштабированными размерами:

![](https://metanit.com/kotlin/jetpack/pics/14.24.png)

### Перемещение
Функция translate() позволяет переместить сцену на определенное количество пикселей по горизонтали и/или вертикали:

fun translate(left: Float = 0.0f, top: Float = 0.0f, block: DrawScope.() -> Unit): Unit

Функция принимает три параметра:

- left: перемещение в пикселях по горизонтали

- top: перемещение в пикселях по вертикали

- block: функция типа DrawScope.() -> Unit, внутри которой происходит отрисовка на перещенной плоскости

Например, повернем прямоугольник на 45°:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.drawscope.translate
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.fillMaxWidth().height(300.dp).background(Color.LightGray)) {
                drawRect(
                    color = Color.DarkGray,
                    topLeft = Offset(60f, 60f),
                    size = size / 2f
                )
                translate(250f, 150f) {
                    drawRect(
                        color = Color.Blue,
                        topLeft = Offset(60f, 60f),
                        alpha = 0.5f,
                        size = size / 2f
                    )
                }
            }
        }
    }
}
```


Здесь происходит сдвиг прямоугольника на 250 пикселей по горизонтали и на 150 пикселей по вертикали. Для наглядности темно-серый прямоугольник представляет оригинальное положение, а синий прямоугольник - положение после сдвига:


![](https://metanit.com/kotlin/jetpack/pics/14.25.png)

# Создание градиента

Все фигуры позволяют использовать цвет для заливки фигуры или для создания ее контура. Для установки цвета можно использовать компонент Color или компонент Brush. Но если Color представляет сплошной цвет, то Brush позволяет создавать более сложное цветовое наполнение, например, в виде градиента различных типов. Например, чтобы заполнить прямоугольник горизонтальным градиентом, надо объект Brush инициализироваnm списком цветов - объектов Color вместе с начальным и конечным положением по оси X. Опционально можно указать параметр tileMode.

В следующем примере прямоугольник заполняется горизонтальным градиентом:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.TileMode
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val colorList = listOf(Color.Red, Color.Blue, Color.Green, Color.Cyan)
 
                val brush = Brush.horizontalGradient(
                    colors = colorList,
                    startX = 0f,
                    endX = 300.dp.toPx(),
                    tileMode = TileMode.Repeated
                )
                drawRect(brush = brush,size = size)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.12.png)

Другой пример - заполнение радиальным градиентом окружности:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.TileMode
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val radius = 150.dp.toPx()
                val colorList = listOf(Color.White, Color.Yellow, Color.Red)
                val brush = Brush.radialGradient(
                    colors = colorList,
                    center = center,
                    radius = radius,
                    tileMode = TileMode.Repeated
                )
                drawCircle(brush = brush, radius = radius)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.13.png)

Градиенты особенно полезны для добавления эффектов тени к рисункам. Например:

```kt
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.TileMode
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Canvas(Modifier.size(300.dp).background(Color.LightGray)) {
                val radius = 150.dp.toPx()
                val colorList = listOf(Color.Yellow, Color.Black)
                val brush = Brush.horizontalGradient(
                    colors = colorList,
                    startX = 0f,
                    endX = 300.dp.toPx(),
                    tileMode = TileMode.Repeated
                )
                drawCircle(brush = brush, radius = radius)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/14.14.png)