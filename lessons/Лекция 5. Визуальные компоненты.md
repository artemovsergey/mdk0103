# Визуальные компоненты

# Text

Неотъемлемой частью визуального интерфейса является текст. Для отображения текста Jetpack Compose предоставляет ряд встроенных компонентов. Прежде всего это компонент Text, который имеет следующее определение:

```kotlin
@Composable
fun Text(
    text: String,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    minLines: Int = 1,
    onTextLayout: ((TextLayoutResult) -> Unit)? = null,
    style: TextStyle = LocalTextStyle.current
): Unit
```

Параметры компонента:

- text: объект String, который представляет выводимый текст

- modifier: объект Modifier, который представляет применяемые к компоненту модификаторы

- color: объект Color, который представляет цвет текста. По умолчанию имеет значение Color.Unspecified

- fontSize: объект TextUnit, который представляет размер шрифта. По умолчанию равен TextUnit.Unspecified

- fontStyle: объект FontStyle?, который представляет стиль шрифта. По умолчанию равен null

- fontWeight: объект FontWeight?, который представляет толщину шрифта. По умолчанию равен null

- fontFamily: объект FontFamily?, который представляет тип шрифта. По умолчанию равен null

- letterSpacing: объект TextUnit, который представляет отступы между символами. По умолчанию равен TextUnit.Unspecified

- textDecoration: объект TextDecoration?, который представляет тип декораций (например, подчеркивание), применяемых к тексту. По умолчанию равен null

- textAlign: объект TextAlign?, который представляет выравнивание текста. По умолчанию равен null

- lineHeight: объект TextUnit, который представляет высоту строки текста. По умолчанию равен TextUnit.Unspecified

- overflow: объект TextOverflow, который определяет поведение текста при его выходе за границы контейнера. По умолчанию равен TextOverflow.Clip

- softWrap: объект Boolean, который определяет, должен ли текст переносится при завершении строки. При значении false текст не переносится, как будто строка имеет бесконечную длину. По умолчанию равен true

- maxLines: объект Int, который представляет максимальное количество строк. Если текст превысил установленное количество строк, то он усекается в соответствии с параметрами overflow и softWrap. По умолчанию равен Int.MAX_VALUE

- minLines: минимальное количество строк

- onTextLayout: объект (TextLayoutResult) -> Unit, который представляет функцию, выполняемую при определении компоновки текста.

- style: объект TextStyle, который представляет стиль текста. Значение по умолчанию - LocalTextStyle.current

## Размер шрифта
Размер шрифта определяется параметром fontSize. В качестве параметру может передаваться значение типов Int, Double и Float, после которых указывается тип единиц. Это могут быть масштабируемые пиксели (единицы sp, например, 22.sp), либо это может быть относительный размер шрифта в единицах em (например, 18.em). Значение TextUnit.Unspecified указывает, что высота шрифта наследуется от настроек родительного компонента

Простейшее применение компонента:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.foundation.layout.Column
import androidx.compose.ui.unit.em
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Hello Jetpack Compose!", fontSize=25.sp)
                Text("Hello Jetpack Compose!", fontSize=6.em)
            }
        }
    }
}
```

**Цвет шрифта**
За определение цвета шрифта отвечает параметр color, который представляет объект Color, ранее рассмотренный в пункте "Установка цвета".

```kotlin
import androidx.compose.ui.graphics.Color
//..........
Column {
    Text("Hello Jetpack Compose!",  fontSize=22.sp, color=Color.Red)
    Text("Hello Jetpack Compose!",  fontSize=22.sp, 
        color= Color(red = 0x44, green = 0x55, blue = 0x88, alpha = 0xFF))
}
```

## Стиль шрифта
Стиль шрифта определяется параметром fontStyle, который представляет класс FontStyle?. Для определения этот класс предоставляет два встроенных значения:

- FontStyle.Italic (наклоннный шрифт)
- FontStyle.Normal (стандартный шрифт)

```kotlin
import androidx.compose.ui.text.font.FontStyle
//..........
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontStyle = FontStyle.Italic)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontStyle = FontStyle.Normal)
```

## Толщина шрифта
Толщина шрифта задается параметром fontWeight, который представляет класс FontWeight.

Есть два способа установки толщины шрифта. Прежде всего можно использовать конструктор этого класса, в который передается числовое значение от 1 до 1000. Чем больше значение, тем толще будет шрифт:

```kotlin
FontWeight(600)
```
Второй способ заключается в применении встроенных значений:

- FontWeight.Black (Эквивалентно значению W900)
- FontWeight.Bold (Эквивалентно значению W700)
- FontWeight.ExtraBold (Эквивалентно значению W800)
- FontWeight.ExtraLight (Эквивалентно значению W200)
- FontWeight.Light (Эквивалентно значению W300)
- FontWeight.Medium (Эквивалентно значению W500)
- FontWeight.Normal (Эквивалентно W400 - значение по умолчанию)
- FontWeight.SemiBold (Эквивалентно значению W600)
- FontWeight.Thin (Эквивалентно значению W100

Так, следующие определения компонента Text будут аналогичны:

```kotlin
import androidx.compose.ui.text.font.FontWeight
//..........
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight.Bold)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight.W700)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight(700))
```

### Тип шрифта
Тип или семейство шрифта определяется параметром fontFamily, который представляет объект FontFamily?

Для определения шрифта FontFamily предоставляет ряд встроенных констант:

- FontFamily.Cursive (курсивный, рукописный шрифт)
- FontFamily.Monospace
- FontFamily.Serif
- FontFamily.SansSerif
- FontFamily.Default (шрифт по умолчанию на текущей платформе)
- FontFamily.SansSerif

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily= FontFamily.Cursive)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Monospace)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.SansSerif)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Serif)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Default)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.1.png)


## Расстояния между символами
Параметр letterSpacing задает расстояние между символами и представляет класс TextUnit. В данном случае мы можем установить расстояние, так как и размер шрифта, с помощью единиц sp или em:

```kotlin
Text("Hello Jetpack Compose!",  fontSize=22.sp, letterSpacing= 1.3.sp)
Text("Hello Jetpack Compose!",  fontSize=22.sp, letterSpacing= 0.3.em)
```

## Декорации текста
Параметр textDecoration позволять задать декорации для текста. Данный параметр принимает объект класса TextDecoration, который предоставляет несколько встроенных значений:

- TextDecoration.LineThrough (зачеркивает текст)
- TextDecoration.Underline (подчеркивает текст)
- TextDecoration.None (отсутствие декораций)

```kotlin
import androidx.compose.ui.text.style.TextDecoration
//...........
Column {
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.LineThrough)
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.Underline)
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.None)
}  
```

![](https://metanit.com/kotlin/jetpack/pics/4.61.png)

### Выравнивание текста
Параметр textAlign управляет выравниванием текста и представляет объект класса TextAlign. В качестве значения этому параметру можно передать значение одного из свойств класса TextAlign:

- TextAlign.Center: выравнивание текста по центру контейнера
- TextAlign.Justify: текст равномерно растягивается по всей ширине контейнера
- TextAlign.End: выравнивание текста по конечному краю контейнера (в зависимости от ориентации текста это может быть левый или правый край)
- TextAlign.Start: выравнивание текста по началу контейнера (в зависимости от ориентации текста это может быть левый или правый край)
- TextAlign.Left: выравнивание текста по левому краю контейнера
- TextAlign.Right: выравнивание текста по правому краю контейнера

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Center", modifier = Modifier.fillMaxWidth(1f) , fontSize=28.sp, textAlign = TextAlign.Center)
                Text("Justify", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Justify)
                Text("Left", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Left)
                Text("Right", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Right)
                Text("Start", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Start)
                Text("End", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.End)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.2.png)


## Усечение текста
Параметр overflow управляет тем, как будет обрабатываться текст при его выходе за границы контейнера. Этот параметр принимает значение класса TextOverflow. В качестве значения параметру можно передать значение одного из свойств данного класса:

- TextOverflow.Clip: выходящий за границы контейнера текст усекается
- TextOverflow.Ellipsis: текст усекается, а в конце текста добавляется многоточие
- TextOverflow.Visible: весь текст может отображаться

## Перенос текста
Параметр softWrap управляет переносом текста. Если он равен true, то текст переносится. Если false, то нет.

## Стиль текста
Параметр style управляет стилем текста. Он предоставляет класс TextStyle , который по сути объединяет ряд вышеупомянутых и несколько дополнительных параметров в одну сущность. Он несколько конструкторов с кучей параметров, например, один из них:

```kotlin
TextStyle(
    color: Color,
    fontSize: TextUnit,
    fontWeight: FontWeight?,
    fontStyle: FontStyle?,
    fontSynthesis: FontSynthesis?,
    fontFamily: FontFamily?,
    fontFeatureSettings: String?,
    letterSpacing: TextUnit,
    baselineShift: BaselineShift?,
    textGeometricTransform: TextGeometricTransform?,
    localeList: LocaleList?,
    background: Color,
    textDecoration: TextDecoration?,
    shadow: Shadow?,
    drawStyle: DrawStyle?,
    textAlign: TextAlign,
    textDirection: TextDirection,
    lineHeight: TextUnit,
    textIndent: TextIndent?,
    platformStyle: PlatformTextStyle?,
    lineHeightStyle: LineHeightStyle?,
    lineBreak: LineBreak,
    hyphens: Hyphens,
    textMotion: TextMotion?
)
```

Основные параметры конструктора в принципе дублируют стандартные свойства компонента Text:

- color: объект Color, который представляет цвет текста. По умолчанию имеет значение Color.Unspecified
- background: объект Color, который фоновый цвет компонента. По умолчанию имеет значение Color.Unspecified
- fontSize: объект TextUnit, который представляет размер шрифта. По умолчанию равен TextUnit.Unspecified
- fontStyle: объект FontStyle?, который представляет стиль шрифта. По умолчанию равен null
- fontWeight: объект FontWeight?, который представляет толщину шрифта. По умолчанию равен null
- fontFamily: объект FontFamily?, который представляет тип шрифта. По умолчанию равен null
- fontFeatureSettings: объект String?, который определяет, как будут применяться настройки толщины шрифта и его наклон (то есть значения параметров fontWeight и fontStyle), если используемый шрифт не поддерживает выделение жирным и (или) наклон. По умолчанию равен null
- letterSpacing: объект TextUnit, который представляет отступы между символами. По умолчанию равен TextUnit.Unspecified
- baselineShift: объект BaselineShift?, который определяет, насколько текст будет сдвигаться относительно базовой линии (baseline). По умолчанию равен null
- textGeometricTransform: представляет применяемые к тексту геометрические трансформации в виде объекта TextGeometricTransform?. По умолчанию равен null
- localeList: объект LocaleList?, который представляет список со специфичными для егиона символами. По умолчанию равен null
- textDecoration: объект TextDecoration?, который представляет тип декораций (например, подчеркивание), применяемых к тексту. По умолчанию равен null
- textAlign: объект TextAlign?, который представляет выравнивание текста. По умолчанию равен null
- textDirection: объект TextDirection?, который представляет направление текста. По умолчанию равен null
- lineHeight: объект TextUnit, который представляет высоту строки текста. По умолчанию равен TextUnit.Unspecified
- shadow: объект Shadow?, который определяет применяемый к тексту эффект тени. По умолчанию равен null

textIndent: объект TextIndent?, который представляет отступ от начала текста. По умолчанию равен null

Поскольку большая часть этих параметров применяется непосредственно в функции компонента Text, рассмотрим некоторые параметры, которые отстуствуют в функции компонента Text.

### Геометрические трансформации

Параметр TextGeometricTransform задает геометрические трансформации текста с помощью объекта TextGeometricTransform:

```kotlin
TextGeometricTransform(scaleX: Float = 1.0f, skewX: Float = 0f)
```

Первый параметр - scaleX указывает на увеличение текста. Если значение меньше 1.0f, то текст сжимается, если больше - то увеличивается.

Второй параметр - skewX указывает на сдвиг текста. Например, точка с координатами (x, y), будет трансформирована в точку (x + y * skewX, y). Значение по умолчанию - 0.0f. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextGeometricTransform
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val content = "Все мы сейчас желаем кушать, потому что утомились"
            val textSize = 25.sp
            Column {
                Text(
                    content,
                    fontSize = textSize,
                    style = TextStyle(textGeometricTransform = TextGeometricTransform(0.5f))
                )
                Text(
                    content,
                    fontSize = textSize,
                    style = TextStyle(textGeometricTransform = TextGeometricTransform(1.5f))
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.4.png)

### Создание тени для текста
Параметр shadow задает затенение текста с помощью объекта Shadow:

```kotlin
Shadow(color: Color, offset: Offset, blurRadius: Float)
```

Первый параметр - color устанавливает цвет тени.

Второй параметр - offset смещение тени в виде объекта Offset.

Третий параметр - blurRadius задает радиус размытия.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shadow
import androidx.compose.ui.text.TextStyle
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(text = "Hello Metanit.com",
                fontSize = 30.sp,
                style = TextStyle(shadow = Shadow(Color.LightGray , Offset(10.0f, 16.5f), 1.0f)))
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.5.png)

### Направление текста
Параметр textDirection устанавливает направление текста и может принимать следующие значения:

- TextDirection.Content: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm

- TextDirection.ContentOrLtr: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm, либо представляет направление слева направо

- TextDirection.ContentOrRtl: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm, либо представляет направление справа налево

- TextDirection.Ltr: текс направлен слева направо

- TextDirection.Rtl: текст направлен справо налево

Например:

```kotlin
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextDirection
//............
Text(
    "Все мы сейчас желаем кушать, потому что утомились",
    fontSize=22.sp,
    style = TextStyle(textDirection = TextDirection.Rtl)
)
```

## TextIndent

Параметр textIndent позволяет установить отступ от первого символа в тексте и от остального текста. Этот параметр представляет класс TextIndent, конструктор которого принимает два значения. Первое значение указывает на отступ от первого символа. Второе значение применяется, если текст многострочный и устанавливает отступ от остальных символов на второй и последующих строках. Для установки отступа применяются единицы sp. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextIndent
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                text = "Все мы сейчас желаем кушать, потому что утомились и уже четвертый час",
                fontSize = 22.sp,
                style = TextStyle(textIndent = TextIndent(50.sp, 25.sp))
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.3.png)









# Аннотированные строки

Аннотированные строки (Annotated strings) позволяют разбить текст на сегменты, каждый из которых будет иметь свою собственную стилизацию. Аннотированные строки представляют объект AnnotatedString. Для его создания применяется функция buildAnnotatedString(), которой передается отображаемый текст и стили.

Поддерживаются два типа стилей: SpanStyle и ParagraphStyle

## SpanStyle
Первый тип стилей представляет объект SpanStyle и используется для стилизации отдельных символов в строке. SpanStyle имеет следующий конструктор:

```kotlin
SpanStyle(
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontWeight: FontWeight? = null,
    fontStyle: FontStyle? = null,
    fontSynthesis: FontSynthesis? = null,
    fontFamily: FontFamily? = null,
    fontFeatureSettings: String? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    baselineShift: BaselineShift? = null,
    textGeometricTransform: TextGeometricTransform? = null,
    localeList: LocaleList? = null,
    background: Color = Color.Unspecified,
    textDecoration: TextDecoration? = null,
    shadow: Shadow? = null,
    platformStyle: PlatformSpanStyle? = null,
    drawStyle: DrawStyle? = null
)
```

Из конструктора мы видим, какие параметры текста устанавливает SpanStylе:

- color: цвет текста

- fontSize: высота шрифта

- fontWeight: вес шрифта.

- fontStyle: стиль шрифта.

- fontSynthesis: устанавливает синтез толщины и/или стиля шрифта, если запрошенную толщину или стиль невозможно найти в предоставленном семействе шрифтов.

- fontFamily: семейство шрифтов.

- fontFeatureSettings: настройки типографии шрифта

- letterSpacing: расстояние между буквами.

- baselineShift: величина, на которую сдвигается текст вверх относительно базовой линии.

- textGeometricTransform: применяемые к тексту геометрические трансформации.

- localeList: список локалей, который используется для выбора специфичных для языка глифов

- background: фоновый цвет текста.

- textDecoration: декорации текста.

- shadow: тень текста.

- platformStyle: платформозависимые параметры стиля.

- drawStyle: стиль заполнения текста.

Для создания и применения SpanStyle используется следующий синтаксис:

```kotlin
buildAnnotatedString {
 
    withStyle(style = SpanStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    withStyle(style = SpanStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    ...................................
}
```

Для добавления сегмента в текст применяется функция append(), в которую передается добавляемая подстрока. Если append() вызывается в контексте функции withStyle(), то к добавляемому тексту применяется стилизация определенная с помощью SpanStyle.

Применение SpanStyle:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
 
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                buildAnnotatedString {
                    withStyle(SpanStyle(fontWeight = FontWeight.Bold, fontSize = 30.sp)) {
                        append("H")
                    }
                    append("ello ")
 
                    withStyle(SpanStyle(fontWeight = FontWeight.Bold, fontSize = 23.sp, color = Color.Blue)) {
                        append("METANIT.COM")
                    }
                }
            )
        }
    }
}
```

В данном случае текст разбивается на три сегмента. Первый сегмент состоит из одной буквы "H", к которой применяется некоторое форматирование. Второй сегмент - "ello" не использует никакого форматирования и добавляется в текст как есть. И затем добавляется третий сегмент, к которому также применяется некоторая стилизация:

![](https://metanit.com/kotlin/jetpack/pics/4.88.png)

## ParagraphStyle
Второй способ стилизации предоставляет класс ParagraphStyle. Он применяется к отдельным параграфам и имеет следующие параметры:

```kotlin
ParagraphStyle(
    textAlign: TextAlign = TextAlign.Unspecified,
    textDirection: TextDirection = TextDirection.Unspecified,
    lineHeight: TextUnit = TextUnit.Unspecified,
    textIndent: TextIndent? = null,
    platformStyle: PlatformParagraphStyle? = null,
    lineHeightStyle: LineHeightStyle? = null,
    lineBreak: LineBreak = LineBreak.Unspecified,
    hyphens: Hyphens = Hyphens.Unspecified,
    textMotion: TextMotion? = null
)
```

- textAlign: выравнивание текста в параграфе
- textDirection: направление текста (слева направо или справо налево)
- lineHeight: высота строк
- textIndent: настройки отступа в параграфе
- platformStyle: платформо-зависимые параметры
- lineHeightStyle: конфигурация для установки высоты строк. Применяется, если параметр lineHeight установлен
- lineBreak: настройка разрыва строк
- hyphens: настройки переносов
- textMotion: настройки размещения текстовых символов, оптимизация для анимированного или статического текста.

Для создания и применения ParagraphStyle используется следующий синтаксис:

```kotlin
buildAnnotatedString {
 
    withStyle(style = ParagraphStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    withStyle(style = ParagraphStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    ...................................
}
```

Применение ParagraphStyle:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
 
import androidx.compose.ui.text.ParagraphStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.style.TextIndent
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                buildAnnotatedString {
                    append("Все мы сейчас желаем кушать, потому что утомились и уже четвертый час, но это")
                    withStyle(ParagraphStyle(lineHeight = 25.sp, textIndent = TextIndent(firstLine = 30.sp, restLine = 8.sp))) {
                        append("Все мы сейчас желаем кушать, потому что утомились и уже четвертый час, но это")
                    }
                },
                fontSize = 22.sp)
        }
    }
}
```

Здесь определены два идентифных параграфа/абзаца, но ко второму применяется дополнительная стилизация, в частности, отступы в 30 пикселей для первой строки и 8 пикселей для остальных строк, а также 25 пикселей высота строки.

![](https://metanit.com/kotlin/jetpack/pics/4.89.png)





















































# Кнопка Button

Для создания кнопок в Jetpack Compose применяется компонент Button, который имеет следующее определение:

```kotlin
@Composable
fun Button(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.shape,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    elevation: ButtonElevation? = ButtonDefaults.buttonElevation(),
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Параметры функции компонента:

- onClick: представляет функцию-обработчик нажатия кнопки
- modifier: представляет объект Modifier, который определяет модификаторы кнопки
- enabled: значение типа Boolean устанавливает, доступна ли кнопка для нажатия. По умолчанию равно true (то есть кнопка доступна для нажатия)
- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }
- elevation: объект типа ButtonElevation?, который определяет анимацию для кнопки. По умолчанию равно ButtonDefaults.elevation()
- shape: объект типа Shape, который устанавливает форму кнопки. По умолчанию равно MaterialTheme.shapes.small
- border: объект типа BorderStroke?, который устанавливает границу кнопки. По умолчанию равно null
- colors: объект типа ButtonColors, который устанавливает цвета кнопки. По умолчанию равно ButtonDefaults.buttonColors()
- contentPadding: объект типа PaddingValues, который устанавливает отступы между границами кнопки и ее содержимым. По умолчанию равно ButtonDefaults.ContentPadding
- content: содержимое кнопки в виде строки Row

Определим простейшую кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {}){
                Text("Click", fontSize = 25.sp)
            }
        }
    }
}
```

Здесь надо отметить следующие моменты. Прежде всего, необходимо определить как минимум один параметр - onClick, однако в данном случае это пустая функция, которая ничего не делает.

Второй момент - кнопка представляет сложный компонент, который может содержать другие компоненты. Таким образом мы можем создавать комплексные кнопки с различным содержимым. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},)
            {
                Column(horizontalAlignment = Alignment.CenterHorizontally){
                    Text("Button Header", fontSize = 18.sp)
                    Text("Button Text", fontSize = 25.sp)
                    Text("Button footer", fontSize = 18.sp)
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.11.png)

### Обработка нажатия
Для обработки нажатия параметру onClick передается функция, которая будет выполняться при нажатии.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val label = remember{mutableStateOf("Click")}
            Button(onClick = {label.value = "Hello"}){
                Text(label.value, fontSize = 28.sp)
            }
        }
    }
}
```

В данном случае мы определяем переменную label, которая будет хранить текст для компонента Text. Однако это не просто строка - объект типа String, а объект MutableState<T>, который создается функцией mutableStateOf(). В эту функцию передается собственно хранимое значение, которое затем можно получить с помощью свойства value объекта MutableState<T> и которое в данном случае мы отображаем в компоненте Text:

```kotlin
Text(label.value, fontSize = 25.sp)
```

А в обработчике нажатия мы изменяем это значение:

```kotlin
onClick = {label.value = "Hello"}
```

В итоге при нажатии на кнопку изменится ее текст.

![](https://metanit.com/kotlin/jetpack/pics/4.7.png)


## Форма кнопки

Как видно из предыдущих скриншотов, по умолчанию кнопка имеет округлую форму. Но с помощью параметра shape можно задать любую другую форму, которая представляет объект интерфейса Shape. Например, для создания прямоугольной формы можно использовать встроенный объект RectangleShape. Для создания кнопки с закругленными углами можно использовать встроенный класс RoundedCornerShape, в конструктор которого передается радиус закругления:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column{
                Button(onClick = {},
                    shape = RectangleShape,     // прямоугольная кнопка
                    modifier = Modifier.padding(10.dp)
                ){ Text("Button 1", fontSize = 28.sp) }
 
                Button(onClick = {},
                    shape = RoundedCornerShape(15.dp),  // округлая кнопка
                    modifier = Modifier.padding(10.dp)
                ){ Text("Button 2", fontSize = 28.sp) }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.63.png)


## elevation
Параметр elevation определяет анимацию для кнопки в разных состояниях и представляет объект интерфейса ButtonElevation. По умолчанию этот параметр в качестве значения имеет компонент ButtonDefaults.elevation:

```kotlin
@Composable
fun elevation(
    defaultElevation: Dp = 2.dp,
    pressedElevation: Dp = 8.dp,
    disabledElevation: Dp = 0.dp
): @Composable ButtonElevation
```

Этот компонент определяет ряд параметров, между значениями которых будет идти анимация при переключении состояния кнопки:

- defaultElevation: определяет анимацию, когда кнопка доступна для нажатия и когда для нее не определено других объектов Interaction, которые определяют состояние для кнопки.
- pressedElevation: определяет анимацию для кнопки в нажатом состоянии.
- defaultElevation: определяет анимацию для кнопки в отключенном состоянии.

## Цвета кнопки
Цвета кнопки задаются с помощью параметра colors, который предоставляет объект ButtonColors и по умолчанию равен компоненту ButtonColors.buttonColors:

```kotlin
@Composable
public final fun buttonColors(
    containerColor: Color = FilledButtonTokens.ContainerColor.toColor(),
    contentColor: Color = FilledButtonTokens.LabelTextColor.toColor(),
    disabledContainerColor: Color = FilledButtonTokens.DisabledContainerColor.toColor()                 
        .copy(alpha = FilledButtonTokens.DisabledContainerOpacity),
    disabledContentColor: Color = FilledButtonTokens.DisabledLabelTextColor.toColor()             
        .copy(alpha = FilledButtonTokens.DisabledLabelTextOpacity)
): ButtonColors
```

- containerColor: определяет фоновый цвет, когда кнопка доступна для нажатия.
- contentColor: определяет цвет содержимого, когда кнопка доступна для нажатия.
- disabledBackgroundColor: определяет фоновый цвет, когда кнопка не доступна для нажатия.
- disabledContentColor: определяет цвет содержимого, когда кнопка не доступна для нажатия.

Для установки цветов кнопки мы можем создать свой класс или компонент интерфейса ButtonColors, либо воспользоваться встроенным компонентом ButtonDefaults.buttonColors. Применим второй способ:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},
                colors = ButtonDefaults.buttonColors(
                    contentColor = Color(0xff004D40),       // цвет текста
                    containerColor = Color(0xff9ed6df))     // цвет фона
            ){ Text("Click", fontSize = 28.sp) }
        }
    }
}
```

Здесь в качестве фонового цвета применяется красный, а в качестве цвета содержимого - черный:

![](https://metanit.com/kotlin/jetpack/pics/4.9.png)

## Граница кнопки
За установки границы кнопки (а именно ее толщины и цвета) отвечает параметр border, который представляет класс BorderStroke со следующими конструкторами:

```kotlin
BorderStroke(width: Dp, color: Color)
BorderStroke(width: Dp, brush: Brush)
```

Первый параметр конструкторов устанавливает толщину границы, а второй - ее цвет с помощью объекта Brush или Color. Например, определим границу у кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.BorderStroke
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},
                colors = ButtonDefaults.buttonColors(containerColor = Color.LightGray, contentColor = Color.Black),
                border = BorderStroke(3.dp, Color.DarkGray)
            ){ Text("Click", fontSize = 28.sp) }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.10.png)

## OutlinedButton
Компонент OutlinedButton также представляет кнопку и имеет тот же набор параметров:

```kotlin
@Composable
fun OutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.outlinedShape,
    colors: ButtonColors = ButtonDefaults.outlinedButtonColors(),
    elevation: ButtonElevation? = null,
    border: BorderStroke? = ButtonDefaults.outlinedButtonBorder,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Он работает похожим образом. Главное отличие от стандартных кнопок - немного иная стилизация, которая по умолчанию добавляет ярко выраженную границу компонента и применяет иную цветоую гамму. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedButton
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            OutlinedButton({}){
                Text("Hello", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.28.png)


## TextButton
Компонент TextButton представляет еще один встроенный тип кнопок, который не имеет границы и имеет прозрачный фон. Он имеет тот же набор параметров, что и Button и OutlinedButton:

```kotlin
@Composable
fun TextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.textShape,
    colors: ButtonColors = ButtonDefaults.textButtonColors(),
    elevation: ButtonElevation? = null,
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.TextButtonContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Используем TextButton:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            TextButton({}){
                Text("Hello", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.29.png)









































# Ввод текста, TextField и OutlinedTextField

Для ввода текста в приложении предназначен компонент TextField. Он имеет несколько версий, возьмем одну из них:

```kotlin
@Composable
fun TextField(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: (@Composable () -> Unit)? = null,
    placeholder: (@Composable () -> Unit)? = null,
    leadingIcon: (@Composable () -> Unit)? = null,
    trailingIcon: (@Composable () -> Unit)? = null,
    prefix: (@Composable () -> Unit)? = null,
    suffix: (@Composable () -> Unit)? = null,
    supportingText: (@Composable () -> Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions.Default,
    singleLine: Boolean = false,
    maxLines: Int = if (singleLine) 1 else Int.MAX_VALUE,
    minLines: Int = 1,
    interactionSource: MutableInteractionSource? = null,
    shape: Shape = TextFieldDefaults.shape,
    colors: TextFieldColors = TextFieldDefaults.colors()
): Unit
```

Основные параметры компонента:

- value: представляет введенное в текстовое поле значение в виде строки, то есть объекта String
- onValueChange: функция обработки изменения введенного значения. Представляет функцию типа (String) -> Unit

- modifier: объект типа Modifier, который задает модификаторы компонента

- enabled: устанавливает, будет ли поле доступно для ввода. Представляет значение типа Boolean. По умолчанию равно true, то есть поле доступно для ввода

- readOnly: устанавливает, будет ли поле доступно только для чтения. Представляет значение типа Boolean. По умолчанию равно false, то есть поле доступно не только для чтения, но для изменения значения

- textStyle: объект типа TextStyle, который устанавливает стиль текста. Значение по умолчанию - LocalTextStyle.current

- label: устанавливает дополнительную метку, которая отображается внутри поля. Для установки метки применяется функция типа () -> Unit. Значение по умолчанию - null

- placeholder: плейсхолдер - временный текст, который отображается внутри поля. Для установки этого текста применяется функция типа () -> Unit. Значение по умолчанию - null

- leadingIcon: устанавливает иконку, которая отображается перед текстом. Для установки применяется функция типа () -> Unit. Значение по умолчанию - null

- trailingIcon: устанавливает иконку, которая отображается после текста. Для установки применяется функция типа () -> Unit. Значение по умолчанию - null

- isError: указывает, является ли текущее введенное в поле значение некорректным. Представляет значение типа Boolean. По умолчанию равно false, то есть введенное значение корректно. Если равно true, то для поля устанавливаютс соответствующие индикаторы - метка, иконка, выделение цветом, которые поддчеркивают, что введенное значение некорректно.

- visualTransformation: объект типа VisualTransformation, который задает визуальные трансформации для вводимого текста. Значение по умолчанию - VisualTransformation.None

- keyboardOptions: объект KeyboardOptions, который задает параметры клавиатуры (например, ее тип). Значение по умолчанию - KeyboardOptions.Default

- keyboardActions: KeyboardActions, который задает набор функций, которые вызываются в ответ на некоторые действия пользователя. Значение по умолчанию - KeyboardActions()

- singleLine: устанавливает, будет ли текст однострочным. По умолчанию равно false, то есть поле будет многосточным

- maxLines: задает максимальное количество строк в поле. По умолчанию равно Int.MAX_VALUE

- minLines: задает минимальное количество строк в поле. По умолчанию равно 1

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для поля ввода. Значение по умолчанию - remember { MutableInteractionSource() }

- shape: представляет объект Shape, который задает форму для поля ввода. Значение по умолчанию - MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize)

- colors: объект TextFieldColors, который задает цвета для поля ввода. Значение по умолчанию - TextFieldDefaults.textFieldColors()

Определение простейшего поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.TextField
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            TextField(value = "Hello Work", onValueChange = {})
        }
    }
}
```

При создании поля необходимо задать как минимум два параметра - текущее значение (параметр value) и функцию обработки ввода текста (параметр onValueChange).

![](https://metanit.com/kotlin/jetpack/pics/4.12.png)

## Обработка ввода текста
Параметр onValueChange принимает функцию обработки ввода текста. Она в качестве параметра получает введенный тек

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
 
            Column {
                Text(message.value, fontSize = 28.sp)
                TextField(
                    value = message.value,
                    textStyle = TextStyle(fontSize=25.sp),
                    onValueChange = {newText -> message.value = newText}
                )
            }
        }
    }
}
```

В данном случае мы определяем переменную message, которая будет хранить введенный текст. Однако это не просто строка. Она будет представлять объект типа MutableState<String>, который создается функцией mutableStateOf(). В дальнейшем мы подробнее разберем объект MutableState и функцию mutableStateOf, а пока достуточно знать, что в эту функцию передается собственно хранимое значение, которое затем можно получить с помощью свойства value объекта MutableState<T>. А функция remember позволяет сохранить это значение.

В коде с помощью свойства value мы привязываем значение переменной к свойству text компонента Text и свойству value компонента TextField:

```kotlin
Text(message.value, fontSize = 28.sp)
TextField( value = message.value,
```
А в функции обработки ввода текста передаем в переменную введенный текст:

```kotlin
onValueChange = {newText -> message.value = newText}
```

В данном случае функция задается с помощью лямбда-выражения, где параметр newText представляет введенный текст.

В итоге при ввода текста в поле изменится значение в переменной message и соответственно изменится текст компонента Text.

![](https://metanit.com/kotlin/jetpack/pics/4.13.png)

## Тип клавиатуры
В зависимости от задач приложения может потребоваться вводить разную информацию - когда буквы, когда числа и т.д. Для упрощения ввода Jetpack Compose предоставляет тип 

- KeyboardType, который позволяет настроить тип клавиатуры с помощью своих свойств:

- KeyboardType.Ascii: предоставляет ввод символов ASCII

- KeyboardType.Email: для ввода электронного адреса

- KeyboardType.Number: для ввода цифр

- KeyboardType.NumberPassword: для ввода пароля из цифр

- KeyboardType.Password: для ввода пароля

- KeyboardType.Phone: для ввода номера телефона

- KeyboardType.Text: предоставляет стандартную клавиатуру

- KeyboardType.Uri: предоставляет клавиатуру для ввода URI

С помощью параметра keyboardOptions, который представляет класс KeyboardOptions, можно задать тип клавиатуры. Например, применим клавиатуру для ввода номера телефона:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val phone = remember{mutableStateOf("")}
 
            TextField(
                phone.value,
                {phone.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.14.png)

## Установка иконок
Параметр leadingIcon задает иконку перед текстом, а параметр trailingIcon - иконку после текста. В качестве значения оба параметра принимают функцию типа () -> Unit. Определим иконки для поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.Icon
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
 
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                leadingIcon = { Icon(Icons.Filled.Check, contentDescription = "Проверено") },
                trailingIcon = { Icon(Icons.Filled.Info, contentDescription = "Дополнительная информация") }
            )
        }
    }
}
```
Для определения иконок применяется встроенный тип androidx.compose.material.Icon, в функцию которого передается значок иконки. В данном случае применяются встроенные иконки Icons.Filled.Check и Icons.Filled.Info. Второй параметр - contentDescription позволяет указать к иконке описание.

![](https://metanit.com/kotlin/jetpack/pics/4.15.png)

## Плейсхолдер
Параметр placeholder устанавливает плейсхолдер или заменитель текста, отображаемый в поле ввода, в виде другого компонента:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                placeholder = { Text("Hello Work!") }
            )
        }
    }
}
```

Установка цветовой палитры поля ввода
Параметр colors, который представляет объект интерфейса TextFieldColors, задает цвета для поля ввода. По умолчанию он принимает компонент TextFieldDefaults.textFieldColors()/TextFieldDefaults.colors(), который устанавливает цвета для самых различных состояний:

- focusedTextColor: цвет, используемый для ввода текста этого текстового поля при фокусировке.
- unfocusedTextColor: цвет, используемый для ввода текста этого текстового поля, когда он не сфокусирован
- disabledTextColor: цвет, используемый для ввода текста этого текстового поля, когда он отключен.
- errorTextColor: цвет, используемый для ввода текста этого текстового поля в состоянии ошибки.
- focusedContainerColor: цвет контейнера текстового поля в фокусе.
- unfocusedContainerColor: цвет контейнера текстового поля, когда он не сфокусирован.

- disabledContainerColor: цвет контейнера текстового поля, когда он отключен.

- errorContainerColor: цвет контейнера текстового поля в состоянии ошибки.

- cursorColor: цвет курсора текстового поля

- errorCursorColor: цвет курсора текстового поля в состоянии ошибки.

- selectionColors: цвета, используемые при выборе входного текста этого текстового поля.

- focusedIndicatorColor: цвет индикатора текстового поля при фокусировке.

- unfocusedIndicatorColor: цвет индикатора текстового поля, когда оно не сфокусировано.

- disabledIndicatorColor: цвет индикатора текстового поля, когда он отключен.

- errorIndicatorColor: цвет индикатора текстового поля в состоянии ошибки.

- focusedLeadingIconColor: цвет ведущего значка текстового поля в фокусе.

- unfocusedLeadingIconColor: цвет ведущего значка текстового поля, когда он не сфокусирован.

- disabledLeadingIconColor: цвет ведущего значка текстового поля, когда он отключен.

- errorLeadingIconColor: цвет ведущего значка текстового поля в состоянии ошибки.

- focusedTrailingIconColor: цвет конечного значка текстового поля в фокусе.

- unfocusedTrailingIconColor: цвет конечного значка текстового поля, когда он не в фокусе.

- disabledTrailingIconColor: цвет конечного значка текстового поля, когда он отключен.

- errorTrailingIconColor: цвет конечного значка текстового поля в состоянии ошибки.

- focusedLabelColor: цвет метки текстового поля при фокусировке.

- unfocusedLabelColor: цвет метки текстового поля, когда оно не сфокусировано.

- disabledLabelColor: цвет метки текстового поля, когда он отключен.

- errorLabelColor: цвет метки текстового поля в состоянии ошибки.

- focusedPlaceholderColor: цвет заполнителя текстового поля в фокусе.

- unfocusedPlaceholderColor: цвет заполнителя текстового поля, когда он не сфокусирован.

- disabledPlaceholderColor: цвет заполнителя текстового поля, когда он отключен.

- errorPlaceholderColor: цвет заполнителя текстового поля в состоянии ошибки.

- focusedSupportingTextColor: вспомогательный цвет текста текстового поля при фокусе.

- unfocusedSupportingTextColor: вспомогательный цвет текста текстового поля, когда он не сфокусирован

- disabledSupportingTextColor: вспомогательный цвет текста текстового поля, когда он отключен.

- errorSupportingTextColor: вспомогательный цвет текста текстового поля в состоянии ошибки.

- focusedPrefixColor: цвет префикса текстового поля в фокусе.

- unfocusedPrefixColor: цвет префикса текстового поля, когда оно не сфокусировано.

- disabledPrefixColor: цвет префикса текстового поля, когда он отключен.

- errorPrefixColor: цвет префикса текстового поля в состоянии ошибки.

- focusedSuffixColor: цвет суффикса текстового поля в фокусе.

- unfocusedSuffixColor: цвет суффикса текстового поля, когда оно не сфокусировано.

- disabledSuffixColor: цвет суффикса текстового поля, когда он отключен.

- errorSuffixColor: цвет суффикса текстового поля в состоянии ошибки.

Мы можем использовать этот компонент для настройки цветовой гаммы поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                colors = TextFieldDefaults.colors(
                    unfocusedContainerColor = Color(0xffeeeeee),
                    unfocusedTextColor = Color(0xff888888),
                    focusedContainerColor = Color.White,
                    focusedTextColor = Color(0xff222222),
                )
            )
        }
    }
}
```

В данном случае для текста и фона устанавливаются разные цвета в зависимости от того, получило текстовое поле фокус или нет:

![](https://metanit.com/kotlin/jetpack/pics/4.16.png)

## OutlinedTextField
Компонент OutlinedTextField во многом похож на TextField за тем исключением, что он добавляет границу вокуг поля ввода. Простейшее определение компонента OutlinedTextField:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedTextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            OutlinedTextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  30.sp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.17.png)


В функции компонента OutlinedTextField мы видим, что в отличие от TextField, меняется стандартное значение для последнего параметра - colors, который устанавливает цвета. Теперь он по умолчанию равен компоненту TextFieldDefaults.outlinedTextFieldColors(). Фактически здесь мы можем установить те же самые цвета за тем исключением, что мы также можем настроить текст границы с помощью таких параметов как focusedBorderColor, unfocusedBorderColor, disabledBorderColor и errorBorderColor, который позволяют установить цвет границы для различных состояний поля ввода. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            OutlinedTextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  30.sp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor= Color(0xff16a085), // цвет при получении фокуса
                    unfocusedBorderColor = Color(0xffcccccc)  // цвет при отсутствии фокуса
                )
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.62.png)
























# Modifier.toggleable

Модификатор Modifier.toggleable устанавливает для компонента два состояния и позволяет переключаться между этими состояниями. Подобные компоненты в этом плане похожи на флажки (checkbox), в которых можно поставить отметку, а можно ее снять, тем самым изменив состояние флажка. Функция модификатора принимает следующие параметры:

```kotlin
fun Modifier.toggleable(
    value: Boolean,
    enabled: Boolean = true,
    role: Role? = null,
    onValueChange: (Boolean) -> Unit
): Modifier
```

- value хранит состояние компонента в виде объекта Boolean, поэтому состояние может принимать только два значения: true и false

- enabled указывает, будет ли компонент доступен для выбора. Если он имеет значение true (значение по умолчанию), то компонент будет доступен

- role представляет объект Role, который представляет тип элемента интерфейса

- onValueChange представляет функцию типа (Boolean) -> Unit, которая вызывается при нажатии на компонент

Создадим переключаемый компонент на основе компонента Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.selection.toggleable
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var checked = remember { mutableStateOf(false) }
            Text(
                modifier = Modifier.toggleable(value = checked.value, onValueChange = { checked.value = it }),
                text = checked.value.toString(),
                fontSize = 30.sp
            )
        }
    }
}
```

Для отслеживания состояния создается переменная checked, которая по умолчанию хранит значение false. Это значение передается в функцию модификатора toggleable параметру value. А с помощью другого параметра - onValueChange задаем функцию, которая получает новое состояние через параметр it и передает его переменной checked. Таким образом, при нажатии состояние компонента будет переключаться.

![](https://metanit.com/kotlin/jetpack/pics/4.27.png)

Мы можем пойти дальше и сделать с помощью модификатора что-то наподобие стандартного флажка или чекбокса:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.toggleable
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var checked = remember { mutableStateOf(false) }
            Row{
                Box(modifier = Modifier.padding(10.dp).size(30.dp)
                    .background(Color.Black).padding(1.dp)
                    .background(
                        if(checked.value) Color.Black
                        else Color.White
                    ).toggleable(value = checked.value, onValueChange = { checked.value = it }))
                Text(checked.value.toString(),fontSize = 30.sp)
            }
        }
    }
}
```

В данном случае для изменения состояния применяется компонент Box. Для этого компонента устанавливаем отступ от границ контейнера и размер

```kotlin
Modifier.padding(10.dp).size(30.dp)
```

Далее устанавливаем границу черным цветом в 1 пиксель:

```kotlin
.background(Color.Black).padding(1.dp)
```

Затем устанавливаем фон компонента - он привязан к состоянию:

```kotlin
.background(
    if(checked.value) Color.Black
    else Color.White
)
```

То есть если состояние равно true, то Box получает черный цвет, иначе - белый цвет.

И далее с помощью модификатора toggable устанавливаем переключение состояния по нажатию на Box:

```kotlin
.toggleable(value = checked.value, onValueChange = { checked.value = it }))
```

Тектовое поле просто выводит значение состояния:

![](https://metanit.com/kotlin/jetpack/pics/4.64.png)






















































# Checkbox

Компонент Checkbox представляет флажок, который может быть в отмеченном и неотмеченном состоянии. Его функция принимает следующие параметры:


```kotlin
@Composable
fun Checkbox(
    checked: Boolean,
    onCheckedChange: ((Boolean) -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: CheckboxColors = CheckboxDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

- checked: указывает, будет ли отмечен флажок. Представляет значение Boolean. Если равен true, то флажок отмечен.

- onCheckedChange: представляет функции типа (Boolean) -> Unit, которая выполняется при изменении состояния флажка (установки или снятия отметки). В качестве параметра в функцию передается новое состояние флажка.

- modifier: объект Modifier, который устанавливает для флажка модификаторы

- enabled: указывает, будет ли доступен флажок. Представляет значение Boolean и по умолчанию равен true (то есть флажок будет доступен).

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для флажка. По умолчанию равен remember { MutableInteractionSource() }.

- colors: объект CheckboxColors, который задает цвета для флажка. По умолчанию равен CheckboxDefaults.colors().

Простейший флажок:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Checkbox
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Checkbox(
                checked = checkedState.value,
                onCheckedChange = { checkedState.value = it }
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.65.png)


Здесь надо отметить два момента. Прежде всего для компонента Checkbox необходимо задать как минимум два параметра: checked и onCheckedChange. Для этого в примере выше определена переменная checkedState, которая представляет состояние флажка (отмечен или нет). Эта переменная представляет объект типа MutableState<Boolean>, который создается функцией mutableStateOf(). В эту функцию передается собственно хранимое значение - в данном случае значение true, которое затем можно получить с помощью свойства value объекта MutableState<T>. А функция remember позволяет сохранить это значение.

В коде с помощью свойства value мы привязываем значение переменной к свойству checked:

```kotlin
checked = checkedState.value
```

А в функции обработки изменения состояния флажка с помощью параметра it передаем в переменную новое состояние флажка (если отмечен - true, если отметка отсутвует - false):

```kotlin
onCheckedChange = { checkedState.value = it }
```

Второй момент, который надо отметить, флажок не предоставляет встроенных возможностей по установке текстовой метки. Однако, как правило, при флажке идет некоторый текст, который некоторым образом объясняет назначение флажка. Но в Jetpack Compose подобную текстовую метку нам надо устанавливать дополнительно:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Checkbox
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Row{
                Checkbox(
                    checked = checkedState.value,
                    onCheckedChange = { checkedState.value = it }
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.18.png)

Из параметров следует отметить параметр colors, который представляет тип CheckboxColors и устанавливает цветовую гамму флажка. По умолчанию он хранит компонент CheckboxDefaults.colors

![](@Composable
fun colors(
    checkedColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.SelectedContainerColor),
    uncheckedColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.UnselectedOutlineColor),
    checkmarkColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.SelectedIconColor),
    disabledCheckedColor: Color = MaterialTheme.colorScheme                 
        .fromToken(CheckboxTokens.SelectedDisabledContainerColor)                 
        .copy(alpha = CheckboxTokens.SelectedDisabledContainerOpacity),
    disabledUncheckedColor: Color = MaterialTheme.colorScheme                 
        .fromToken(CheckboxTokens.UnselectedDisabledOutlineColor)                 
        .copy(alpha = CheckboxTokens.UnselectedDisabledContainerOpacity),
    disabledIndeterminateColor: Color = disabledCheckedColor
): @Composable CheckboxColors)

Его параметры:

- checkedColor: цвет флажка, когда он находится в отмеченном состоянии

- uncheckedColor: цвет флажка, когда он неотмечен

- checkmarkColor: цвет отметки флажка

- disabledCheckedColor: цвет флажка, когда он отмечен, но не доступен для нажатия

- disabledUncheckedColor: цвет флажка, когда он не отмечен и не доступен для нажатия

- disabledIndeterminateColor: цвет флажка типа TriStateCheckbox, когда он не доступен и одновременно находится в состоянии ToggleableState.Indeterminate

Используем данный параметр для настройки цветов:


```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CheckboxDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Row{
                Checkbox(
                    checked = checkedState.value,
                    onCheckedChange = { checkedState.value = it },
                    colors  = CheckboxDefaults.colors(checkedColor = Color(0xffffb6c1), checkmarkColor = Color.Red)
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.19.png)


## TriStateCheckbox
Компонент TriStateCheckbox расширяет Checkbox, добавляя возможность установить флажок в третье - неопределенное состояние

```kotlin
@Composable
fun TriStateCheckbox(
    state: ToggleableState,
    onClick: (() -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: CheckboxColors = CheckboxDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

Он принимает почти те же параметры, что и Checkbox, за исключением двух параметров. Так, параметр state представляет тип ToggleableState и устанавливает состояние флажка с помощью следующих значений:

- ToggleableState.Indeterminate: неопределенное состояние
- ToggleableState.Off: отметка снята
- ToggleableState.On: флажок отмечен

Второй отличающийся параметр - onClick задает функцию изменения состояния флажка.

Определим простейший компонент TriStateCheckbox:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.material3.TriStateCheckbox
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.state.ToggleableState
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(ToggleableState.Indeterminate) }
            Row{
                TriStateCheckbox(
                    state = checkedState.value,
                    onClick = {
                        if (checkedState.value == ToggleableState.Indeterminate || checkedState.value == ToggleableState.Off)
                            checkedState.value = ToggleableState.On
                        else checkedState.value = ToggleableState.Off
                    }
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.20.png)




































# Выбираемый компонент и модификатор selectable

Модификатор Modifier.selectable позволяет сделать компонент выбираемым (или выделяемым). Данный модификатор имеет следующие параметры:

```kotlin
fun Modifier.selectable(
    selected: Boolean,
    enabled: Boolean = true,
    role: Role? = null,
    onClick: () -> Unit
): Modifier
```

- selected указывает, будет ли компонент выбран. Если он имеет значение true, то компонент выбран

- enabled указывает, будет ли компонент доступен для выбора. Если он имеет значение true (значение по умолчанию), то компонент будет доступен

- role представляет тип элемента графического интерфейса

- onClick представляет функцию типа () -> Unit, которая вызывается при нажатии на компонент

Рассмотрим простейший пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.selection.selectable
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val selected = remember { mutableStateOf(true) }
            Text(
                text= selected.value.toString(),
                fontSize = 30.sp,
                modifier = Modifier.selectable(
                    selected = selected.value,
                    onClick = { selected.value = !selected.value }
                )
            )
        }
    }
}
```

Здесь для компонента Text устанавливается модификатор Modifier.selectable:

```kotlin
modifier = Modifier.selectable(
    selected = selected.value,
    onClick = { selected.value = !selected.value }
)
```

Параметр selected модификатора, который указывает, будет ли выбран компонент, получает значение из переменной selected, которая представляет объект MutableState<Boolean>, то есть значение selected.value будет равно true или false.

А параметр onClick, который задает функцию, выполняемую при нажатии на компонент, будет переключать значение selected.value. То есть если это значение было равно true, оно становится равным false и наоброт.

![](https://metanit.com/kotlin/jetpack/pics/4.24.png)


## Выбор из группы компонентов
Обычно данный модификатор применяется для настройки выбора из нескольких компонентов. В этом случае все эти компоненты рассматриваются как единая группа, из которой одномоменто можно выбрать только один компонент. Рассмотрим небольшой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.selectable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val colors = listOf(Color.Red, Color.LightGray, Color.Blue)
            val selectedOption = remember { mutableStateOf(colors[0]) }
            Column(modifier =Modifier.padding(20.dp)) {
                Box( Modifier.padding(10.dp).size(100.dp).background(color = selectedOption.value))
 
                colors.forEach { color ->
                    val selected = selectedOption.value == color
                    Box(
                        Modifier.padding(8.dp)
                            .size(60.dp)
                            .background(color = color)
                            .selectable(
                                selected = selected,
                                onClick = { selectedOption.value = color }
                            )
                            .border(
                                width= if(selected) 3.dp else 0.dp,
                                color = Color.Black
                            )
                    )
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.25.png)

В данном случае у нас три варианта выбора, которые описываются списком colors:

```kotlin
val colors = listOf(Color.Red, Color.Green, Color.Blue)
```

Для хранения текущего выбранного элемента создаем переменную selectedOption, которая по умолчанию указывает на первый элемент из списка:

```kotlin
val selectedOption = remember { mutableStateOf(colors[0]) }
```

Каждый элемент списка представляет описание цвета. С помощью функции forEach() пробегаемся по каждому И для каждого из этих элементов мы создаем отдельный элемент Box:

```kotlin
colors.forEach { color ->
    val selected = selectedOption.value == color
    Box(
```

Условно говоря, закрепляем за каждым компонентом Box свой элемент из списка colors. В функцию forEach() передается лямбда-выражение, в которое в качестве параметра передается текущий элемент списка. Затем устанавливаем переменную selected, которая для данного элемента будет указывать, выбран ли данный элемент (иначе говоря равен ли он значению selectedOption.value)

В модификаторе selectable устанавливаем, что компонент выбран, если выбран текущий элемент списка colors:

```kotlin
.selectable(
    selected = selected,
    onClick = { selectedOption.value = color }
)
```

А в параметру onClick передается функция, которая при нажатии на данный компонент присваивает переменной selectedOption значение текщего элемента списка.

## Комплексные компоненты
Подобным образом мы можем определить список объектов своих классов и посредством выбора компонентов выбирать один из объектов из списка. Например, изменим код следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.selectable
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin",0xff16a085),
                Language("Java",0xff2980b9),
                Language("JavaScript",0xffe74c3c),
                Language("Python", 0xffd35400))
            val selectedOption = remember { mutableStateOf(langs[0]) }
            Column{
 
                Row(modifier = Modifier.padding(10.dp).fillMaxWidth()){
                    Box( Modifier.padding(10.dp).size(100.dp).background(color = Color(selectedOption.value.hexColor)))
                    Text(text = selectedOption.value.name, fontSize = 36.sp, modifier = Modifier.padding(10.dp))
                }
 
                for(lang in langs){
                    val selected = selectedOption.value == lang
                    Row(modifier = Modifier.padding(10.dp).fillMaxWidth()
                        .selectable(selected = selected, onClick = { selectedOption.value = lang }),
                        verticalAlignment = Alignment.CenterVertically
                    ){
                        Box(
                            Modifier.padding(8.dp)
                                .size(60.dp)
                                .background(Color(lang.hexColor))
                                .border(
                                    width= if(selected){2.dp} else{0.dp},
                                    color = Color.Black
                                )
                        )
                        Text(text = lang.name, fontSize = 28.sp)
                    }
                }
            }
        }
    }
}
data class Language(val name: String, val hexColor:Long)
```

![](https://metanit.com/kotlin/jetpack/pics/4.26.png)


В данном случае создаем класс Language, который описывает применяемые данные и который хранит два значения - имя языка программирования и шестнадцатериченое значение цвета. В коде MainActivity также создаем список данных, только теперь каждый элемент списка представляет объект Language. Далее проходим по каждому из этих объектов и для каждого из них создаем строку Row. Каждая строка Row содержит компонент Box, который отображает цвет языка, и компонент Text, который отображает название языка программирования.


# RadioButton

Компонент RadioButton представляет переключатель или радиокнопку и служит для создания группы радиокнопок, из которых одномоментно можно выбрать только один переключатель. Этот компонент имеет следующие параметры:

```kotlin
@Composable
fun RadioButton(
    selected: Boolean,
    onClick: (() -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: RadioButtonColors = RadioButtonDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

- selected: указывает, будет ли отмечена радиокнопка. Представляет значение Boolean. Если равен true, то радиокнопка отмечена.

- onClick: представляет функцию типа () -> Unit, которая выполняется при нажатия на радиокнопку.

- modifier: объект Modifier, который устанавливает для радиокнопки модификаторы

- enabled: указывает, будет ли доступна радиокнопка. Представляет значение Boolean и по умолчанию равен true (то есть радиокнопка будет доступна).

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для радиокнопки. По умолчанию равен remember { MutableInteractionSource() }.

- colors: объект RadioButtonColors, который задает цвета для радиокнопки. По умолчанию равен RadioButtonDefaults.colors().

Создадим группу из двух радиокнопок:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val state = remember { mutableStateOf(true) }
            Column(Modifier.selectableGroup())
            {
                RadioButton(
                    selected = state.value,
                    onClick = { state.value = true }
                )
                RadioButton(
                    selected = !state.value,
                    onClick = { state.value = false }
                )
            }
        }
    }
}
```

Для создании группы радиокнопок, которые рассматриваются именно как группа или единое целое, у контейнера - компонента Column или Row устанавливается модификатор Modifier.selectableGroup(). В данном случае радиокнопки помещаются в Column и соответственно будут располагаться в столбик:

```kotlin
Column(Modifier.selectableGroup())
```

Хотя также можно было бы расположить радиокнопки в строку, поместив в контейнер Row.

Для хранения состояния радиокнопок определяется переменная state, которая представляет тип MutableState<Boolean>:

```kotlin
val state = remember { mutableStateOf(true) }
```

С помощью свойства value получаем хранимое в переменной значение (true или false) и передаем его параметру selected радиокнопок:

```kotlin
selected = state.value
```

Но поскольку только одна радиокнопка одномоментно может быть выбрана, то другой радиокнопке передается противоположеное значение:

```kotlin
selected = !state.value
```

А в обработчике нажатия из параметра onClick изменяем данное значение:

```kotlin
onClick = { state.value = true }
```

![](https://metanit.com/kotlin/jetpack/pics/4.21.png)

## Добавление текстовых меток к радиокнопкам
В примере выше мы видим, что для радиокнопок, как и для флажков, неопределяется никакой текстовой метки, которая несла бы самую минимальную информацию о радиокнопке. В этом случае необходимо самостоятельно комбинировать радиокнопку с текстовыми компонентами:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val state = remember { mutableStateOf(true) }
            Column {
                Text(text = if(state.value) {"Kotlin"} else {"Java"}, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    Row{
                        RadioButton(
                            selected = state.value,
                            onClick = { state.value = true }
                        )
                        Text("Kotlin", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
                    }
                    Row{
                        RadioButton(
                            selected = !state.value,
                            onClick = { state.value = false }
                        )
                        Text("Java", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
                    }
                }
            }
        }
    }
}
```

В данном случае, если state хранит true, то выбирается радиокнопка с языком Kotlin, если state хранит false, то выбирается радиокнока с языком Java.

![](https://metanit.com/kotlin/jetpack/pics/4.22.png)

## Обработка выбора варианта в группе радиокнопок

Выше приведенный пример довольно прост в том плане, что у нас только две радиокнопки - когда у одной кнопки параметр selected равен true, у другой равен false. В этом плане довольно просто задать логику переключения между радиокнопками. Однако что если у нас 3 и более переключателей? Рассмотрим следующий пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
            val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
            Column {
                Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    languages.forEach { text ->
                        Row( Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)
                        {
                            RadioButton(
                                selected = (text == selectedOption),
                                onClick = { onOptionSelected(text) }
                            )
                            Text( text = text, fontSize = 24.sp )
                        }
                    }
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.23.png)

В примере выше прежде всего все данные, которые будут представлять радиокнопки, помещаются в список languages:

```kotlin
val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
```

Здесь четыре элемента, соответственно мы будем создавать четыре радиокнопки для каждого из этих элементов.

Далее мы получаем объект MutableState<String>, который необходим для и отслеживания выбранного значения:

```kotlin
val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
```

В функцию mutableStateOf() передается первый элемент из списка, то есть по умолчанию будет выбран первый элемент списка languages.

Однако мы не просто берем объект MutableState<String>, а раскладываем его на два компонента - selectedOption и onOptionSelected. Значение selectedOption будет представлять отслеживаемый объектом MutableState<String> элемент списка languages. А onOptionSelected - функция типа (String) -> Unit, которая будет вызываться при изменении значения в MutableState<String> и которая в качестве параметра будет получать новое значение.

Выбранный элемент из selectedOption выводится в верхний компонент Text:

```kotlin
Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
```

Как и в примерах выше, чтобы задать группу выбираемых компонентов, для контейнера (в данном случае компонента Column) устанавливается модификатор selectableGroup:

```kotlin
Column(Modifier.selectableGroup()){ ........... }
```

Далее перебираем список languages с помощью функции forEach(), в которую передается функция, вызываемая для каждого перебираемого элемента:

```kotlin
languages.forEach { text ->
    Row( Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)
    {
        RadioButton(
            selected = (text == selectedOption),
            onClick = { onOptionSelected(text) }
        )
        Text( text = text, fontSize = 24.sp )
    }
}
```

Фактически в данном случае за каждой строкой закрепляется определенный элемент из списка languages. И радиокнопка является выбранный, если значение selectedOption совпадает со значением элемента из списка languages, закрепленным за данным компонентом Row:

```kotlin
selected = (text == selectedOption)
```

При нажатии на компонент срабатывает функция из параметра onClick, в которой вызывается функция onOptionSelected:

```kotlin
onClick = { onOptionSelected(text) }
```

В функции onOptionSelected передается закрепленный за компонентом Row элемент из списка languages, благодаря чему изменится выбранный элемент.

## Выбор всей строки
Пример выше прекрасно работает, однако имеет один недостаток: чтобы выбрать радиокноку, необходимо пальцем попасть в этот небольшой кружок, который представляет радиокнопку. Было бы гораздо лучше, если бы мы могли нажать на любой место в строке, например, на текстовую метку, и тем самым выбрать радиокноку. Для этого изменим код следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
            val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
            Column {
                Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    languages.forEach { text ->
                        Row( Modifier.fillMaxWidth()
                            .selectable(
                                selected = (text == selectedOption),
                                onClick = { onOptionSelected(text) }),
                            verticalAlignment = Alignment.CenterVertically)
                        {
                            RadioButton(
                                selected = (text == selectedOption),
                                onClick = { }
                            )
                            Text( text = text, fontSize = 24.sp )
                        }
                    }
                }
            }
        }
    }
}
```
Ключевым моментом здесь является установка модификатора Modifier.selectable:

```kotlin
Row(
    Modifier.selectable(
        selected = (text == selectedOption),
        onClick = { onOptionSelected(text) }
),
```

Модификатор Modifier.selectable() делает компонент (в данном случае компонент Row) выделяемым. То есть мы можем выбрать не просто радиокнопку, а всю строку. В примере выше компонент Row является выбранным, если значение selectedOption совпадает со значением элемента из списка languages, закрепленным за данным компонентом Row:

```kotlin
selected = (text == selectedOption)
```

При нажатии на компонент срабатывает функция из параметра onClick, в которой вызывается функция onOptionSelected:

```kotlin
onClick = { onOptionSelected(text) }
```

В функции onOptionSelected передается закрепленный за компонентом Row элемент из списка languages, благодаря чему изменится выбранный элемент.

Кроме того, также надо настроить радиокнопки, которые выводятся в строке Row:

```kotlin
RadioButton(
    selected = (text == selectedOption),
    onClick = {}
)
```

Для выбора радиокнопки действует тот же алгоритм, что и для контейнера Row: радиокнопка выбрана, если текущий элемент из languages совпадает со значением selectedOption.

И поскольку выбор элемента обрабатывается в родительском контейнере Row, то нет смысла обрабатывать выбор элемента в радиокнопке, поэтому ее параметру onClick передается значение {} (по сути пустая функция).

Таким образом, внешне мы получим тот же визуальный интерфейс, только теперь для выделения радиокнопки достаточно нажать на любое место в строке.

## Настройка цвета радиокнопок
За настройку цвета радиокнопок отвечает параметр colors компонента RadioButton. Для установки этого параметра можно использовать встроенную функцию RadioButtonDefaults.colors(), которая имеет следующее определение:

```kotlin
@Composable
public final fun colors(
    selectedColor: Color = RadioButtonTokens.SelectedIconColor.toColor(),
    unselectedColor: Color = RadioButtonTokens.UnselectedIconColor.toColor(),
    disabledSelectedColor: Color = RadioButtonTokens.DisabledSelectedIconColor             
        .toColor()             
        .copy(alpha = RadioButtonTokens.DisabledSelectedIconOpacity),
    disabledUnselectedColor: Color = RadioButtonTokens.DisabledUnselectedIconColor             
        .toColor()             
        .copy(alpha = RadioButtonTokens.DisabledUnselectedIconOpacity)
): RadioButtonColors
```

Таким образом, для отдельной радиокнопки мы можем установить 4 цвета:

- selectedColor: цвет, когда кнопка выбрана
- unselectedColor: цвет, когда кнопка не выбрана
- disabledSelectedColor: цвет, когда кнопка выбрана, но не доступна
- disabledUnselectedColor: цвет, когда кнопка не выбрана и не доступна

Например:

```kotlin
RadioButton(
    selected = (text == selectedOption),
    onClick = { },
    colors = RadioButtonDefaults.colors(selectedColor = Color.DarkGray, unselectedColor = Color.LightGray)
)
```







































# Иконки и компоненты IconButton и IconToggleButton

Компонент IconButton представляет кликабельную иконку, по нажатию на которую можно выполнить некоторые действия. То есть, фактически он объединяет иконку и кнопку. Обычно этот компонент применяется в панелях инстументов.

Данный компонент имеет следующие параметры:

```kotlin
@Composable
fun IconButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable () -> Unit
): Unit
```

Параметры функции компонента:

- onClick: представляет функцию-обработчик нажатия кнопки

- modifier: предствляет объект Modifier, который определяет модификаторы кнопки

- enabled: значение типа Boolean устанавливает, доступна ли кнопка для нажатия. По умолчанию равно true (то есть кнопка доступна для нажатия)

- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }

- content: содержимое кнопки - обычно представляет иконку в виде объекта типа Icon. В качестве иконки можно использовать встроенные иконки из пакета androidx.compose.material.icons.Icons. А также можно создавать и использовать свои иконки.

Определим простейшую кнопку-иконку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            IconButton(onClick = { }) {
                Icon(Icons.Filled.Info, contentDescription = "Информация о приложении")
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.30.png)

Компонент Icon, который задает иконку, имеет ряд версий:

```kotlin
@Composable
fun Icon(
    imageVector: ImageVector,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
): Unit
 
@Composable
fun Icon(
    bitmap: ImageBitmap,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
): Unit
 
@Composable
fun Icon(
    painter: Painter,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current.copy(alpha = LocalContentAlpha.current)
): Unit
```

Во всех трех версиях первый параметр представляет рисунок, который отображается на иконке. В примере выше этому параметру передавалась встроенная иконка Icons.Filled.Info. Jetpack Compose располагает большим набором встроенных иконок. Весь этот набор можно посмотреть по ссылке Icons

Второй параметр - contentDescription задает описание иконки, которое используется сервисами accessibility. Данное описание нигде в визуальном интерфейсе не оображается и служит только для служебных целей.

Третий параметр - modifier - объект Modifier, который, как и для других компонентов, задает модификаторы для данного компонента.

Четвертый параметр - tint устанавливает цвет иконки.

Например, немного изменить иконку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.size
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            IconButton(onClick = {  }) {
                Icon(
                    Icons.Filled.Info,
                    contentDescription = "Информация о приложении", modifier = Modifier.size(80.dp),
                    tint = Color.Red
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.31.png)

## IconToggleButton
Компонент IconToggleButton фактически предоставляет IconButton, который может находиться в двух состояниях. Он принимает следующие параметры:

```kotlin
@Composable
fun IconToggleButton(
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    content: () -> Unit
): Unit
```

Параметры функции компонента:

- checked: значение типа Boolean, которое указывает, будет ли компонент выбран (значение true) или нет (false)

- onCheckedChange: представляет функцию-обработчик нажатия кнопки

- modifier: представляет объект Modifier, который определяет модификаторы кнопки

- enabled: значение типа Boolean устанавливает, доступна ли кнопка для нажатия. По умолчанию равно true (то есть кнопка доступна для нажатия)

- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }

- content: содержимое кнопки - обычно представляет иконку в виде объекта типа Icon. В качестве иконки можно использовать встроенные иконки из пакета androidx.compose.material.icons.Icons. А также можно создавать и использовать свои иконки.

Пример с IconToggleButton:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.Icon
import androidx.compose.material3.IconToggleButton
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checked = remember { mutableStateOf(false) }
            Row(verticalAlignment = Alignment.CenterVertically){
                IconToggleButton(checked = checked.value, onCheckedChange = { checked.value = it }) {
                    Icon(
                        Icons.Filled.Info,
                        contentDescription = "Информация о приложении",
                        tint = if (checked.value) Color(0xFFEC407A) else Color(0xFFB0BEC5)
                    )
                }
                Text(
                    text = if(checked.value) "Выбрано" else "Не выбрано",
                    fontSize = 28.sp
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.32.png)

В данном случае для отслеживания, выбрана ли кнопка, определена переменная checked, в зависимости от значения которой устанавливаются тест компонента Text и цвет иконки в IconToggleButton



















# FloatingActionButton и ExtendedFloatingActionButton


Компонент FloatingActionButton представляет кнопку, которая обычно располагается внизу экрана поверх основного содержимого и приглашает к некотором действию. Этот компонент имеет следующие параметры:

```kotlin
@Composable
fun FloatingActionButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    shape: Shape = FloatingActionButtonDefaults.shape,
    containerColor: Color = FloatingActionButtonDefaults.containerColor,
    contentColor: Color = contentColorFor(containerColor),
    elevation: FloatingActionButtonElevation = FloatingActionButtonDefaults.elevation(),
    interactionSource: MutableInteractionSource? = null,
    content: @Composable () -> Unit
): Unit
```

Параметры функции компонента:

- onClick: представляет функцию-обработчик нажатия кнопки

- modifier: предствляет объект Modifier, который определяет модификаторы кнопки

- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }

- elevation: объект типа FloatingActionButtonElevation, который определяет анимацию при нажатии кнопки. По умолчанию равно FloatingActionButtonDefaults.elevation()

- shape: объект типа Shape, который устанавливает форму кнопки. По умолчанию равно MaterialTheme.shapes.small.copy(CornerSize(percent = 50))

- containerColor: фоновый цвет компонента. По умолчанию имеет значение MaterialTheme.colors.secondary

- contentColor: цвет содержимого компонента. По умолчанию устанавливается функцией contentColorFor(backgroundColor), которая устанавливает цвет в зависимости от фонового цвета

- content: содержимое кнопки - обычно представляет иконку в виде объекта типа Icon. В качестве иконки можно использовать встроенные иконки из пакета androidx.compose.material.icons.Icons. А также можно создавать и использовать свои иконки.

Определим простейший элемент FloatingActionButton:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            FloatingActionButton(onClick = { }) {
                Icon(Icons.Filled.Add, contentDescription = "Добавить")
            }
        }
    }
}
```

В данном случае кнопка никак не обрабатывает нажатия и просто отображает иконку Icons.Filled.Add из стандартного набора иконок.

![](https://metanit.com/kotlin/jetpack/pics/4.33.png)

Как и в обычных кнопках, мы можем обработать нажатия:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column{
                val label = remember{ mutableStateOf("")}
                FloatingActionButton(onClick = {label.value = "Добавлено!" }, modifier = Modifier) {
                    Icon(Icons.Filled.Add, contentDescription = "Добавить")
                }
                Text(text = label.value, fontSize = 28.sp)
            }
        }
    }
}
```

ExtendedFloatingActionButton
Jetpack Compose также предоставляет похожий компонент, который по сути расширяет FloatingActionButton - компонент ExtendedFloatingActionButton:

```kotlin
@Composable
fun ExtendedFloatingActionButton(
    text: @Composable () -> Unit,
    icon: @Composable () -> Unit,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    expanded: Boolean = true,
    shape: Shape = FloatingActionButtonDefaults.extendedFabShape,
    containerColor: Color = FloatingActionButtonDefaults.containerColor,
    contentColor: Color = contentColorFor(containerColor),
    elevation: FloatingActionButtonElevation = FloatingActionButtonDefaults.elevation(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

В отличие от FloatingActionButton вместо одного параметра content для установки содержимого применяются два параметра:

- text: устанавливает текст кнопки

- icon: устанавливает иконку кнопку

Простейший пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.ExtendedFloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ExtendedFloatingActionButton(
                icon = { Icon(Icons.Filled.Add, contentDescription = "Добавить") },
                text = { Text("Добавить") },
                onClick = {}
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.34.png)

Добавим обработку нажатия:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.ExtendedFloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val added = remember{ mutableStateOf(false)}
            ExtendedFloatingActionButton(
                icon = {
                    Icon(
                        if(added.value) Icons.Filled.Delete else Icons.Filled.Add,
                        contentDescription = "Добавить"
                    ) },
                text = { Text(if(added.value) "Удалить" else "Добавить") },
                onClick = {added.value = !added.value}
            )
        }
    }
}
```

В данном случае по нажатию изменяем текст и иконку кнопки:

![](https://metanit.com/kotlin/jetpack/pics/4.35.png)



# Панели приложения TopAppBar и BottomAppBar

По умолчанию Jetpack Compose предоставляет два компонента для создания верхней и нижней панели в приложении.

## TopAppBar
Компонент TopAppBar позволяет определить верхнюю панель приложения. Он имеет следующие параметры:

```kotlin
@ExperimentalMaterial3Api
@Composable
fun TopAppBar(
    title: @Composable () -> Unit,
    modifier: Modifier = Modifier,
    navigationIcon: @Composable () -> Unit = {},
    actions: @Composable RowScope.() -> Unit = {},
    windowInsets: WindowInsets = TopAppBarDefaults.windowInsets,
    colors: TopAppBarColors = TopAppBarDefaults.topAppBarColors(),
    scrollBehavior: TopAppBarScrollBehavior? = null
): Unit
```

Параметры функции компонента:

- title: задает заголовок панели.

- modifier: представляет объект Modifier, который определяет модификаторы панели

- navigationIcon: задает иконку навигации (обычно компонент IconButton), которая отображается в начале панели

- actions: набор значков, отображаемых в конце панели. Обычно это кнопки IconButton. для расположения иконок по умолчанию применяется контейнер Row, поэтому иконки располагаются по горизонтали.

- windowInsets: отступы от сторон окна

- colors: цвета панели в виде объекта TopAppBarColors. Для установки применяется функция TopAppBarDefaults.topAppBarColors().

- scrollBehavior: задает поведение при прокрутке с помощью объекта TopAppBarScrollBehavior.

На момент написания текущей статьи данный компонент помечен как экспериментальный. Поэтому при его использовании к родительскому компоненту следует применять аннотацию @OptIn(ExperimentalMaterial3Api::class). Определим простейшую панель TopAppBar:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalMaterial3Api::class){
            TopAppBar(title= { Text("METANIT.COM", fontSize = 22.sp)},
                navigationIcon={ IconButton({ }) { Icon(Icons.Filled.Menu, contentDescription = "Меню")}},
                actions={
                    IconButton({ }) { Icon(Icons.Filled.Info, contentDescription = "О приложении")}
                    IconButton({ }) {Icon(Icons.Filled.Search, contentDescription = "Поиск")}
                })
        }
    }
}
```

В данном случае в самом начале панели располагается иконка навигации navigationIcon (здесь в этом качестве выступает иконка Icons.Filled.Menu). Затем идет заголовок, который определяется функцией из title. И в правой части панели располагаются дополнительные иконки (здесь Icons.Filled.Info и Icons.Filled.Search), которые представляют дополнительные действия в приложении. В данном случае для каждого компонента IconButton параметр onClick представляет пустое лямбда-выражение, поэтому при нажатии естественно никаких реальных действий не происходит.

![](https://metanit.com/kotlin/jetpack/pics/4.36.png)

### Настройка цвета
Для установки цвета верхней панели применяется объект TopAppBarColors. Для создания этого объекта удобно использовать функцию-компонент TopAppBarDefaults.topAppBarColors:

```kotlin
@Composable
fun topAppBarColors(
    containerColor: Color = Color.Unspecified,
    scrolledContainerColor: Color = Color.Unspecified,
    navigationIconContentColor: Color = Color.Unspecified,
    titleContentColor: Color = Color.Unspecified,
    actionIconContentColor: Color = Color.Unspecified
): TopAppBarColors
```

Эта функция предполагает установку следующих цветов:

- containerColor: цвет контейнера

- scrolledContainerColor: цвет контейнера при прокрутке содержимого за ним

- navigationIconContentColor: цвет содержимого, используемый для значка навигации

- titleContentColor: цвет содержимого, используемый для заголовка

- actionIconContentColor: цвет контента, используемый для действий

По умолчанию все эти цвета не указаны, соответственно панель не имеет цвета. Теперь настроим цвета:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalMaterial3Api::class){
            TopAppBar(title= { Text("METANIT.COM", fontSize = 22.sp)},
                navigationIcon={ IconButton({ }) { Icon(Icons.Filled.Menu, contentDescription = "Меню")}},
                actions={
                    IconButton({ }) { Icon(Icons.Filled.Info, contentDescription = "О приложении")}
                    IconButton({ }) {Icon(Icons.Filled.Search, contentDescription = "Поиск")}
                },
                colors=TopAppBarDefaults.topAppBarColors(containerColor = Color.DarkGray,
                    titleContentColor = Color.LightGray,
                    navigationIconContentColor = Color.LightGray,
                    actionIconContentColor = Color.LightGray))
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.37.png)

## BottomAppBar
Компонент BottomAppBar позволяет определить нижнюю панель. Он имеет ряд похожих версий. Возьмем одну из них:

```kotlin
@Composable
fun BottomAppBar(
    modifier: Modifier = Modifier,
    containerColor: Color = BottomAppBarDefaults.containerColor,
    contentColor: Color = contentColorFor(containerColor),
    tonalElevation: Dp = BottomAppBarDefaults.ContainerElevation,
    contentPadding: PaddingValues = BottomAppBarDefaults.ContentPadding,
    windowInsets: WindowInsets = BottomAppBarDefaults.windowInsets,
    content: @Composable RowScope.() -> Unit
): Unit
```

Параметры функции компонента:

- modifier: представляет объект Modifier, который определяет модификаторы панели

- containerColor: значение типа Color, которое задает фоновый цвет панели

- contentColor: значение типа Color, которое устанавливает предпочтительный цвет для содержимого панели. По умолчанию предоставляет вызов contentColorFor(containerColor), которое для установки использует значение параметра bcontainerColor

- windowInsets: устанавливает отступы от границ

- tonalElevation: определяет эффект анимацию для содержимого панели

- contentPadding: объект типа PaddingValues, который устанавливает отступы между границами панели и ее содержимым.

- windowInsets: устанавливает отступы от границ окна

- content: задает контент панели. По умолчанию содержимое располагается в виде строки с помощью контейнера Row. Обычно здесь располагаются компоненты IconButton, по нажатию на которые выполняются определенные действия.

Определим простейший BottomAppBar:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween){
                Text("Main Content", fontSize = 28.sp)
                BottomAppBar{
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Меню")
                    }
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Info, contentDescription = "О приложении")
                    }
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Search, contentDescription = "Поиск")
                    }
                }
            }
        }
    }
}
```

В качестве формального содержимого здесь определен компонент Text с некоторым текстом, а внизу столбца располагается нижняя панель приложения с тремя иконками.

![](https://metanit.com/kotlin/jetpack/pics/4.38.png)

По умолчанию все вложенные компоненты панели располагаются рядом друг с другом. Но иногда требуется сделать между ними некоторый зазор. Так, в примере выше мы, возможно, захотим разместить две последние иконки в правой части панели (как в случае с TopAppBar). Чтобы установить пустое пространство между компонентами Compose предоставляет специальный компонент Spacer. Этот компонент просто определяет пустую область, которая соответствует его размеру. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween){
                Text("Main Content", fontSize = 28.sp)
                BottomAppBar{
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Меню")
                    }
                    Spacer(Modifier.weight(1f, true))
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Info, contentDescription = "О приложении")
                    }
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Search, contentDescription = "Поиск")
                    }
                }
            }
        }
    }
}
```

Здесь в Spacer растягивается на все незанятое другими компонентами пространство с помощью установки модификатора Modifier.weight(1f, true).

![](https://metanit.com/kotlin/jetpack/pics/4.66.png)

С помощью параметров containerColor и contentColor можно настроить цвет саой панели BottomAppBar и ее компонентов соответственно:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Search
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween){
                Text("Main Content", fontSize = 28.sp)
                BottomAppBar(
                    containerColor = Color.DarkGray,
                    contentColor = Color.LightGray
                ){
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Menu, contentDescription = "Меню")
                    }
                    Spacer(Modifier.weight(1f, true))
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Info, contentDescription = "О приложении")
                    }
                    IconButton(onClick = { }) {
                        Icon(Icons.Filled.Search, contentDescription = "Поиск")
                    }
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.67.png)

Стоит отметить, что Jetpack Compose также предоставляет компоненты, которые позволяют автоматически разместить верхнюю и нижнюю панель соответственно вверху и внизу окна приложения и которые мы далее рассмотрим.


















# Scaffold

androidx.compose.material.Scaffold представляет сложный компонент, который устанавливает общую структуру страницы. И мы можем встроить в эту структуру различные компоненты. В некотором роде Scaffold выступает в роли еще одного компонента-контейнера. Определение функции компонента:

```kotlin
@Composable
fun Scaffold(
    modifier: Modifier = Modifier,
    topBar: @Composable () -> Unit = {},
    bottomBar: @Composable () -> Unit = {},
    snackbarHost: @Composable () -> Unit = {},
    floatingActionButton: @Composable () -> Unit = {},
    floatingActionButtonPosition: FabPosition = FabPosition.End,
    containerColor: Color = MaterialTheme.colorScheme.background,
    contentColor: Color = contentColorFor(containerColor),
    contentWindowInsets: WindowInsets = ScaffoldDefaults.contentWindowInsets,
    content: @Composable (PaddingValues) -> Unit
): Unit
```

Параметры функции компонента:

- modifier: представляет объект Modifier, который определяет модификаторы компонента

- topBar: устанавливает верхнюю панель окна

- bottomBar: устанавливает нижнюю панель окна

- snackbarHost: представляет компонент, который содержит отображаемые на экран объекты Snackbar. Обычно это компонент SnackbarHost.

- floatingActionButton: устанавливает кнопку для выполнения некоторого действия. Обычно в качестве подобной кнопки выступает компонент FloatingActionButton

- floatingActionButtonPosition: задает позицию кнопки из параметра floatingActionButton. Представляет объект типа FabPosition и по умолчанию равно значению FabPosition.End

- containerColor: фоновый цвет компонента Scaffold

- contentColor: цвет содержимого компонента Scaffold

- contentWindowInsets: отступы от границ окна. Применяются только, если не установлены topBar/ bottomBar, иначе для определения отступов будут использоваться настройки topBar/bottomBar

- content: содержимое Scaffold. Представляет вызов функции типа (PaddingValues) -> Unit

Определим простейший Scaffold:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Scaffold{
                Text("Hello METANIT.COM", fontSize = 28.sp, modifier = Modifier.padding(it))
            }
        }
    }
}
```

В данном случае Scaffold содержит один компонент Text. Стоит отметить, что при определении содержимого Scaffold с помощью функции content нам надо как-то задействовать ее параметр - значение PaddingValues. В данном случае значение it, который представляет параметр типа PaddingValues, передается в Text модификатору padding.

![](https://metanit.com/kotlin/jetpack/pics/4.39.png)

Теперь добавим в Scaffold верхнюю и нижнюю панели:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Scaffold(
                topBar = {
                    @OptIn(ExperimentalMaterial3Api::class)
                    TopAppBar(title= { Text("METANIT.COM", fontSize = 22.sp)},
                        navigationIcon={ IconButton({ }) { Icon(Icons.Filled.Menu, contentDescription = "Меню")}},
                        actions={
                            IconButton({ }) { Icon(Icons.Filled.Info, contentDescription = "О приложении")}
                            IconButton({ }) {Icon(Icons.Filled.Search, contentDescription = "Поиск")}
                        },
                        colors= TopAppBarDefaults.topAppBarColors(containerColor = Color.DarkGray,
                            titleContentColor = Color.LightGray,
                            navigationIconContentColor = Color.LightGray,
                            actionIconContentColor = Color.LightGray))
                },
                bottomBar = {
                    BottomAppBar(
                        containerColor = Color.DarkGray,
                        contentColor = Color.LightGray
                    ){
                        IconButton(onClick = {  }) { Icon(Icons.Filled.Favorite, contentDescription = "Избранное")}
                        Spacer(Modifier.weight(1f, true))
                        IconButton(onClick = {  }) { Icon(Icons.Filled.Info, contentDescription = "Справка")}
                    }
                }
            ){
                Text("Hello METANIT.COM", fontSize = 28.sp, modifier = Modifier.padding(it))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.40.png)

В данном случае для верхней и нижней панели применяются соответственно компоненты TopAppBar и BottomAppBar. Тем не менее это необязательно. Мы можем создавать свои собственные композиции компонентов в качестве подобных панелей.

## Установка кнопки floatingActionButton
Компонент Scaffold может включать кнопку, которая устанавливается через параметр floatingActionButton и по нажатию на которую выполняется некоторое действие. Обычно это кнопки типа FloatingActionButton или ExtendedFloatingActionButton. Добавим подобную кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Clear
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FabPosition
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val isAdded = remember{ mutableStateOf(false) }
            Scaffold(
                topBar = {
                    @OptIn(ExperimentalMaterial3Api::class)
                    TopAppBar(title= { Text("METANIT.COM", fontSize = 22.sp)},
                        colors= TopAppBarDefaults.topAppBarColors(containerColor = Color.DarkGray, titleContentColor = Color.LightGray))
                },
                floatingActionButton = {
                    FloatingActionButton(
                        content = {
                            if(isAdded.value) Icon(Icons.Filled.Clear, contentDescription = "Удалить")
                            else Icon(Icons.Filled.Add, contentDescription = "Добавить") },
                        onClick = { isAdded.value = !isAdded.value}
                    )
                },
                floatingActionButtonPosition = FabPosition.Center
            ){
                Text(if(isAdded.value) "Товар добавлен" else "Корзина пуста",
                    fontSize = 28.sp,
                    modifier = Modifier.padding(it))
            }
        }
    }
}
```

Здесь параметр floatingActionButton получает кнопку FloatingActionButton, которая переключает значение переменной isAdded с true на false и обратно. В зависимости от этого значения устанавливается иконка данной кнопки, а также текст содержимого в Scaffold.

Кроме того, с помощью параметра floatingActionButtonPosition для кнопки установлено позиционирование по центру. Этот параметр принимает одно из двух значений: FabPosition.Center (позиционирование по центру) и FabPosition.End (позиционирование по нижнем углу).

![](https://metanit.com/kotlin/jetpack/pics/4.41.png)































# Всплывающие сообщения и Snackbar

Всплывающие сообщения, которые извещают пользователя о некоторых процессах в приложения и которые через некоторое время исчезают, являются обычным делом в приложении. И Jetpack Compose предоставляет для создания подобных сообщений встроенный функционал.

## Snackbar
Ключевым компонентом для создания всплывающих сообщений является Snackbar, который предоставляет короткое сообщение, отображаемое внизу экрана. Данный компонент имеет две версии. Первая версия:

```kotlin
@Composable
fun Snackbar(
    modifier: Modifier = Modifier,
    action: (@Composable () -> Unit)? = null,
    dismissAction: (@Composable () -> Unit)? = null,
    actionOnNewLine: Boolean = false,
    shape: Shape = SnackbarDefaults.shape,
    containerColor: Color = SnackbarDefaults.color,
    contentColor: Color = SnackbarDefaults.contentColor,
    actionContentColor: Color = SnackbarDefaults.actionContentColor,
    dismissActionContentColor: Color = SnackbarDefaults.dismissActionContentColor,
    content: @Composable () -> Unit
): Unit
```

Параметры функции компонента:

- modifier: представляет объект Modifier, который определяет модификаторы компонента

- action: вложенный компонент (обычно текст), по нажатию на который компонент уведомляет систему, что необходимо выполнить некоторое действие.

- dismissAction: дополнительный компонент, по нажатию на который выполняется некоторое действие.

- actionOnNewLine: указывает, будет ли действие располагаться на новой строке.

- shape: объект Shape, который задает форму компонента.

- containerColor: фоновый цвет

- contentColor: цвет содержимого.

- actionContentColor: цвет компонента, который представляет основное действие и устанавливается через параметр action

- dismissActionContentColor: цвет компонента, который устанавливается через dismissAction

- content: содержимое компонента

Вторая версия Snackbar:

```kotlin
@Composable
fun Snackbar(
    snackbarData: SnackbarData,
    modifier: Modifier = Modifier,
    actionOnNewLine: Boolean = false,
    shape: Shape = SnackbarDefaults.shape,
    containerColor: Color = SnackbarDefaults.color,
    contentColor: Color = SnackbarDefaults.contentColor,
    actionColor: Color = SnackbarDefaults.actionColor,
    actionContentColor: Color = SnackbarDefaults.actionContentColor,
    dismissActionContentColor: Color = SnackbarDefaults.dismissActionContentColor
): Unit
```

Тут в пинципе применяются те же параметры, за исключением того, что содержимое Snackbar устанавливается с помощью параметра snackbarData, который представляет объект SnackbarData. SnackbarData - это интерфейс, который предоставляет ряд свойств и методов для управления сообщением:

- Свойство visuals позволяет установить общую информацию с помощью следующих свойств:

- - Свойство message: текст сообщения

- - Свойство actionLabel: текстовая метка, нажатие на которую будет извещать систему, что надо выполнить некотоое действие

- - Свойство duration: время отображения сообщения, представляет объект SnackbarDuration

- Метод performAction(): уведомляет систему, что произошло нажатие на метку, представленную параметром actionLabel

- Метод dismiss(): уведомляет систему, что отображение сообщения завершилось без нажатия на метку из параметра actionLabel

В принципе мы можем определить Snackbar как обычный компонент и сами управлять им. Например:

```kotlin
Snackbar{
    Text("Загрузка завершена", fontSize = 22.sp)
}
```

Однако в реальности мы можем даже явным образом не создавать объект Snackbar для отображения сообщение, а воспользоваться функцией showSnackbar() объекта SnackbarHostState.

### SnackbarHostState
Объект SnackbarHostState отображает или ставит в очередь для отображения компоненты Snackbar. SnackbarHostState гарантирует, что одномоментно только один объект Snackbar будет отображаться на экране.

Для отображения Snackbar в SnackbarHostState определена функция showSnackbar():

```kotlin
suspend fun showSnackbar(
    message: String,
    actionLabel: String? = null,
    withDismissAction: Boolean = false,
    duration: SnackbarDuration = if (actionLabel == null) SnackbarDuration.Short else SnackbarDuration.Indefinite
): SnackbarResult
```

Основные параметры

- message: отображаемое в Snackbar сообщение

- actionLabel: метка, которая отображается в виде кнопки в Snackbar

- withDismissAction: указывает, надо ли отображать кнопку отмены. Если равно true, то Snackbar отображает кнопку отмены в виде крестика

- duration: длительность отображения сообщения в виде объекта SnackbarDuration. Значение по умолчанию SnackbarDuration.Short. Другие возможные значения: SnackbarDuration.Long и SnackbarDuration.Indefinite

Фактически все эти параметры аналогичны свойствам объекта SnackbarDat.visuals.

В качестве результата функция возвращает объект SnackbarResult. Он может иметь следующие значения: SnackbarResult.ActionPerformed (если была нажата метка действия в Snackbar) и SnackbarResult.Dismissed (если Snackbar был скрыт из-за действий пользователя или из-за того, что окончилось его время отображения)

Итак, используем функцию showSnackbar() для отображения всплывающего сообщения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()
            val count = remember{ mutableStateOf(0) }
            Scaffold(
                snackbarHost = { SnackbarHost(snackbarHostState) },
                floatingActionButton = {
                    FloatingActionButton(
                        content = {Icon(Icons.Filled.Add, contentDescription = "Добавить")},
                        onClick = {
                            scope.launch {
                                snackbarHostState.showSnackbar("Count: ${++count.value}")
                            }
                        }
                    )
                }
            ){
                Text("Count: ${count.value}", fontSize = 28.sp, modifier=Modifier.padding(it))
            }
        }
    }
}
```

Здесь надо отметить несколько моментов. Во-первых, определяем оббъект состояния в виде SnackbarHostState:

```kotlin
val snackbarHostState = remember { SnackbarHostState() }
```

Во-вторых, функция showSnackbar() - это suspend-функция, которую необходимо вызывать в рамках корутины. Для создания контекста корутины применяется другая встроенная функция - rememberCoroutineScope():

```kotlin
val scope = rememberCoroutineScope()
```

В Scaffold используем SnackbarHostState для установки параметра snakbarHost:

```kotlin
snackbarHost = { SnackbarHost(snackbarHostState) }
```

Для создания объекта состояния применяется встроенная функция rememberScaffoldState()(). Далее, используя это состояние, обращаемся к SnackbarHostState и его функции showSnackbar:

```kotlin
scaffoldState.snackbarHostState.showSnackbar("Count: ${++count.value}")
```

По нажатию на FloatingActionButton с помощью контекста корутины scope запускаем корутину и в ней вызывем функцию showSnackbar:

```kotlin
scope.launch {
    snackbarHostState.showSnackbar("Count: ${++count.value}")
}
```

В самой функции showSnackbar увеличиваем значение в переменной count. Вызов данной функции приведт к отображению сообщения в приложении:

![](https://metanit.com/kotlin/jetpack/pics/4.42.png)

### actionLabel
Теперь свяжем сообщение с некоторым действием. Для этого устанавим в функции showSnackbar() параметр actionLabel - фактически это просто текстовая метка, а не конкретное действие:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()
            val count = remember{ mutableStateOf(0) }
            Scaffold(
                snackbarHost = { SnackbarHost(snackbarHostState) },
                floatingActionButton = {
                    FloatingActionButton(
                        content = {Icon(Icons.Filled.Add, contentDescription = "Добавить")},
                        onClick = {
                            scope.launch {
                                val result = snackbarHostState.showSnackbar(
                                        "Текущее значение: ${count.value}",
                                        actionLabel = "Подтвердить",
                                        withDismissAction = true,
                                        duration = SnackbarDuration.Short)
                                when (result) {
                                    SnackbarResult.ActionPerformed -> { count.value++; }
                                    SnackbarResult.Dismissed -> { snackbarHostState.showSnackbar("Действие отменено")}
                                }
                            }
                        }
                    )
                }
            ){
                Text("Count: ${count.value}", fontSize = 28.sp, modifier=Modifier.padding(it))
            }
        }
    }
}
```

В данном случае текстовая метка в сообщении, которая приглашает к некоторому действию, имеет текст "Подтвердить" и отображается в правой части окна сообщения.

![](https://metanit.com/kotlin/jetpack/pics/4.43.png)

Хотя сама эта метка ничего не делает, но теперь по нажатию на эту метку функция showSnackbar будет возвращать значение SnackbarResult.ActionPerformed. Если нажатия не было, и сообщение само по себе пропало, либо если мы нажали на кнопку отмены (на крестик), то возвращается значение SnackbarResult.Dismissed

Получив результат функции, с помощью конструкции when мы можем проверить его значение и выполнить определенные действия. В данном случае для простоты при одном результате к переменной count добавляется единица, а при другом результате - отображаем сообщение об отмене действия.

![](https://metanit.com/kotlin/jetpack/pics/4.68.png)

Может сложиться впечатление, что для отображения всплывающего сообщения необходимо обрабатывать нажатия обязательно в floatingActionButton. Однако в реальности мы можем запускать отображение в любом месте Scaffold. Например, по нажатию на обычную кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()
            val count = remember{ mutableStateOf(0) }
            Scaffold(
                snackbarHost = { SnackbarHost(snackbarHostState) }
            ){
                Button(
                    onClick = {
                        scope.launch {
                            val result = snackbarHostState.showSnackbar("Count: ${count.value}", "Click", duration= SnackbarDuration.Short)
                            if(result==SnackbarResult.ActionPerformed) count.value++
                        }
                    },
                    modifier = Modifier.padding(it)
                ){
                    Text("Click", fontSize = 28.sp)
                }
            }
        }
    }
}
```

## SnackbarHost
Выше система сама определяла визуальные аспекты вслывающего сообщения, мы только задавали текстовую соотавляющую. Однако в реальности мы также можем настроить отображение сообщения. Для этого необходимо явным образом создать отображаемый объект Snackbar.

Кроме того, для установки объектов Snackbar, которые связаны со Scaffold компонент предоставляет параметр snackbarHost, который по умолчанию представляет объект SnackbarHost. SnackbarHost фактически представляет хранилище объектов Snackbar и позволяет управлять их отображением. Его определение:

```kotlin
@Composable
fun SnackbarHost(
    hostState: SnackbarHostState,
    modifier: Modifier = Modifier,
    snackbar: @Composable (SnackbarData) -> Unit = { Snackbar(it) }
): Unit
```

- hostState: представляет состояние SnackbarHost в виде объекта SnackbarHostState, который управляет отображением сообщения

- snackbar: данные для Snackbar в виде объекта SnackbarData, которыt будут отображаться

Например, настроим цветовую гамму сообщения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Snackbar
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
 
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()
            val count = remember{ mutableStateOf(0) }
            Scaffold(
                snackbarHost = {
                    SnackbarHost(snackbarHostState){ data ->
                        Snackbar(
                            snackbarData = data,
                            containerColor = Color.DarkGray,
                            contentColor = Color.LightGray,
                            actionOnNewLine =  true,
                            actionColor = Color.LightGray
                        )
                    }
                }
            ){
                Button(
                    {
                        scope.launch {
                            val result = snackbarHostState.showSnackbar("Count: ${count.value}", "Add", true)
                            if(result==SnackbarResult.ActionPerformed) count.value++
                        }
                    },
                    Modifier.padding(it)
                ){ Text("Click", fontSize = 28.sp) }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.44.png)

В данном случае в SnackbarHost в качестве параметра передается объект SnackbarHostState, который запускает отображение сообщения:

```kotlin
SnackbarHost(snackbarHostState){ data ->
    Snackbar(
        snackbarData = data,
```

Далее в SnackbarHost определяется объект Snackbar, в который передается объект SnackbarData через параметр data. Этот объект будет содержать отображаемое сообщение и название метки действия. Но здесь мы их никак не изменям. Мы их будет отобажать, как они определены в функции showSnackbar(), изменяется только визуальная составляющая.

# Полная настройка Snackbar
Выше у Snackbar был изменен применяемый цвет. Однако мы также можем полностью изменить его содержимое:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Snackbar
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val snackbarHostState = remember { SnackbarHostState() }
            val scope = rememberCoroutineScope()
            val count = remember{ mutableStateOf(0) }
            Scaffold(
                snackbarHost = {
                    SnackbarHost(snackbarHostState){ data ->
                        Snackbar(
                            modifier = Modifier.padding(10.dp),
                            containerColor = Color.DarkGray,
                            contentColor = Color.LightGray,
                            action = {
                                TextButton(onClick={ data.performAction() }){
                                    Text("OK", fontSize=22.sp, color=Color.LightGray)
                                }
                            },
                            dismissAction = {
                                TextButton(onClick={ data.dismiss() }){
                                    Text("Отмена", fontSize=22.sp, color=Color.LightGray)
                                }
                            }
                        ){ Text("Clicks: ${count.value}", fontSize=28.sp) }
                    }
                }
            ){
                Button(
                    {
                        scope.launch {
                            val result = snackbarHostState.showSnackbar("")
                            if(result==SnackbarResult.ActionPerformed) count.value++
                        }
                    },
                    Modifier.padding(it)
                ){ Text("Click", fontSize = 28.sp) }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.45.png)

В данном случае полностью переопределяем внутреннее содержимое и метку действия у Snackbar. При этом параметры из функции showSnackbar() могут игнорироваться. Однако даже в этом случае передаваемый параметр SnackbarData может нам понадобиться. Так, в данном случае при нажатии на метку действия (которая в примере выше представлена компонентом TextButton) вызывается метод performAction()

```kotlin
action = {
    TextButton(onClick={ data.performAction() }){
        Text("OK", fontSize=22.sp, color=Color.LightGray)
    }
},
```

Благодаря этому система узнает, что результатом функции showSnackbar() является значение SnackbarResult.ActionPerformed.

Snackbar вне Scaffold
Может возникнуть вопрос, а можно ли использовать Snackbar вне Scaffold? В принципе можно, но в этом случае придется приложить дополнительные усилия, написать дополнительный код для позиционирования сообщения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val scope = rememberCoroutineScope()
            val snackbarHostState = remember { mutableStateOf(SnackbarHostState()) }
            Button(
                onClick = {
                    scope.launch {
                        snackbarHostState.value.showSnackbar("Hello")
                    }
                }
            ) { Text("Click", fontSize = 28.sp) }
            SnackbarHost(snackbarHostState.value)
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.46.png)













































# Выдвижная панель ModalNavigationDrawer

Компонент ModalNavigationDrawer предназначен для создания приложений с выдвижной панелью, где часто располагается какое-нибдуь меню. Этот компонент имеет следующее определение:

```kotlin
@Composable
fun ModalNavigationDrawer(
    drawerContent: @Composable () -> Unit,
    modifier: Modifier = Modifier,
    drawerState: DrawerState = rememberDrawerState(DrawerValue.Closed),
    gesturesEnabled: Boolean = true,
    scrimColor: Color = DrawerDefaults.scrimColor,
    content: @Composable () -> Unit
): Unit
```

Параметры компонента:

- drawerContent: содержимое выдвижной панели

- modifier: применяемыек компоненты модификаторы

- drawerState: состояние в виде объекта DrawerState. Для определения состояния применяется функция rememberDrawerState(), в которую передается передается начальное состояние панели с помощью констант перечисления DrawerValue: DrawerValue.Closed (панель закрыта) и DrawerValue.Open (панель открыта) По умолчанию равно rememberDrawerState(DrawerValue.Closed)

- gesturesEnabled: указывает, может или нет панель управляться касаниями. По умолчанию равно true

- scrimColor: цвет, который скрывает основное содержимое приложения, когда панель открыта

- content: остальное содержимое приложения

Первый и последний параметр являются обязательными и в реальности они могут представлять любые компоненты. Например, определим простейшую выдвижную панель:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ModalNavigationDrawer(
                drawerContent = { Text("Drawer", fontSize = 22.sp, color=Color.LightGray)  },
                scrimColor = Color.DarkGray,
                content={Text("Main Content", fontSize = 28.sp)})
        }
    }
}
```

Здесь и содержимое выдвижной панели, и содержимое основной части приложения представлено компонентом Text. При выдвижении панели основной контент закрашивается сервым цветом - то есть фактически это цвет самой панели. В данном случае по умолчанию панель не видна, и для ее выдвижения надо провести пальцем от левой стороны приложения вправо:

![](https://metanit.com/kotlin/jetpack/pics/4.69.png)


## Состояние DrawerState
Выдвижная панель может быть открыта или закрыта. Соответственно компонент может находиться в двух состояниях. Для хранения состояния применяется класс DrawerState. Внутри этого класса для хранения состояния применяется перечисление DrawerValue. В частности, оно имеет два значения: DrawerValue.Closed (панель закрыта) и DrawerValue.Open (панель открыта).

Для создания и управления состояния DrawerState применяется функция rememberDrawerState():

```kotlin
@Composable
fun rememberDrawerState(
    initialValue: DrawerValue,
    confirmStateChange: (DrawerValue) -> Boolean = { true }
): DrawerState
```

В качестве обязательного параметра она принимает значение DrawerValue, которое указывает, открыта или закрыта панель по умолчанию. Для получения информации о состоянии DrawerState предоставляет ряд свойств:

- currentValue: текущее состояние в виде значения DrawerValue

- isClosed: если равно true, то выдвижная панель скрыта

- isOpen: если равно true, то выдвижная панель раскрыта

Кроме того, DrawerState предоставляет ряд методов для управления состоянием:

- open(): раскрывает выдвижную панель

- close(): скрывает выдвижную панель

Обе эти функции являются suspend-функциями. Например, используем эти функции для программного управления состоянием панели:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.rememberDrawerState
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()
            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = { Text("Menu", fontSize = 22.sp, color=Color.LightGray) },
                scrimColor = Color.DarkGray,
                content={
                    IconButton(onClick = {
                        scope.launch {drawerState.open()} }) {
                        Icon(Icons.Filled.Menu, "Меню")
                    }
                }
            )
        }
    }
}
```

Сначала определяем контекст DrawerState и контекст корутины для запуска suspend-функций:

```kotlin
val drawerState = rememberDrawerState(DrawerValue.Closed)
val scope = rememberCoroutineScope()
```

Для связи этого состояния с ModalNavigationDrawer определяем параметр drawerState:

```kotlin
ModalNavigationDrawer(
    drawerState = drawerState,
    ..........................
```

Затем через параметр content определяем кнопку-иконку меню, по нажатию на которую будет раскрываться панель с помощью выполнения метода drawerState.open():

```kotlin
content={
    IconButton(onClick = {
        scope.launch {drawerState.open()} }) {
        Icon(Icons.Filled.Menu, "Меню")
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.71.png)

Также здесь мы могли бы сделать более тонкое управление состоянием - открывать панель, когда она скрыта, и скрывать ее, когда она раскрыта:

```kotlin
scope.launch {
    if(drawerState.isClosed) drawerState.open()
    else drawerState.close()
}
```

## Обработка выбора
Нередко на подобных выдвижных панелях размещается некоторое меню. Определим подобное меню и определим обработку выбора его пунктов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.TextButton
import androidx.compose.material3.rememberDrawerState
 
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = listOf("Home", "Contact", "About")
            val selectedItem = remember { mutableStateOf(items[0]) }
            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()
            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = {
                    Column {
                        items.forEach { item ->
                            TextButton(onClick = {
                                    scope.launch { drawerState.close() }
                                    selectedItem.value = item
                                },
                                colors = ButtonDefaults.buttonColors(contentColor = Color.LightGray, containerColor = Color.Transparent)) {
                                Text(item, fontSize = 22.sp)
                            }
                        }
                    }
                },
                scrimColor = Color.DarkGray,
                content={
                    Column {
                        IconButton(onClick = {
                            scope.launch {drawerState.open()}
                        }, content = {
                            Icon(Icons.Filled.Menu, "Меню")
                        })
                        Text(selectedItem.value, fontSize = 28.sp)
                    }
                }
            )
        }
    }
}
```

В данном случае все пункты меню определены в массиве items. Для хранения выбранного пункта определена переменная selectedItem.

При наполнении выдвижной панели компонентами создаем для каждого элемента в items компонент TextButton. При нажатии на такую кнопку в переменную selectedItem будет передаваться нажатый элемент.

```kotlin
drawerContent = {
    Column {
        items.forEach { item ->
            TextButton(onClick = {
                    scope.launch { drawerState.close() }
                    selectedItem.value = item
                },
                colors = ButtonDefaults.buttonColors(contentColor = Color.LightGray, containerColor = Color.Transparent)) {
                Text(item, fontSize = 22.sp)
            }
        }
    }
},
```

В основном содержимом приложения отображаем выбранный пункт:

```kotlin
content={Text(selectedItem.value, fontSize = 28.sp)}
```

![](https://metanit.com/kotlin/jetpack/pics/4.70.png)

## ModalDrawerSheet
Для настройки отображения и поведения элементов на выдвижной панели применяется компонент ModalDrawerSheet

```kotlin
@Composable
fun ModalDrawerSheet(
    modifier: Modifier = Modifier,
    drawerShape: Shape = DrawerDefaults.shape,
    drawerContainerColor: Color = DrawerDefaults.modalContainerColor,
    drawerContentColor: Color = contentColorFor(drawerContainerColor),
    drawerTonalElevation: Dp = DrawerDefaults.ModalDrawerElevation,
    windowInsets: WindowInsets = DrawerDefaults.windowInsets,
    content: @Composable ColumnScope.() -> Unit
): Unit
```

Он использует следующие параметры:

- modifier: функции модификатора, которые применются к компоненту

- drawerShape: форма компонента в виде объекта Shape

- drawerContainerColor: цвет контейнера

- drawerContentColor: цвет содержимого

- drawerTonalElevation: эффект анимации при нажатии на элементы компонента

- windowInsets: отступы от границ контейнера

- content: содержимое выдвижной панели

Применим ModalDrawerSheet:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.TextButton
import androidx.compose.material3.rememberDrawerState
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = listOf("Home", "Contact", "About")
            val selectedItem = remember { mutableStateOf(items[0]) }
            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()
            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = {
                    ModalDrawerSheet{
                        items.forEach { item ->
                            TextButton(
                                onClick = {
                                    scope.launch { drawerState.close() }
                                    selectedItem.value = item
                                },
                            ) { Text(item, fontSize = 22.sp) }
                        }
                    }
                },
                content={
                    Row{
                        IconButton(onClick = {scope.launch {drawerState.open()}},
                            content = { Icon(Icons.Filled.Menu, "Меню") }
                        )
                        Text(selectedItem.value, fontSize = 28.sp)
                    }
                }
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.72.png)

Как видно, ModalDrawerSheet имеет некоторую стандартную стилизацию и упрощает создание содержимого. И мы можем помещать в ModalDrawerSheet любые компоненты, как в данном случае компоненты TextButton. Тем не менее для определения элементов в ModalDrawerSheet в Jetpack Compose предназначен специальный компонент - NavigationDrawerItem:

```kotlin
@Composable
fun NavigationDrawerItem(
    label: @Composable () -> Unit,
    selected: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    icon: (@Composable () -> Unit)? = null,
    badge: (@Composable () -> Unit)? = null,
    shape: Shape = NavigationDrawerTokens.ActiveIndicatorShape.value,
    colors: NavigationDrawerItemColors = NavigationDrawerItemDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

Отмечу основные параметры компонента:

- label: определяет содержимое
- selected: указывает, будет ли выделен элемент (при значении true)
- onClick: обработчик нажатия на компонент
- colors: устанавливает цвета. Для установки цветов можно использовать функцию NavigationDrawerItemDefaults.colors()

```kotlin
@Composable
fun colors(
    selectedContainerColor: Color = NavigationDrawerTokens.ActiveIndicatorColor.value,
    unselectedContainerColor: Color = Color.Transparent,
    selectedIconColor: Color = NavigationDrawerTokens.ActiveIconColor.value,
    unselectedIconColor: Color = NavigationDrawerTokens.InactiveIconColor.value,
    selectedTextColor: Color = NavigationDrawerTokens.ActiveLabelTextColor.value,
    unselectedTextColor: Color = NavigationDrawerTokens.InactiveLabelTextColor.value,
    selectedBadgeColor: Color = selectedTextColor,
    unselectedBadgeColor: Color = unselectedTextColor
): NavigationDrawerItemColors
```

Она устанавливает следующие цвета:
- selectedContainerColor: цвет фона выбранного элемента
- unselectedContainerColor: цвет фона невыбранного элемента
- selectedIconColor: цвет иконки выбранного элемента
- unselectedIconColor: цвет иконки невыбранного элемента
- selectedTextColor: цвет текста выбранного элемента
- unselectedTextColor: цвет текста невыбранного элемента
- selectedBadgeColor: цвет значка выбранного элемента
- unselectedBadgeColor: цвет значка невыбранного элемента

Применим NavigationDrawerItem для создания элементов выдвижной панели:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.rememberDrawerState
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = listOf("Home", "Contact", "About")
            val selectedItem = remember { mutableStateOf(items[0]) }
            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()
            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = {
                    ModalDrawerSheet{
                        items.forEach { item ->
                            NavigationDrawerItem(
                                label= { Text(item, fontSize = 22.sp) },
                                selected = selectedItem.value==item,
                                onClick = {
                                    scope.launch { drawerState.close() }
                                    selectedItem.value = item
                                }
                            )
                        }
                    }
                },
                content={
                    Row{
                        IconButton(onClick = {scope.launch {drawerState.open()}},
                            content = { Icon(Icons.Filled.Menu, "Меню") }
                        )
                        Text(selectedItem.value, fontSize = 28.sp)
                    }
                }
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.73.png)

Аналогично можно настроить цветовую гамму для выдвижной панели:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.DrawerValue
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ModalDrawerSheet
import androidx.compose.material3.Text
import androidx.compose.material3.ModalNavigationDrawer
import androidx.compose.material3.NavigationDrawerItem
import androidx.compose.material3.NavigationDrawerItemDefaults
import androidx.compose.material3.rememberDrawerState
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val items = listOf("Home", "Contact", "About")
            val selectedItem = remember { mutableStateOf(items[0]) }
            val drawerState = rememberDrawerState(DrawerValue.Closed)
            val scope = rememberCoroutineScope()
            ModalNavigationDrawer(
                drawerState = drawerState,
                drawerContent = {
                    ModalDrawerSheet(
                        drawerContainerColor = Color.DarkGray,
                        drawerContentColor =  Color.LightGray
                    ) {
                        items.forEach { item ->
                            NavigationDrawerItem(
                                label= { Text(item, fontSize = 22.sp) },
                                selected = selectedItem.value==item,
                                onClick = {
                                    scope.launch { drawerState.close() }
                                    selectedItem.value = item
                                },
                                colors = NavigationDrawerItemDefaults.colors(
                                    selectedContainerColor = Color.Transparent,
                                    unselectedContainerColor = Color.Transparent,
                                    selectedTextColor = Color.White,
                                    unselectedTextColor = Color.LightGray
                                )
                            )
                        }
                    }
                },
                content={
                    Row{
                        IconButton(onClick = {scope.launch {drawerState.open()}},
                            content = { Icon(Icons.Filled.Menu, "Меню") }
                        )
                        Text(selectedItem.value, fontSize = 28.sp)
                    }
                }
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.74.png)


















# Slider

Компонент Slider представляет шкалу с некоторым диапазоном числовых значений, из которых мы можем выбрать одно из значений. Типичный прример подобной шкалы - элемент для установки громкости.

Функция компонента имеет следующее определение:

```kotlin
@Composable
fun Slider(
    value: Float,
    onValueChange: (Float) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    valueRange: ClosedFloatingPointRange<Float> = 0f..1f,
    steps: @IntRange(from = 0) Int = 0,
    onValueChangeFinished: (() -> Unit)? = null,
    colors: SliderColors = SliderDefaults.colors(),
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() }
): Unit
```

Параметры компонента:

- value: текущее значение слайдера в виде объекта Float

- onValueChange: функция обработки изменения введенного значения. Представляет функцию типа (Float) -> Unit, в которую в качестве параметра передается новое значение

- modifier: объект типа Modifier, который задает модификаторы компонента

- enabled: устанавливает, будет ли слайдер доступен для ввода. Представляет значение типа Boolean. По умолчанию равно true, то есть поле доступно для ввода

- valueRange: устанавливает диапазон достуных для выбора значений в виде объекта ClosedFloatingPointRange<Float>. По умолчанию равно диапазону 0f..1f.

- steps: количество делений на диапазоне valueRange. Если это значение больше 0, то значения равномено распределяются по шкале, и мы можем выбрать одно из этих делений. Если это значение равно 0, то мы можем выбрать любое значение на шкале. Значение по умолчанию - 0

- onValueChangeFinished: устанавливает функцию типа () -> Unit, которая вызывается после завершения установки значения слайдера. Эта функция позволяет указать, что пользователь завершил изменение значения слайдера. Значение по умолчанию - null

- colors: объект SliderColors, который задает цвета для поля ввода. Значение по умолчанию - SliderDefaults.colors()

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для поля ввода.

Определим простейший слайдер:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.material3.Slider
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var sliderPosition by remember{mutableStateOf(0f)}
            Column{
                Text(text = "Текущее значение: ${sliderPosition}", fontSize = 22.sp)
                Slider(
                    value = sliderPosition,
                    onValueChange = { sliderPosition = it }
                )
            }
        }
    }
}
```

В данном случае для хранения значения слайдера определена переменная sliderPosition. По умолчанию она равна 0.

Для слайдера необходимо задать как минимум два параметра: value и onValueChange. Параметр value привязан к значению переменной sliderPosition, а в функции onValueChange получаем новое значение и переустанавливаем значение переменной sliderPosition.

![](https://metanit.com/kotlin/jetpack/pics/4.49.png)

В примере выше не указан диапазон, поэтому по умолчанию мы можем выбирать значения на диапазоне от 0 до 1. Причем, так как не указано количество делений, это может быть любое значение, напимер, 0.51574075. Теперь явно укажем диапазон и количество делений:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.material3.Slider
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var sliderPosition by remember{mutableStateOf(0f)}
            Column{
                Text(text = "Текущее значение: ${sliderPosition}", fontSize = 22.sp)
                Slider(
                    value = sliderPosition,
                    valueRange = 0f..10f,
                    steps = 9,
                    onValueChange = { sliderPosition = it }
                )
            }
        }
    }
}
```

В данном случае количество делений - 9, а диапазон - от 1 до 10. Поэтому на слайдере мы можем выбрать любое число из диапазона [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

![](https://metanit.com/kotlin/jetpack/pics/4.50.png)

## Цветовая гамма

По умолчанию слайдер использует цвета, устанавливаемые компонентом SliderDefaults.colors:

```kotlin
@Composable
fun colors(
    thumbColor: Color = Color.Unspecified,
    activeTrackColor: Color = Color.Unspecified,
    activeTickColor: Color = Color.Unspecified,
    inactiveTrackColor: Color = Color.Unspecified,
    inactiveTickColor: Color = Color.Unspecified,
    disabledThumbColor: Color = Color.Unspecified,
    disabledActiveTrackColor: Color = Color.Unspecified,
    disabledActiveTickColor: Color = Color.Unspecified,
    disabledInactiveTrackColor: Color = Color.Unspecified,
    disabledInactiveTickColor: Color = Color.Unspecified
): SliderColors
```

Параметры компонента:

- thumbColor: цвет ползунка

- activeTrackColor: цвет шкалы до ползунка

- activeTickColor: цвет делений шкалы до ползунка

- inactiveTrackColor: цвет шкалы после ползунка

- inactiveTickColor: цвет делений шкалы после ползунка

- disabledThumbColor: цвет ползунка, когда слайдер недоступен для взаимодействия

- disabledActiveTrackColor: цвет шкалы до ползунка, когда слайдер недоступен для взаимодействия

- disabledInactiveTrackColor: цвет шкалы после ползунка, когда слайдер недоступен для взаимодействия

- disabledActiveTickColor: цвет делений шкалы до ползунка, когда слайдер недоступен для взаимодействия

- disabledInactiveTickColor: цвет делений шкалы после ползунка, когда слайдер недоступен для взаимодействия

Изменим цветовую гамму слайдера:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.material3.Slider
import androidx.compose.material3.SliderDefaults
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var sliderPosition by remember{mutableStateOf(0f)}
            Column{
                Text(text = "Текущее значение: ${sliderPosition}", fontSize = 22.sp)
                Slider(
                    value = sliderPosition,
                    valueRange = 0f..10f,
                    steps = 9,
                    onValueChange = { sliderPosition = it },
                    colors = SliderDefaults.colors(
                        thumbColor = Color(0xFFB71C1C),
                        activeTrackColor = Color(0xFFEF9A9A),
                        inactiveTrackColor = Color(0xFFFFEBEE),
                        inactiveTickColor = Color(0xFFEF9A9A),
                        activeTickColor = Color(0xFFB71C1C)
                    )
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.51.png)
















# Переключатель Switch

Компонент Switch представляет переключатель, который может находиться в двух состояниях: отмеченном и неотмеченном. Он имеет следующие параметры:

```kotlin
@Composable
fun Switch(
    checked: Boolean,
    onCheckedChange: ((Boolean) -> Unit)?,
    modifier: Modifier = Modifier,
    thumbContent: (@Composable () -> Unit)? = null,
    enabled: Boolean = true,
    colors: SwitchColors = SwitchDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

Параметры функции компонента:

- checked: указывает, отмечен ли переключатель. Если равно true, то отмечен

- onCheckedChange: функция обработки нажатия на компонент. Представляет функцию типа (Boolean) -> Unit, в которую в качестве параметра передается новое состояние переключателя

- modifier: объект типа Modifier, который задает модификаторы компонента

- thumbContent: содержимое для отрисовки переключателя

- enabled: устанавливает, будет ли слайдер доступен для ввода. Представляет значение типа Boolean. По умолчанию равно true, то есть поле доступно для ввода

- colors: объект SwitchColors, который задает цвета для поля ввода. Значение по умолчанию - SwitchDefaults.colors()

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для поля ввода. Значение по умолчанию - remember { MutableInteractionSource() }

Простейший Switch:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Switch
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Switch(
                checked = checkedState.value,
                onCheckedChange = { checkedState.value = it }
            )
        }
    }
}
```

В данном случае состояние компонента Switch привязано к значению переменной checkedState. В функции параметра onCheckedChange изменяем значение этой переменной, передавая ей новое значение.

![](https://metanit.com/kotlin/jetpack/pics/4.54.png)

Обычно рядом со Switch идет текстовая метка, которая говорит о предназначении переключателя:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(false) }
            val textColor = remember { mutableStateOf(Color.Unspecified) }
            Column{
                Row (verticalAlignment = Alignment.CenterVertically){
                    Text("Цвет Purple40", fontSize = 22.sp, color = textColor.value, modifier = Modifier.padding(8.dp, 0.dp))
                    Switch(
                        checked = checkedState.value,
                        onCheckedChange = {
                            checkedState.value = it
                            if(checkedState.value) textColor.value = Color(0xFF6650a4)
                            else textColor.value = Color.Unspecified
                        }
                    )
                }
            }
        }
    }
}
```

В данном случае мы переключаем значение переменной textColor - если Switch находится в отмеченном состоянии, то она получает цвет Purple40. Для отображения изменения этой переменной ее значение привязано к параметру color компонента Text:

![](https://metanit.com/kotlin/jetpack/pics/4.55.png)


Цветовая гамма
По умолчанию Switch использует цвета, устанавливаемые функцией SwitchDefaults.colors. Она имеет много параметров, поэтому отмечу лишь некоторые:

- checkedThumbColor: цвет бегунка в отмеченном состоянии

- checkedTrackColor: цвет переключателя в отмеченном состоянии

- checkedBorderColor: цвет границы переключателя при отмеченном состоянии

- uncheckedThumbColor: цвет бегунка в неотмеченном состоянии

- uncheckedTrackColor: цвет переключателя в неотмеченном состоянии

- uncheckedBorderColor: цвет границы переключателя при неотмеченном состоянии

- disabledCheckedTrackColor: цвет переключателя в отмеченном состоянии, когда он недоступен для взаимодействия

- disabledUncheckedTrackColor: цвет переключателя в неотмеченном состоянии, когда он недоступен для взаимодействия

- disabledCheckedThumbColor: цвет бегунка в отмеченном состоянии, когда переключатель недоступен для взаимодействия

- disabledUncheckedThumbColor: цвет бегунка в неотмеченном состоянии, когда переключатель недоступен для взаимодействия

Изменим цветовую гамму переключателя:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Switch
import androidx.compose.material3.SwitchDefaults
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(false) }
            val textColor = remember { mutableStateOf(Color.Unspecified) }
            Column{
                Row (verticalAlignment = Alignment.CenterVertically ){
                    Text("Красный цвет", fontSize = 22.sp, color = textColor.value, modifier = Modifier.padding(8.dp, 0.dp))
                    Switch(
                        checked = checkedState.value,
                        onCheckedChange = {
                            checkedState.value = it
                            if(checkedState.value) textColor.value = Color(0xFFC62828)
                            else textColor.value = Color.Unspecified
                        },
                        colors = SwitchDefaults.colors(
                            checkedThumbColor = Color(0xFFC62828),
                            checkedTrackColor = Color(0xFFE57373),
                            uncheckedThumbColor = Color(0xFFEF9A9A),
                            uncheckedTrackColor = Color(0xFFFFEBEE)
                        )
                    )
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.56.png)
























# Диалоговые окна AlertDialog

Компонент AlertDialog представляет диалоговое окно, которое прерывает работу пользователя, отображая некоторую важную информацию. Этот компонент имеет следующее определение:

```kotlin
@Composable
fun AlertDialog(
    onDismissRequest: () -> Unit,
    confirmButton: @Composable () -> Unit,
    modifier: Modifier = Modifier,
    dismissButton: (@Composable () -> Unit)? = null,
    icon: (@Composable () -> Unit)? = null,
    title: (@Composable () -> Unit)? = null,
    text: (@Composable () -> Unit)? = null,
    shape: Shape = AlertDialogDefaults.shape,
    containerColor: Color = AlertDialogDefaults.containerColor,
    iconContentColor: Color = AlertDialogDefaults.iconContentColor,
    titleContentColor: Color = AlertDialogDefaults.titleContentColor,
    textContentColor: Color = AlertDialogDefaults.textContentColor,
    tonalElevation: Dp = AlertDialogDefaults.TonalElevation,
    properties: DialogProperties = DialogProperties()
): Unit
```

Параметры компонента:

- onDismissRequest: представляет функцию типа () -> Unit, которая выполняется, когда пользователь пытается закрыть диалоговое окно, нажав на область вне окна или на кнопку Назад.

- confirmButton: представляет функцию типа () -> Unit, в которой устанавливается кнопка подтверждения действия.

- modifier: объект типа Modifier, который задает модификаторы компонента

- dismissButton: представляет функцию типа () -> Unit, в которой устанавливается кнопка отмены действия.

- icon: иконка, которая отображается над заголовков или текстом

- title: устанавливает заголовок диалогового окна

- text: устанавливает текст диалогового окна

- shape: устанавливает форму диалогового окна в виде объекта Shape

- containerColor: устанавливает фоновый цвет окна

- iconContentColor: устанавливает цвет для иконки

- titleContentColor: устанавливает цвет заголовка окна

- textContentColor: устанавливает цвет текста окна

- tonalElevation: устанавливает эффект анимации

- properties: дополнительные свойства для настройки окна, которые представляют объект DialogProperties

Для создания диалогового окна достаточно установить параметры onDismissRequest и confirmButton.

Определим простейшее диалоговое окно:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val openDialog = remember { mutableStateOf(false) }
            Button({ openDialog.value = true }) {
                Text("Удалить", fontSize = 22.sp)
            }
            if (openDialog.value) {
                AlertDialog(
                    onDismissRequest = { openDialog.value = false},
                    title = { Text(text = "Подтверждение действия") },
                    text = { Text("Вы действительно хотите удалить выбранный элемент?") },
                    confirmButton = {
                        Button({ openDialog.value = false }) {
                            Text("OK", fontSize = 22.sp)
                        }
                    }
                )
            }
        }
    }
}
```

Для управления отображением окна здесь определена переменная openDialog. Если она равна true, то диалоговое окно отображается. По умолчанию она равна false, поэтому при загрузке приложения мы не увидим окна на экране.

Нажав на кнопку с надписью "Удалить", мы изменим значение переменной openDialog на true и тем самым отобразим окно.

Нажав на кнопку "OK" внутри диалогового окна (срабатывает функция onClick кнопки) или на область вне окна (срабатывает функция из параметра onDismissRequest) значение переменной openDialog будет переключено обратно на false, и диалоговое окно исчезнет.

![](https://metanit.com/kotlin/jetpack/pics/4.52.png)

Подобным образом можно настроить и другие аспекты окна. Например, добавим еще кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.BorderStroke
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Text
 
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val openDialog = remember { mutableStateOf(false) }
            val buttonColors = ButtonDefaults.buttonColors(containerColor = Color.DarkGray, contentColor = Color.LightGray)
            Button({ openDialog.value = true }, colors = buttonColors) {
                Text("Удалить", fontSize = 22.sp)
            }
            if (openDialog.value) {
                AlertDialog(
                    onDismissRequest = { openDialog.value = false},
                    title = { Text(text = "Подтверждение действия") },
                    text = { Text("Вы действительно хотите удалить выбранный элемент?") },
                    confirmButton = {
                        Button({ openDialog.value = false }, colors = buttonColors, border = BorderStroke(1.dp, Color.LightGray)) {
                            Text("Удалить", fontSize = 22.sp)
                        }
                    },
                    dismissButton = {
                        Button(
                            onClick = { openDialog.value = false }, colors = buttonColors, border = BorderStroke(1.dp, Color.LightGray)) {
                            Text("Отмена", fontSize = 22.sp)
                        }
                    },
                    containerColor = Color.DarkGray,
                    titleContentColor = Color.LightGray,
                    textContentColor = Color.LightGray,
                    iconContentColor = Color.LightGray
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.53.png)

Единственное что стоит отметить, что кнопка dismissedButton отображается перед кнопки confirmButton.


# Меню DropdownMenu

Компонент DropdownMenu позволяет компактным образом разместить ряд вариантов для выбора пользователем - некий аналог контекстного меню. DropdownMenu немного похож на всплывающее окно - он может быть отображаться, а может быть скрыт. DropdownMenu сам по себе не занимает места в разметке и отображается поверх остального контента. Обычно DropdownMenu размещается в контейнере Box, хотя это необязательное требование.

Функция компонента принимает следующие параметры:

```kotlin
@Composable
fun DropdownMenu(
    expanded: Boolean,
    onDismissRequest: () -> Unit,
    modifier: Modifier = Modifier,
    offset: DpOffset = DpOffset(0.dp, 0.dp),
    scrollState: ScrollState = rememberScrollState(),
    properties: PopupProperties = PopupProperties(focusable = true),
    shape: Shape = MenuDefaults.shape,
    containerColor: Color = MenuDefaults.containerColor,
    tonalElevation: Dp = MenuDefaults.TonalElevation,
    shadowElevation: Dp = MenuDefaults.ShadowElevation,
    border: BorderStroke? = null,
    content: @Composable ColumnScope.() -> Unit
): Unit
```

Параметры функции компонента:

- expanded: значение типа Boolean, которое устанавливает, будет ли меню отображаться (значение true) или будет скрыто (значение false)

- onDismissRequest: представляет функцию-обработчик типа () -> Unit, которая вызывается, когда пользователь нажимает на область вне меню для его закрытия

- modifier: представляет объект Modifier, который определяет модификаторы кнопки

- offset: объект типа DpOffset, который определяет смещения позиции меню относительно положения по умолчанию. По умолчанию равно DpOffset(0.dp, 0.dp)

- scrollState: значение типа ScrollState, которое применяется для настройки вертикальной прокрутки элементов.

- properties: объект типа PopupProperties, который задает дополнительные свойства меню. По умолчанию равно PopupProperties(focusable = true)

- shape: форма меню в виде объекта Shape.

- containerColor: цвет контейнера.

- tonalElevation: эффект анимации при нажатии на элемент меню.

- shadowElevation: высота тени.

- border: параметры границы в виде объекта BorderStroke.

- content: содержимое меню в виде столбца компонентов. Обычно представляет набор компонентов типа DropdownMenuItem.

Определим простейшее меню DropdownMenu:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var expanded by remember { mutableStateOf(false) }
 
            Box {
                IconButton(onClick = { expanded = true }) {
                    Icon(Icons.Default.MoreVert, contentDescription = "Показать меню")
                }
                DropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    Text("Скопировать", fontSize=18.sp, modifier = Modifier.padding(10.dp))
                    Text("Вставить", fontSize=18.sp, modifier = Modifier.padding(10.dp))
                    Divider()
                    Text("Настройки", fontSize=18.sp, modifier = Modifier.padding(10.dp))
                }
            }
        }
    }
}
```

Здесь для управления отображением меню определена переменная expanded, и ее значение привязано к параметру expanded компонента DropdownMenu. При нажатии на кнопку IconButton эта переменная получает значение true, и меню отображается на экране.

![](https://metanit.com/kotlin/jetpack/pics/4.57.png)

Само меню состоит из трех компонентов Text. Между предпоследним и последним компонентами располагается элемент Divider, который просто для красоты разделяет пункты меню горизонтальной линией.

При нажатии пользователем на область вне меню, срабатывает функция параметра onDismissRequest компонента DropdownMenu. В этой функции переменная expanded получает значение false, и меню скрывается.

## DropdownMenuItem
Обычно элементы меню DropdownMenu предоставляют компонент DropdownMenuItem:

```kotlin
@Composable
fun DropdownMenuItem(
    text: @Composable () -> Unit,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    leadingIcon: (@Composable () -> Unit)? = null,
    trailingIcon: (@Composable () -> Unit)? = null,
    enabled: Boolean = true,
    colors: MenuItemColors = MenuDefaults.itemColors(),
    contentPadding: PaddingValues = MenuDefaults.DropdownMenuItemContentPadding,
    interactionSource: MutableInteractionSource? = null
): Unit
```

Параметры функции компонента:

- text: устанавливает содержимое компонента

- onClick: представляет функцию-обработчик нажатия меню

- modifier: предствляет объект Modifier, который определяет модификаторы компонента

- leadingIcon: иконча, которая отображается в начале компонента

- trailingIcon: иконча, которая отображается в конце компонента

- enabled: значение типа Boolean устанавливает, доступен ли компонент для нажатия (значение true) или нет (значение false)

- colors: цветовые настройки меню

- contentPadding: объект типа PaddingValues, который устанавливает отступы между границами компонента и его содержимым. По умолчанию равно MenuDefaults.DropdownMenuItemContentPadding

- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }

Используем в качестве пунктов меню DropdownMenuItem:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var expanded by remember { mutableStateOf(false) }
 
            Box {
                IconButton(onClick = { expanded = true }) {
                    Icon(Icons.Default.MoreVert, contentDescription = "Показать меню")
                }
                DropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    DropdownMenuItem(
                        onClick = { },
                        text = { Text("Скопировать") }
                    )
                    DropdownMenuItem(
                        onClick = { },
                        text = {Text("Вставить")}
                    )
                    Divider()
                    DropdownMenuItem(
                        onClick = { },
                        text = {Text("Настройки")}
                    )
                }
            }
        }
    }
}
```

## Обработка выбора пунктов меню
Если пункт меню представлен компонентом DropdownMenuItem, то мы можем определить обработку выбора пункта с помощью параметра onClick:

```kotlin
ackage com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var expanded by remember { mutableStateOf(false) }
            var selectedOption by remember { mutableStateOf("") }
            Box {
                Row {
                    IconButton(onClick = { expanded = true }) {
                        Icon(Icons.Default.MoreVert, contentDescription = "Показать меню")
                    }
                    Text("Выбран пункт: $selectedOption", fontSize = 28.sp)
                }
                DropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false }
                ) {
                    DropdownMenuItem(
                        onClick = { selectedOption = "Copy" },
                        text = { Text("Скопировать") }
                    )
                    DropdownMenuItem(
                        onClick = { selectedOption = "Paste" },
                        text = { Text("Вставить") }
                    )
                    Divider()
                    DropdownMenuItem(
                        onClick = { selectedOption = "Settings" },
                        text = { Text("Настройки") }
                    )
                }
            }
        }
    }
}
```
Здесь по нажатию на любой пункт меню в обработчике нажатия передаем переменной selectedOption соответствующее значение.

## Определение позиции
Если нас не устраивает начальная позиция DropdownMenu, то мы можем ее сместить с помощью параметра offset. Он представляет объект DpOffset, который имеет два свойства: x (смещение по горизонтали) и y (смещение по вертикали). Оба свойства принимают значения в единицах dp:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.Text
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.unit.DpOffset
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var expanded by remember { mutableStateOf(false) }
            var selectedOption by remember { mutableStateOf("") }
            Box {
                IconButton(onClick = { expanded = true }) {
                    Icon(Icons.Default.MoreVert, contentDescription = "Показать меню")
                }
                DropdownMenu(
                    expanded = expanded,
                    onDismissRequest = { expanded = false },
                    offset = DpOffset(x = 20.dp, y = 10.dp)
                ) {
                    DropdownMenuItem(
                        onClick = {},
                        text = { Text("Скопировать") }
                    )
                    DropdownMenuItem(
                        onClick = {  },
                        text = { Text("Вставить") }
                    )
                    Divider()
                    DropdownMenuItem(
                        onClick = { },
                        text = { Text("Настройки") }
                    )
                }
            }
        }
    }
}
```
В данном случае строка

```kotlin
offset = DpOffset(x = 20.dp, y = 10.dp)
```

Позволяет задать смещение меню на 20 пикселей вправо и на 10 пикселей вниз




















# Индикаторы прогресса


## CircularProgressIndicator
Компонент CircularProgressIndicator представляет круговой индикатор процесса. Он имеет следующее определение:

```kotlin
@Composable
fun CircularProgressIndicator(
    progress: () -> Float,
    modifier: Modifier = Modifier,
    color: Color = ProgressIndicatorDefaults.circularColor,
    strokeWidth: Dp = ProgressIndicatorDefaults.CircularStrokeWidth,
    trackColor: Color = ProgressIndicatorDefaults.circularDeterminateTrackColor,
    strokeCap: StrokeCap = ProgressIndicatorDefaults.CircularDeterminateStrokeCap,
    gapSize: Dp = ProgressIndicatorDefaults.CircularIndicatorTrackGapSize
): Unit
```

Параметры функции компонента:

- progress: функция, которая устанавливает значение индикатора в виде объекта Float. Это значение находится в диапазаоне от 0.0 (процесс еще не начался) до 1.0 (завершение процесса).

- modifier: представляет объект Modifier, который определяет модификаторы компонента

- color: цвет индикатора

- strokeWidth: ширина индикатора

- trackColor: цвет дорожки индикатора

- strokeCap: тип линий индикатора

- gapSize: зазор между индикатором и дорожкой

Определим индикацию процесса с помощью CircularProgressIndicator:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var progress by remember { mutableStateOf(0.0f) }
            val scope = rememberCoroutineScope()
 
            Column{
                Text("Статус: $progress", fontSize = 28.sp)
                OutlinedButton(
                    onClick = {
                        if(progress >=1f) progress=0f
                        scope.launch {
                            while (progress < 1f) {
                                progress += 0.1f
                                delay(1000L)
                            }
                        }
                    }
                ) { Text("Запустить", fontSize = 22.sp) }
                CircularProgressIndicator(progress = progress)
            }
        }
    }
}
```

В данном случае значение компонента CircularProgressIndicator привязано к переменной progress. Для имитации некоторого процесса с помощью функции rememberCoroutineScope определяем контекст корутины и по нажатию на кнопку с его с помощью создаем и заускаем корутину. В этой корутине увеличиваем значение прогресса progress на 0.1f пока не дойдем до значения 1.0. Для имитации долговременной работы применяется задержка на одну секунду с помощью вызова delay():

```koltin
onClick = {
    scope.launch {
        while (progress < 1f) {
            progress += 0.1f
            delay(1000L)
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.58.png)

Также компонент имеет еще одну версию:

```kotlin
@Composable
fun CircularProgressIndicator(
    modifier: Modifier = Modifier,
    color: Color = ProgressIndicatorDefaults.circularColor,
    strokeWidth: Dp = ProgressIndicatorDefaults.CircularStrokeWidth,
    trackColor: Color = ProgressIndicatorDefaults.circularIndeterminateTrackColor,
    strokeCap: StrokeCap = ProgressIndicatorDefaults.CircularIndeterminateStrokeCap
): Unit
```

Эта версия предоставляет бесконечно прокручиваемый индикатор процессе.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.material3.CircularProgressIndicator
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box{ CircularProgressIndicator() }
        }
    }
}
```

## LinearProgressIndicator
Компонент LinearProgressIndicator представляет линейный индикатор процесса. Он имеет следующее определение:

```kotlin
@Composable
fun LinearProgressIndicator(
    progress: () -> Float,
    modifier: Modifier = Modifier,
    color: Color = ProgressIndicatorDefaults.linearColor,
    trackColor: Color = ProgressIndicatorDefaults.linearTrackColor,
    strokeCap: StrokeCap = ProgressIndicatorDefaults.LinearStrokeCap,
    gapSize: Dp = ProgressIndicatorDefaults.LinearIndicatorTrackGapSize,
    drawStopIndicator: (DrawScope.() -> Unit)? = {
        drawStopIndicator(
            stopSize = ProgressIndicatorDefaults.LinearTrackStopIndicatorSize,
            color = color,
            strokeCap = strokeCap
        )
    }
): Unit
```

Параметры функции компонента:

- progress: значение индикатора в виде объекта Float. Это значение находится в диапазаоне от 0.0 (процесс еще не начался) до 1.0 (завершение процесса).

- modifier: представляет объект Modifier, который определяет модификаторы компонента

- color: цвет закрашенной части дорожки индикатора (пройденная часть)

- trackColor: цвет незакрашенной части дорожки индикатора (еще непройденная часть)

- strokeCap: тип линий индикатора

- gapSize: зазор между дорожкой и индикатором

- drawStopIndicator: функция, которая вызывается для отрисовки индикатора остановки

Определим индикацию процесса с помощью LinearProgressIndicator:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
 
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var progress by remember { mutableStateOf(0.0f) }
            val scope = rememberCoroutineScope()
 
            Column{
                Text("Статус: $progress", fontSize = 28.sp)
                OutlinedButton(
                    modifier = Modifier.padding(20.dp),
                    onClick = {
                        scope.launch {
                            while (progress < 1f) {
                                progress += 0.1f
                                delay(1000L)
                            }
                        }
                    }
                ) { Text("Запустить", fontSize = 22.sp) }
                LinearProgressIndicator(progress = progress)
            }
        }
    }
}
```

Здесь параметр progress компонента LinearProgressIndicator привязан к значению переменной progress. Для имитации некоторого процесса с помощью функции rememberCoroutineScope определяем контекст корутины и по нажатию на кнопку с его с помощью создаем и заускаем корутину. В этой корутине увеличиваем значение прогресса progress на 0.1f пока не дойдем до значения 1.0. Для имитации долговременной работы применяется задержка на одну секунду с помощью вызова delay().

![](https://metanit.com/kotlin/jetpack/pics/4.59.png)

Параметры color и trackColor позволяют настроить цветовую схему индикатора:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var progress by remember { mutableStateOf(0.0f) }
            val scope = rememberCoroutineScope()
 
            Column{
                Text("Статус: $progress", fontSize = 28.sp)
                OutlinedButton(
                    modifier = Modifier.padding(20.dp),
                    onClick = {
                        scope.launch {
                            while (progress < 1f) {
                                progress += 0.1f
                                delay(1000L)
                            }
                        }
                    }
                ) { Text("Запустить", fontSize = 22.sp) }
                LinearProgressIndicator(
                    progress = progress,
                    color = Color.DarkGray,
                    trackColor = Color.LightGray
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.60.png)

Также компонент имеет еще одну версию:

```kotlin
@Composable
fun LinearProgressIndicator(
    modifier: Modifier = Modifier,
    color: Color = ProgressIndicatorDefaults.linearColor,
    trackColor: Color = ProgressIndicatorDefaults.linearTrackColor,
    strokeCap: StrokeCap = ProgressIndicatorDefaults.LinearStrokeCap,
    gapSize: Dp = ProgressIndicatorDefaults.LinearIndicatorTrackGapSize
): Unit
```

Эта версия предоставляет бесконечно прокручиваемый индикатор процессе. Пример ее применения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column{
                LinearProgressIndicator(modifier = Modifier.padding(20.dp))
            }
        }
    }
}
```