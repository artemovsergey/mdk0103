# Введение в Jetpack Compose

## Android и Jetpack Compose

ОС Android в настоящее время является одной из наиболее распространенных операционных систем и определенно лидирующей на рынке смартфонов. Так, на начало 2024 года ее доля на смартфонах оценивается в более чем 70%. А это миллиарды устройств. И кроме смартфонов, данная система присутствует на планшетах, телевизорах, смарт-часах и ряде других устройств.

ОС Андроид была создана разработчиком Энди Рубином (Andy Rubin) в качестве операционной системы для мобильных телефонов и поначалу развивалась в рамках компании Android Inc. Но в 2005 году Google покупает Android Inc. и начинает развивать операционную систему с новой силой. Android постоянно эволюционирует, и вместе с операционной системой эволюционируют средства и инструменты для разработки. На момент написания данной статьи последней версией является Android 14.0, которая вышла в октябре 2023 года:

|Версия|Кодовое имя        |Дата выпуска   |Уроверь API|
|:-----|:------------------|:--------------|:----------|
|14.0  |14                 |4 сентября 2023|         34|
|13.0  |13                 |15 августа 2022|         33|
|12L   |12L                |март 2022      |         32|
|11.0  |11                 |8 сентября 2020|         30|
|9.0   |Pie                |6 августа 2018 |         28|
|8.1   |Oreo               |5 декабря 2017 |         27|
|8.0   |Oreo               |21 августа 2017|         26|
|7.1   |Nougat             |4 октября 2016 |         25|
|7.0   |Nougat             |22 августа 2016|         24|
|6.0   |Marshmallow        |5 октября 2015 |         23|
|5.1   |Lollipop           |9 марта 2015   |         22|
|5.0   |Lollipop           |3 ноября 2014  |         21|
|4.4   |KitKat             |31 октября 2013|         19|
|4.3   |Jelly Bean         |24 июля 2013   |         18|
|4.2   |Jelly Bean         |13 ноября 2012 |         17|
|4.1   |Jelly Bean         |9 июля 2012    |         16|
|4.0   |Ice Cream Sandwich |16 декабря 2011|         15|
|2.3   |Gingerbread        |6 декабря 2010 |         10|

И в связи со столь широким распространнением системы большое значение получает создание приложений под эту систему. Для разработки под Android использовалось и продолжает использоваться большое количество различных инструментов. Иначально ключевым языком для создания приложений являлся язык Java. Однако в последствии основным языком стал Kotlin. И в данном руководстве мы как раз и будем рассматривать разработку приложений под Android на языке Kotlin с помощью такого инструмента как Jetpack Compose.

Что такое Jetpack Compose
Jetpack Compose представляет современный тулкит от компании Google для создания приложений под ОС Android на языке программирования Kotlin. Jetpack Compose упрощает написание и обновление визуального интерфейса приложения, предоставляя декларативный подход.

Операционной системе Android более 10 лет. За этот период API и библиотеки для создания приложений под эту ОС много раз обновлялись, дополнялись, одни API устаревали, другие, наоборот, добавлялись в арсенал разработчиков. Но в этоге подобное развитие привело к усложнению платформы. Чтобы упростить разработку, сделать ее более быстрой, простой, упростить поддержку компания Google в мае 2019 года анонсировала новый тулкит - Jetpack Compose. В августе 2020 вышла первая альфа-версия тулкита. А 28 июля 2021 года вышла первая стабильная версия - Jetpack Compose 1.0, которая является текущей на момент написания данной статьи и которая применяется далее в дальнейших статьях данного руководства. Также постоянно выходят подверсии. Например, текущей подверсией на момент написания данной статьи является 1.6.2 (вышла в январе 2024 г.).

Jetpack совместим с существующим набором библиотек Android, которые можно использовать в стандартных проектах на Java и Kotlin для написания приложений под Android. Отличительной же чертой Jetpack Compose является то, что он предлагает кардинально другой подход к созданию приложений под Android.

Прежде всего, Jetpack Compose предлагает использовать язык Kotlin и все его преимущества. Соответственно для работы с тулкитом необходимо иметь базовые знания данного языка. Для этого можно обратиться к руководству по языку Kotlin на этом сайте.

Jetpack уменьшает объем кода, что упрощает управление кода, его поддержку и дальнейшее развитие.

Jetpack Compose предлагает декларативный API, который является более интуитивным.

Jetpack Compose ориентирован на данные (data-driven-подход). В частности, Compose применяет концепцию состояния (state). Данные сохраняются как состояние, что гарантирует, что при любые изменения в данных автоматически отразяться на изменении пользовательского интерфейса. Соответственно не потребуется определять какой-то дополнительный код, который бы отслеживал наличие изменений. Любой компонент интерфейса, который обращается к состоянию, подписывается на все изменения этого состояния. И когда состояние изменяется, подписанный компонент пересоздается, чтобы отразить изменения в состоянии. Данный процесс еще называется рекомпозиция.

При этом Jetpack Compose совместим с уже имеющимся кодом. Например, можно вызывать код Jetpack Compose из традиционного приложения на Android. Большинство стандартных библиотек под Android также работают с Jetpack Compose.

Ключевой концепцией тулкита Jetpack Compose является composable-функция (функция, которая имеет аннотацию @Composable). Такие функции представляют некоторые части визуального интерфейса, из которых строится приложение. Это упрощает построение и обновление сложных интерфейсов, тестирование и поддержку самих компонентов.

Для создания приложений с Jetpack Compose нам потребуется специальный комплект инструментов Android SDKи такая среда разработки как Android Studio, которая создана специально для разработки под ОС Android и установщик которой можно загрузить с официального сайта: https://developer.android.com/studio. Android Studio предоставляет богатый инструментарий для создания, отладки и тестирования приложений на Jetpack Compose, предоставляет возможность предпросмотра приложения без запуска на устройстве. Далее мы подробно рассмотрим процесс установки Android Studio на различные операционные системы.

И естественно для тестирования приложений потребуется устройство с ОС Android. Хотя Android Studio позволяет установить и использовать эмулятор устройства, но подобные эмуляторы довольно ресурсоемки (учитывая, что сама Android Studio также потребует большин аппаратных ресурсов). Кроме того, ни один эмулятор полноценно не заменит реальное устройство. Поэтому я бы рекомендовал использовать смарфтон или планшет для тестирования приложений.

## Архитектура Android
Архитектуру патформы можно представить следюущим образом:

![](https://metanit.com/kotlin/jetpack/pics/1.16.png)

В основе платформы Android лежит ядро Linux. Например, среда выполнения Android Runtime (ART) зависит от ядра Linux при выполнении ключевых функциональностей, как например, управление потоками или низкоуровневое управление памятью. Использование Linux упрощает для разработчиков устройств создание драйверов, поскольку Linux - известная платформа.

Hardware abstraction layer (HAL) предоставляет стандартные интерфейсы, которые упрощают для вышележащих слоев (Java API) обращение к оборудованию. HAL состоит из многочисленных модулей библиотек, которые реализуют интерйес для работы с определенным аппаратным компонентом, например, с камерой или Bluetooth. Когда API фреймворка обращается к аппаратному компоненту устройства, Android загружает библиотечный модуль для этого устройства.

Android Runtime (ART) выполняет приложение Android. Когда создается приложение Android, то оно обычно компилируется в промежуточный формат байт-кода Dalvik Executable (DEX) - формат байткода, который разработан специально для Android и который потребляет минимальное количество памяти. Когда приложение впоследствии загружается на устройство, среда выполнения Android Runtime использует процесс, называемый AOT-компиляцией, для преобразования байт-кода в формате DEX в машинные инструкции, которые понятны процессору устройства. Этот формат известен как формат ELF. При каждом последующем запуске приложения запускается исполняемая версия ELF, что приводит к повышению производительности приложения и увеличению времени автономной работы.

Также Android содержит некотрый набор библиотек выполнения, которые предоставляют функциональность для выполнения кода на Java и Kotlin.

Основные библиотеки Android Runtime основаны на Java и предоставляют основные API-интерфейсы для разработчиков, пишущих приложения для Android. Однако важно отметить, что эти библиотеки не выполняют большую часть реальной работы и, по сути, являются Java-обертками для набора библиотек на основе C/C++. Например, при вызове библиотеки android.opengl для рисования 3D-графики на дисплее устройства библиотека в конечном итоге обращается к библиотеке OpenGL ES C++, которая, в свою очередь, работает с базовым ядром Linux для выполнения задач рисования. Android включает библиотеки C/C++ для выполнения широкого и разнообразного спектра функций, включая рисование 2D- и 3D-графики, SSL, управление базами данных SQLite, воспроизведение аудио и видео, рендеринг растровых и векторных шрифтов, подсистему отображения и управление графическими слоями и реализация стандартной системной библиотеки C (libc).

На практике типичный разработчик приложений Android будет получать доступ к этим библиотекам исключительно через API-интерфейсы на основе Java. Если необходим прямой доступ к этим библиотекам, этого можно добиться с помощью Android Native Development Kit (NDK), целью которого является прямой вызов функциональности на C/C++.

Весь набор функций ОС Android доступен через API, написанные на языке Java. Эти API образуют строительные блоки, необходимые для создания приложений Android, упрощая повторное использование основных системных компонентов и сервисов. Ключевые сервисы и компоненты:

- Activity Manager: управляет жизненным циклом приложения и стеком навигации.

- Content Providers: позволяют приложениям публиковать данные и обмениваться ими с другими приложениями.

- Resource Manager: обеспечивает доступ к встроенным ресурсам, не связанным с кодом, таким как строки, настройки цвета и макеты пользовательского интерфейса

- Notifications Manager: позволяет приложениям отображать пользователю оповещения и уведомления

- View System: расширяемый набор представлений, используемый для создания графического интерфейса

- Package Manager: система, с помощью которой приложения могут получать информацию о других приложениях, установленных в данный момент на устройстве

- Telephony Manager: предоставляет приложению информацию о телефонных услугах, доступных на устройстве, например статус и информацию об абоненте.

- Location Manager: обеспечивает доступ к службам определения местоположения, позволяя приложению получать обновления об изменениях местоположения.

На вершине стека платформы Android находятся приложения. К ним относятся как системные приложения, поставляемые с конкретной реализацией Android (например, веб-браузер и приложения электронной почты), так и сторонние приложения, установленные пользователем после покупки устройства.


# Первый проект на Jetpack Compose

Итак, создадим первый проект с использованем тулкита Jetpack Compose. Для этого запустим среду Android Studio.

Если мы находимся в окне Welcome to Android Studio, то для создания проекта нажмем на кнопку New Project. Если в Android Studio уже открыт какой-то проект, то выберем в меню File -> New -> New Project.

![](https://metanit.com/kotlin/jetpack/pics/1.1.png)

Далее в открывшемся окне шаблонов проекта выберем пункт Empty Activity и нажмем на кнопку Next.

![](https://metanit.com/kotlin/jetpack/pics/1.2.png)

Затем нам откроется окно настроек проекта:

![](https://metanit.com/kotlin/jetpack/pics/1.3.png)

В этом окне мы можем установить начальные настройки проекта:

В поле Name вводится название приложения. Укажем в качестве имени название HelloApp

В поле Package Name указывается имя пакета, где будет размещаться главный класс приложения. В данном случае для тестовых проектов это значение не играет ольшого значения, поэтому установим com.example.helloapp.

В поле Save Location установливается расположение файлов проекта на жестком диске. Можно оставить значение по умолчанию.

В поле Minimum SDK указывается самая минимальная поддерживаемая версия SDK. Оставим значение по умолчанию. В моем случае это API 24 ("Nougat"; Android 7.0), которая означает, что приложение можно будет запустить начиная с Android 7.0, а это 96% устройств. На более старых устройствах запустить будет нельзя.

Стоит учитывать, что чем выше версия SDK, тем меньше диапазон поддерживаемых устройств.

В поле Build configuration language указывается язык, который применяется для определения конфигурации построения проекта. Оставим здесь значение по умолчанию.

Далее нажмем на кнопку Finish, и Android Studio создаст новый проект:

![](https://metanit.com/kotlin/jetpack/pics/1.4.png)

Вначале вкратце рассмотрим структуру проекта, что он уже имеет по умолчанию

![](https://metanit.com/kotlin/jetpack/pics/1.5.png)

Проект Android может состоять из различных модулей. По умолчанию, когда мы создаем проект, создается один модуль - app. Модуль по умолчанию включает три каталога:

manifests: хранит файл манифеста AndroidManifest.xml, который описывает конфигурацию приложения и определяет каждый из компонентов данного приложения.

kotlin+java: хранит файлы кода на языке Kotlin, которые структурированы по отдельным пакетам. Так, в папке com.example.helloapp (название которого было указано на этапе создания проекта) имеется по умолчанию файл MainActivity.kt с кодом на языке Kotlin, который представляет класс MainActivity, запускаемый по умолчанию при старте приложения

Также в этой папке определен подкаталог ui.theme, который содержит ряд файлов на языке Kotlin: Color.kt, Theme.kt и Type.kt, которые определяют ряд вспомогательных типов, функций, переменных, применяемых для создания графического интерфейса.

res: содержит используемые в приложении ресурсы. Все ресурсы разбиты на подпапки.

папка drawable предназначена для хранения изображений, используемых в приложении

папки mipmap содержат файлы изображений, которые предназначены для создания иконки приложения при различных разрешениях экрана.

папка values хранит различные xml-файлы, содержащие коллекции ресурсов - различных данных, которые применяются в приложении. По умолчанию здесь есть два файла и одна папка:

файл colors.xml хранит описание цветов, используемых в приложении

файл strings.xml содержит строковые ресурсы, используемые в приложении

папки themes хранит две темы приложения - для светлую (дневную) и темную (ночную)

Отдельный элемент Gradle Scripts содержит ряд скриптов Gradle, которые используются при построении приложения.

Во всей этой структуре следует выделить файл MainActivity.kt, который открыт в Android Studio и который содержит логику приложения и собственно с него начинается выполнение приложения.

### Запуск проекта

Теперь запустим созданный выше проект. Для запуска и тестирования проекта можно использовать как различные эмуляторы, так и реальные устройства. Для тестирования на реальном устройстве на нем должен быть включен режим разработчика. В моем случае я запущу проект на реальном устройстве.

Для запуска проекта нажмем на зеленую стрелочку на панели инструментов.

![](https://metanit.com/kotlin/jetpack/pics/1.6.png)

И после успешного запуска на устройстве/емуляторе мы сможем насладиться надписью "Hello Android":

![](https://metanit.com/kotlin/jetpack/pics/1.7.png)


# Создание визуального интерфейса

При создании проекта, который использует Jetpack Compose, в Android Studio, в проект по умолчанию добавляется файл MainActivity.kt, который содержит одноименный класс MainActivity. Этот класс определяет интерфейс, который мы видим на устройстве/эмуляторе при запуске проекта. Так, по умолчанию графический интерфейс будет выглядеть будет следующим образом:

![](https://metanit.com/kotlin/jetpack/pics/1.7.png)

Рассмотрим основные моменты кода, который добавляется в файл MainActivity.kt и который определяет подобный интерфейс:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import com.example.helloapp.ui.theme.HelloAppTheme
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloAppTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    Greeting("Android")
                }
            }
        }
    }
}
 
@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Text(
        text = "Hello $name!",
        modifier = modifier
    )
}
 
@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    HelloAppTheme {
        Greeting("Android")
    }
}
```

Рассмотрим основные моменты этого кода вкратце. Вначале идет определение пакета, к которому принадлежит класс MainActivity. В моем случае это пакет com.example.helloapp:

```kotlin
package com.example.helloapp
```

Далее идут подключаемые пакеты, функционал который использует класс MainActivity:

```kotlin
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.tooling.preview.Preview
import com.example.helloapp.ui.theme.HelloAppTheme
```

Обратите внимание на последний подключаемый пакет - он представляет функционал из каталога ui.theme, который также добавляется в проект по умолчанию и который содержит ряд файлов на языке Kotlin: Color.kt, Theme.kt и Type.kt.

![](https://metanit.com/kotlin/jetpack/pics/1.11.png)

Далее идет определение класса MainActivity

```kotlin
class MainActivity : ComponentActivity() {
```

Приложение на Android определяется как набор объектов, которые называются activity. Объект activity фактически представляет отдельное окно графического приложения. И класс MainActivity как раз представляет окно, которое отображается при запуске приложения

MainActivity наследуется от встроенного класса ComponentActivity. ComponentActivity обеспечивает построение интерфейса из визуальных компонентов и для этого предоставляет минимальный функционал. В частности, ComponentActivity предоставляет метод onCreate(), который вызывается при запуске MainActivity и создает ее интерфейс:

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent { ......
```

В метод передается объект Bundle, который хранит состояние MainActivity - некоторые значения, которые хранят связанные с MainActivity данные. А в самом методе onCreate() вначале вызывается реализация этого метода из базового класса ComponentActivity.

Для собственно создания интерфейса в onCreate() вызывается другой метод базового класса ComponentActivity - метод setContent(). Этот метод собственно и определяет, какой интерфейс мы увидим на экране устройства. Этот метод выполняет функцию, в которой устанавливается компонент @Composable:

```kotlin
setContent {
    HelloAppTheme {
        Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
            Greeting("Android")
        }
    }
}
```

## @Composable

Что такое компонент @Composable? Функция @Composable представляет центральную концепцию фреймворка Jetpack Compose и, грубо говоря, представляет некоторый визуальный компонент. Причем этот компонент должен быть оформлен в виде функции с аннотацией @Composable. Так, в проекте по умолчанию пользовательский интерфейс определяется функцией HelloAppTheme, которая определена в проекте в файле Theme.kt:

```kotlin
@Composable
fun HelloAppTheme(
        darkTheme: Boolean = isSystemInDarkTheme(),
        dynamicColor: Boolean = true,
        content: @Composable () -> Unit
) {
    .......................................
 
    MaterialTheme(
            colorScheme = colorScheme,
            typography = Typography,
            content = content
    )
}
```

Эта функция кроме того, что задает визуальный интерфейс, также обеспечивает соответствие приложения текущей теме (светлой или темной) устройства. Для этого она в качестве первого параметра принимает в качестве первого параметра булевое значение, которое указывает, выбрана ли темная тема. В зависимости от значения этого параметра устанавливает соответствующие цвета, которые определены в файле Color.kt. Последний параметр представляет еще один компонент @Composable - то есть опять же некоторый визуальный компонент. Далее этот компонент передает в в MaterialTheme.

MaterialTheme задает визуальный интерфейс в стиле Material Design. Для этого он использует также настройки шрифта в виде компонента Typography из файла Type.kt. Можно сказать, что фактически за компонентом HelloAppTheme прячется объект MaterialTheme, которой устанавливает дизайн в стиле Material Design. Однако что именно передается в сам MaterialTheme?

Если мы вернемся к файлу MainActivity.kt, то увидим что это компонент Surface:

```kotlin
Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
    Greeting("Android")
}
```

Surface фактически представляет промежуточный компонент, который задает дополнительное оформление в стиле Material Design. В этот компонент передается компонент Greeting, который определен в том же файле:

```kotlin
@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Text(
            text = "Hello $name!",
            modifier = modifier
    )
}
```

Этот компонент использует другой встроенный компонент - Text, который представляет некоторый текст. Именно этот текст в итоге мы увидим на экране устройства.

И в данном случае мы видим, что для вывода простой надписи "Hello Android" используется целый набор компонентов @Composable, которые вложены в друг друга по принципу матрешки: Text -> Greeting -> Surface -> MaterialTheme -> HelloAppTheme

## Предварительный вид компонентов

Однако выше не была упомянута еще одна часть кода MainActivity.kt - функция GreetingPreview:

```kotlin
@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    HelloAppTheme {
        Greeting("Android")
    }
}
```

Здесь мы видим, что GreetingPreview - это также аннотацию @Composable, и соответственно может представлять некоторую часть визуального интерфейса. И в реальности он скрывает компонент HelloAppTheme - то есть фактически весь тот же самый интерфейс, что и определен в классе MainActivity. Но важная часть определения этого компонента - аннотация @Preview. Она указывает, что данный компонент будет применяться для предварительного просмотра. То есть, чтобы узнать, как будет выглядеть наш интерфейс, нам необязательно запускать приложение на устройстве/эмуляторе. В случае небольших, но частых изменений это может быть довольно утомительно. А с помощью этого компонента мы можем увидить, что это будет за интерфейс.

Весь интерфейс в компоненте GreetingPreview можно увидеть в Android Studio при просмотре в режиме Design или Split:

![](https://metanit.com/kotlin/jetpack/pics/1.12.png)

С помощью параметров аннотации @Preview можно настраивать предварительный просмотр. Например, если надо отобразить остальную часть экрана, то можно установить опцию showSystemUi = true:

```
@Preview(showSystemUi = true)
```

![](https://metanit.com/kotlin/jetpack/pics/1.15.png)


Стоит отметить, что окно предварительного просмотра автоматически подхватывает все изменения в интерфейсе приложения

## Изменение интерфейса

По умолчанию корневым компонентом является HelloAppTheme, который определен в проекте в файле ui.theme/Theme.kt. Однако нам в принципе необязательно использовать всю эту комплексную композицию компонентов. Так, в примере выше, если убрать настройку темы приложения, то по сути все, что оно делает - это выводит некоторый текст на экран устройства. И в реальности мы могли бы в этом случае ограничиться одним компонентом Text. Так, изменим код MainActivity.kt следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(text = "Hello METANIT.COM!", fontSize = 28.sp)
        }
    }
}
```

Компонент, который представляет по сути то, что мы увидим на экране устройства, передается в метод setContent() класса MainActivity. И в данном случае в этот метод сразу передается компонент Text.

У этого компонента устанавливаются в данном случае два свойства. Свойство text представляет выводимый текст. Кроме того, здесь устанавливается свойство fontSize, которое задает размер шрифта. В качестве значения оно принимает числовое значение в единицах sp.

В итоге приложение будет выглядеть следующим образом:

![](https://metanit.com/kotlin/jetpack/pics/1.13.png)


# Создание компонентов Composable

Основой пользовательского интерфейса в Jetpack Compose являются компоненты, которые оформлены в виде функции с аннотацией @Composable. При вызове @Composable-компонента обычно передаются некоторые данные и набор свойств, которые определяют отображение и поведение определенной части пользовательского интерфейса. По сути, функции @Composable преобразуют данные в элементы пользовательского интерфейса. Эти функции не возвращают значения в традиционном смысле функции Kotlin, а вместо этого определяют элементы пользовательского интерфейса для рендеринга.

@Composable-функции могут вызывать другие подобные компоненты для создания иерархии компонентов. При разработке приложений с помощью Compose мы можем как определять свои собственные компоненты, так и использовать встроенные. Собственно типичный пользовательский интерфейс на основе Compose обычно состоит из комбинации встроенных и кастомных @Composable-компонентов.

Встроенные компоненты, которые по умолчанию входят в состав Compose, можно разделить на три категории: Layout, Foundation и Material Design.

В категорию Layout входят компоненты, которые определяют макет приложения, позволяют определить расположение других компонентов на экране. В частности, это следуюшие компоненты:

Box

BoxWithConstraints

Column

ConstraintLayout

Row

Компоненты Foundation — это набор минимальных компонентов, которые обеспечивают базовую функциональность пользовательского интерфейса. Например, это:

BaseTextField

Canvas

Image

LazyColumn

LazyRow

Shape

Text

Компоненты Material Design разработаны так, чтобы они соответствовали рекомендациям визуальному стилю Google Material. Например, это:

AlertDialog

Button

Card

CircularProgressIndicator

DropdownMenu

Checkbox

FloatingActionButton

LinearProgressIndicator

ModalDrawer

RadioButton

Scaffold

Slider

Snackbar

Switch

TextField

TopAppBar

BottomNavigation

Создание своего компонента
Аналогично мы могли бы создать свой компонент на основе имеющихся и использовать его в качестве корневого компонента. Например, изменим код следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Hello()
        }
    }
}
 
@Composable
fun Hello() {
    Text(text = "Hello METANIT.COM!",
        style = TextStyle(
            fontSize = 28.sp
        )
    )
}
```

Здесь мы определили свой компонент Hello, внутри которого по сути используется встроенный компонент Text. Чтобы функция Hello рассматривалась как компонент, к ней применяется аннотация @Composable из пакета androidx.compose.runtime. Причем функции компонентов естественно можно вынести в отдельные файлы и даже пакеты и оттуда подключать.

Настройка предварительного просмотра
И также для наших компонентов можно задать предварительный просмотр в Android Studio, что позволяет уже до запуска увидеть, как будет выглядеть приложение. Так, изменим код MainActivity.kt следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Hello()
        }
    }
}
 
@Composable
fun Hello() {
    Text(text = "Hello METANIT.COM!",
        style = TextStyle(
            fontSize = 28.sp
        )
    )
}
 
@Preview(showSystemUi = true)
@Composable
fun HelloPreview() {
    Hello()
}
```

Здесь добавлен компонент HelloPreview, который использует компонент Hello. К компоненту HelloPreview применяется аннотация @Preview из пакета androidx.compose.ui.tooling.preview. Свойство showSystemUi = true этой аннотации позволяет увидеть интерфейс приложения в целом в области предпросмотра в Android Studio:

![](https://metanit.com/kotlin/jetpack/pics/1.17.png)


## Механика функций Composable
Исходный код аннотации Composable выглядит следующим образом:

```kotlin
@MustBeDocumented
@Retention(AnnotationRetention.BINARY)
@Target(
AnnotationTarget.FUNCTION,
AnnotationTarget.TYPE,
AnnotationTarget.TYPE_PARAMETER,
AnnotationTarget.PROPERTY_GETTER
)
annotation class Composable
```

Здесь мы видим, что к классу аннотации, в совю очередь, применяются три других аннотации:

@MustBeDocumented: указывает, что аннотация является частью общедоступного API и должна быть включена в создаваемую документацию.

@Retention: сообщает компилятору, как долго должна сохраняться аннотация. Значение AnnotationRetention.BINARY позволяет сохранить код в бинарном файле во время компиляции.

@Target: описывает контексты, в которых применяется этот тип. @Composable можно применять к типам, параметрам, функциям и свойствам.

Последняя аннотация указывает, что мы можем применять аннотацию @Composable гораздо шире, чем просто к функции верхнего уровня, как в примерах выше. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Message("Hello METANIT.COM!").printMessage()
        }
    }
}
 
class Message(val messageText:String){
    @Composable
    fun printMessage(){
        Text(text = messageText)
    }
}
```

Здесь аннотация @Composable применяется к функции printMessage внутри класса Message. Эта функция определяет компонент Text, в который передается значение свойства messageText. То есть функция printMessage выступает в качестве компонента. И мы можем использовать этот компонент, вызывав данную функцию:

```kotlin
setContent {
    Message("Hello METANIT.COM!").printMessage()
}
```

Соответственно фактически интерфейс будет определяться компонентом Text, который выведет строку "Hello METANIT.COM!":

![](https://metanit.com/kotlin/jetpack/pics/1.13.png)

## setContent
Теперь пришло время, чтобы сказать чуть подробнее, как устанавливается, корневой компонент. Это происходит в методе setContent. Сигнатура метода setContent() выглядит следующим образом:

```kotlin
fun ComponentActivity.setContent(
    parent: CompositionContext? = null,
    content: @Composable () -> Unit
) { ... }
```

Как можно видеть, setContent() является функцией расширения типа ComponentActivity. Функции расширения добавляют классу дополнительную функциональность без изменения его исходного кода. Это означает, что метод setContent() можно использовать для любого ComponentActivity или его подклассов, например AppCompatActivity.

Вызов setContent() устанавливает функцию из параметра content в качестве корневого компонента, который выступает в качестве контейнера для всех остальных компонентов и в который можно добавить произвольное количество других компонентов. Обратите внимание, что функция content также аннотируется с помощью аннотации @Composable. Так как аннотация @Target позволяет применять аннотацию @Composable к параметрам функции. Конкретно в данном случае аннотация @Composable помечает передаваемую параметру content функцию как Composable-функцию.

Еще один параметр метода setContent() представляет объект CompositionContext, который предствляет контекст композиции интерфейса и используется для рекомпозиции - обновления пользовательского интерфейса.

## Компонент как параметр
Определение метода setContent демонстрирует один из распространенных способов передачи компонентов в другие компоненты. Подобная организация очень удобна, поскольку мы можем в функции получить компонент, как-то настроить его, выполнить с ним некоторые действия.

Например, определим следующее приложение:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Message{
                Text(text = "Hello World", fontSize = 28.sp)
            }
        }
    }
}
@Composable
fun Message(content: @Composable () -> Unit){ content()}
```

Здесь определен компонент Message, который через параметр принимает некоторую функцию-компонент. Внутри компонента Message мы просто вызываем переданную функцию.

Методе setContent вызываем компонент Message. А в функции, которая передается в Message через параметр content, вызываем компонент Text:

```kotlin
Message{
    Text(text = "Hello World", fontSize = 28.sp)
}
```

# Взаимодействие с кодом Kotlin

Jetpack Compose предполагает применение декларативного стиля при определении визуального интерфейса и работы с ним. В этом отношении иногда возникает вопрос как определять какие-то свои собственные данные в виде переменных или действия в виде функций и использовать эти переменные и функции в компонентах для создания графического интерфейса. Рассмотрим некоторые случаи.

## Использование переменных
Как и в общем случае переменные можно определять на уровне класса (например, на уровне класса MainActivity), либо на уровне отдельного метода/функции, в том числе и в функциях Composable. Например, используем пару переменных:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Hello()
        }
    }
}
 
@Composable
fun Hello(){
    val message = "Hello Metanit.com"
    val size = 28.sp
    Text(text = message, fontSize = size)
}
```

В данном случае в компоненте Hello определяются две переменных, и их значения передаются параметрам компонента Text:

![](https://metanit.com/kotlin/jetpack/pics/5.4.png)

Это относится ко всем функциям, которые принимают компоненты в качестве параметров. Причем функция каждого компонента определяет свою область видимости, в рамках которой доступны ее переменные. Вложенные компоненты имеют доступ к переменным, определенным в родительских компонентах. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.Composable
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val textSize = 28.sp
            Hello{
                val content = "Hello Work"
                Text(content, fontSize = textSize)
            }
        }
    }
}
```

Здесь иерархию компонентов можно представить следующим образом: setContent -> Hello -> Text. На уровне компонента setContent определяется переменная textSize - она видна на уровне компонентов в setContent.

На уровне компонента Hello определена переменная content - она доступна во вложенных компонентах, в частности, в компоненте Text, но недоступна вне компонента Hello.

## Вызов функций Kotlin
Стоит отметить, что @Composable-функция может вызывать и стандартные функции Kotlin, однако стандартные функции не могут вызывать @Composable-функции. Например, изменим код MainActivity.kt следующим образом:

```kotlin
Здесь иерархию компонентов можно представить следующим образом: setContent -> Hello -> Text. На уровне компонента setContent определяется переменная textSize - она видна на уровне компонентов в setContent.

На уровне компонента Hello определена переменная content - она доступна во вложенных компонентах, в частности, в компоненте Text, но недоступна вне компонента Hello.

Вызов функций Kotlin
Стоит отметить, что @Composable-функция может вызывать и стандартные функции Kotlin, однако стандартные функции не могут вызывать @Composable-функции. Например, изменим код MainActivity.kt следующим образом:
```

В данном случае определена стандартная функция getTime, которая с помощью встроенного класса Calendar получает текущее время (часы и минуты) и возвращает его в виде строки. В компоненте Text эта функция используется для установки текста.

![](https://metanit.com/kotlin/jetpack/pics/5.5.png)

Подобным образом можно определять и вызывать лямбда-выражения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import java.util.Calendar
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val getTime ={
                val calendar = Calendar.getInstance()
                val hours = calendar.get(Calendar.HOUR_OF_DAY)
                val minutes = calendar.get(Calendar.MINUTE)
                "$hours:$minutes"
            }
            Text(text = getTime(), fontSize = 28.sp)
        }
    }
}
```

## Условные конструкции
Внутри компонентов также можно использовать все стандартные управляющие конструкции, например, условные конструкции, в том числе для создания интерфейса:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val hours = 19
            if(hours<18) {
                Text(text = "Добрый день", fontSize = 28.sp)
            }
            else{
                Text(text = "Добрый вечер", fontSize = 28.sp)
            }
        }
    }
}
```

Здесь в зависимости от переменной hour в качестве внутренного содержимого установливается определенный компонент.

## Циклы
Если необходимо создать ряд отднотиных компонентов, то удобно определить различающиеся данные в виде списка, а в цикле по этому списку создать набор компонентов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Python")
            Column{
                for(lang in langs){
                    Text(text = lang, fontSize = 28.sp)
                }
            }
        }
    }
}
```

Здесь применяется встроенный компонент Column, который располагает вложенные компоненты в столбик. Но эти компоненты здесь создаются динамически. В начале определяем данные в виде списке langs. В столбце Column пробегаемся по этому списку и создаем для каждого свой компонент Text

![](https://metanit.com/kotlin/jetpack/pics/5.6.png)

Причем в данном случае мы также могли бы применить и встроенную функцию forEach() списка, которая позволяет перебрать все объекты:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Scala")
            Column{
                langs.forEach{lang ->
                        Text(text = lang, fontSize = 28.sp)
                }
            }
        }
    }
}
```

# Gradle

Общий обзор Gradle
Gradle представляет набор инструментов для автоматической сборки, который позволяет настраивать и управлять сборкой проектов с помощью специальных файлов конфигурации. В частности, можно задать, как будет собираться проект, какие зависимости необходимо добавить для успешной сборки и каким должен быть конечный результат (или результаты) процесса сборки. Правила конфигурации для сборки проекта объявляются в файлах сборки Gradle и сценариях на основе языка программирования Groovy. Стоит отметить, что в Android Studio интеграция Gradle обеспечивается через специальный одноименный плагин.

Gradle имеет предопределенный набор параметров конфигурации по умолчанию, которые будут использоваться, если только настройки в файлах сборки не переопределят их. Это означает, что сборки могут выполняться с минимальной конфигурацией, необходимой разработчику. Изменения в файлах сборки необходимы только в том случае, если конфигурация по умолчанию не соответствует текущим потребностям сборки.

Один из ключевых моментов конфигурации Gradle — это зависимости - модули, которые необходимы для работы приложения и функционаьность которых используется в приложении. Зависимости Gradle можно разделить на локальные и удаленные. Локальная зависимость ссылается на элемент, присутствующий в локальной файловой системе на текущем компьютере, на котором выполняется сборка. Удаленная зависимость относится к элементу, который присутствует на удаленном сервере (обычно называемом репозиторием).

Удаленные зависимости для проектов Android Studio обрабатываются с помощью другого инструмента управления проектами под названием Maven. Если удаленная зависимость объявлена в файле сборки Gradle с использованием синтаксиса Maven, то зависимость будет автоматически загружена из назначенного репозитория и включена в процесс сборки.

Gradle также обеспечивает поддержку вариантов сборки для проектов Android Studio. Это позволяет создавать несколько вариантов приложения из одного проекта. Android работает на множестве различных устройств с разными типами процессоров и размерами экранов. Чтобы охватить как можно более широкий диапазон типов и размеров устройств, часто бывает необходимо создать несколько вариантов приложения (например, один с пользовательским интерфейсом для телефонов, а другой — для планшетов).

С каждым проектом Android Studio связан файл AndroidManifest.xml (файл манифеста), который содержит сведения о конфигурации приложения. В файлах сборки Gradle можно указать несколько записей манифеста, которые затем автоматически генерируются в файл манифеста при сборке проекта. Эта возможность дополняет функцию вариантов сборки, позволяя настраивать такие элементы, как номер версии приложения, идентификатор приложения и информацию о версии SDK, для каждого варианта сборки.

ProGuard — это инструмент, включенный в Android Studio, который оптимизирует, сжимает и запутывает байт-код Java, чтобы сделать его более эффективным и трудным для дизассемблирования/декомпиляции. Файлы сборки Gradle позволяют контролировать, будет ли ProGuard запускаться при сборке проекта.


## Файлы Gradle
Все файлы Gradle в проекте можно увидеть в узле Gradle Scripts:

![](https://metanit.com/kotlin/jetpack/pics/20.1.png)

## Свойства и настройки Gradle
Файл gradle.properties содержит в основном настройки флагов командной строки, используемым виртуальной машиной Java (JVM), а также указывают, использует ли проект библиотеки AndroidX и поддерживает ли стиль кодирования Kotlin:

```kotlin
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

Обычно не требуется изменить какие-либо параметры в этом файле.

Файл settings.gradle.kts определяет, какие онлайн-репозитории следует использовать, когда системе сборки необходимо загрузить и установить любые дополнительные библиотеки и плагины, необходимые для сборки проекта, а также имя проекта. Типичный файл settings.gradle.kts выглядит следующим образом:

```kotlin
pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\.android.*")
                includeGroupByRegex("com\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
 
rootProject.name = "HelloApp"
include(":app")
```

## Файл Gradle проекта
Каждый проект содержит один файл сборки Gradle верхнего уровня. Этот файл указан как build.gradle.kts (Project: <имя проекта>)

![](https://metanit.com/kotlin/jetpack/pics/20.2.png)

По умолчанию он имеет содержимое типа следующего:

```
plugins {
    alias(libs.plugins.androidApplication) apply false
    alias(libs.plugins.jetbrainsKotlinAndroid) apply false
}
```

В большинстве случаев не требуется изменять данных файл.

## Файл Gradle модуля
Проект приложения может состоять из одного или нескольких модулей. И для каждого модуля потребуется собственный файл сборки Gradle. По умолчанию, когда создается проект в Android Studio, в нем создается один модулья, который называется app. Соответственно для него определяется файл сборки Gradle уровня модуля, который называется build.gradle.kts (Module :app):

![](https://metanit.com/kotlin/jetpack/pics/20.3.png)

По умолчанию он выглядит примерно следующим образом:

```kotlin
plugins {
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.jetbrainsKotlinAndroid)
}
 
android {
    namespace = "com.example.helloapp"
    compileSdk = 34
 
    defaultConfig {
        applicationId = "com.example.helloapp"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"
 
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }
 
    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
    kotlinOptions {
        jvmTarget = "1.8"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.1"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}
 
dependencies {
 
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}
```

Как правило, если требуется внести некоторые изменения в конфигурацию сборки модуля, то именно то место, где подобные изменения производятся. Вкратце рассмотрим основные секции файла.

Файл сборки начинается с объявления плагинов приложения Android и Kotlin:

```
plugins {
    alias(libs.plugins.androidApplication)
    alias(libs.plugins.jetbrainsKotlinAndroid)
}
```

Далее идет раздел android, который начинается с объявляения пространствоа имен проекта и версии SDK, которая будет использоваться при сборке модуля:

```
android {
    namespace = "com.example.helloapp"
    compileSdk = 34
}
```

Элементы, объявленные в подразделе defaultConfig, определяют элементы, которые будут созданы в файле AndroidManifest.xml модуля во время сборки:

```kotlin
defaultConfig {
    applicationId = "com.example.helloapp"
    minSdk = 24
    targetSdk = 34
    versionCode = 1
    versionName = "1.0"
 
    testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    vectorDrawables {
        useSupportLibrary = true
    }
}
```

Подраздел buildTypes указывает, следует ли и как запускать ProGuard в APK-файле при сборке релизной версии приложения:

```kotlin
buildTypes {
    release {
        isMinifyEnabled = false
        proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
    }
}
```

В текущей конфигурации ProGuard не будет запускаться при сборке модуля. Чтобы включить ProGuard, запись minifyEnabled должна быть изменена с false на true. А выражение proguardFiles() определяет применяемые файлы ProGuard. Файл proguard-rules.pro можно найти в каталоге модулей проекта. Изменения, внесенные в этот файл, переопределяют настройки по умолчанию в файле proguard-android.txt, который находится в каталоге установки Android SDK в папке "sdk/tools/proguard".

Поскольку в данном случае подраздел buildTypes не определяет конфигурацию для сборки в режиме отладки (режим debug), то при отладке будут использоваться значения по умолчанию (созданные без ProGuard, подписанные ключом отладки и включенными символами отладки).

Далее идет подразделы compileOptions и kotlinOptions которые определяют используемую при сборке проекта версию компилятора Java:

```kotlin
compileOptions {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
kotlinOptions {
    jvmTarget = "1.8"
}
```

И в самом конце идет секция dependencies перечисляет все локальные и удаленные зависимости, от которых зависит модуль. Строки зависимостей в приведенном выше файле примера обозначают библиотеки Android, которые необходимо включить из репозитория Android:

```kotlin
dependencies {
 
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    .....................................
}
```

## Каталог версий libs.versions.toml
Когда Gradle собирает проект, ему необходимо знать, какие библиотеки необходимы для завершения сборки и соответствующие номера их версий. И каталог версий - файле libs.versions.toml позволяет указать, какие версии каких библиотек будут использоваться в проекте. Этот файл имеет содержимое наподобие следующего:

```
[versions]
agp = "8.3.0"
kotlin = "1.9.0"
coreKtx = "1.10.1"
junit = "4.13.2"
junitVersion = "1.1.5"
espressoCore = "3.5.1"
lifecycleRuntimeKtx = "2.6.1"
activityCompose = "1.7.0"
composeBom = "2023.08.00"
 
[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
 
[plugins]
androidApplication = { id = "com.android.application", version.ref = "agp" }

jetbrainsKotlinAndroid = { id = 'org.jetbrains.kotlin.android', version.ref = 'kotlin' }

```


Данный файл подразделен на три секции: [versions], [libraries] [plugins]. Чтобы понять, как работает каталог, в качестве примера рассмотрим подключение библиотеки "androidx-core-ktx". Итак, в секции [libraries] библиотека "androidx-core-ktx" объявлена следующим образом:

```
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
```

Параметр versions.ref указывает, как на библиотеку будут ссылаться в секции [versions] - через имя "coreKtx".

В секции [versions] мы можем увидеть, что для этой библиотеки указана версия 1.10.1:

```
[versions]
coreKtx = "1.10.1"
```

Наконец, библиотека объявляется в секции dependencies файла Gradle уровня модуля:

```
dependencies {
 
    implementation(libs.androidx.core.ktx)
    .........................................
}
```

Обратите внимание, что синтаксис ссылки на библиотеку в файле Gradle заключается в добавлении к имени, используемому в записи каталога [libraries], префикса "libs".


# Добавление зависимостей

Как было сказано в прошлой теме, все зависимости, которые использует проект, должны быть указаны в секции dependencies файла сборки Gradle уровня модуля. Например, в проекте по умолчанию есть модуль app, для которого автоматически создается файл build.gradle.kts (Module :app). Соответственно все зависимости этого модуля добавляются в этот файл. Рассмотрим небольшой пример. Например, в приложении Jetpack Compose можно применять класс ViewModel, который является посредником между данными и пользовательским интерфейсом. И через ViewModel идет взаимодействие между данными и графическим интерфейсом. Но для полноценной работы с ViewModel необходимо добавить соответствующую зависимость. Чтобы было понятно, о чем речь, привиду минимальный код:

```kotlin
package com.example.testapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewmodel.compose.viewModel
 
class AppViewModel : ViewModel()
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val vm: AppViewModel = viewModel()
        }
    }
}
```

Здесь мы определяем класс AppViewModel. Затем создаем его переменную. Для создания переменной используется функция viewModel(). Она эта функция недоступна:

![](https://metanit.com/kotlin/jetpack/pics/20.4.png)

В проект по умолчанию уже подключается некоторый набор базовых зависимостей, но эти зависимости не содержат функцию viewModel(). И всплывающая подксказка говорит нам, что нам нужно добавить зависимость "androidx.lifecycle:lifecycle-viewmodel-compose". Есть два способа добавления зависимостей. Рассмотрим оба из них.

## Добавление зависимости напрямую в build.gradle.kts
Раньше зависимости добавлялись напрямую в файл build.gradle.kts уровня модуля в секцию dependecies. Так, откроем файл build.gradle.kts (Module :app)

![](https://metanit.com/kotlin/jetpack/pics/2.26.png)

В этом файле ближе к низу найдем секцию dependencies, которая хранит добавленные в проект зависимости и которая выглядит примерно следующим образом:

```
dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)
}
```

Внутрь этой секции, например, самое начало добавим строку

```
implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
```

То есть в итоге получится

```
dependencies {
 
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
 
    implementation(libs.androidx.core.ktx)
    // остальные зависимости
    ........................................
 
}
```

Для добавления библиотек может применяться вызов implementation, в который передается добавляемая зависимость в формате:

```
implementation("имя_библиотеки:версия_библиотеки")
```

То есть мы добавляем в качестве зависимости библиотеку "androidx.lifecycle:lifecycle-viewmodel-compose" версии 2.7.0. И чтобы изменения в файле Gradle были применены, нажмем на кнопку Sync Now

![](https://metanit.com/kotlin/jetpack/pics/15.2.png)

После этого мы сможем спокойно использовать функцию viewModel и другую функциональность подключенной библиотеки.

## Использование каталога версий
Хотя мы можем использовать способ, описанный выше, но в настоящее время также используется другой подход с управлением библиотеками и их версиями в каталог версий. Так, откроем файл каталога версий libs.versions.toml

![](https://metanit.com/kotlin/jetpack/pics/20.5.png)

Перейдем к секции [libraries] в этом файле. По умочланию он выглядит примерно следующим образом:

```
[libraries]
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
androidx-junit = { group = "androidx.test.ext", name = "junit", version.ref = "junitVersion" }
androidx-espresso-core = { group = "androidx.test.espresso", name = "espresso-core", version.ref = "espressoCore" }
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
androidx-activity-compose = { group = "androidx.activity", name = "activity-compose", version.ref = "activityCompose" }
androidx-compose-bom = { group = "androidx.compose", name = "compose-bom", version.ref = "composeBom" }
androidx-ui = { group = "androidx.compose.ui", name = "ui" }
androidx-ui-graphics = { group = "androidx.compose.ui", name = "ui-graphics" }
androidx-ui-tooling = { group = "androidx.compose.ui", name = "ui-tooling" }
androidx-ui-tooling-preview = { group = "androidx.compose.ui", name = "ui-tooling-preview" }
androidx-ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest" }
androidx-ui-test-junit4 = { group = "androidx.compose.ui", name = "ui-test-junit4" }
androidx-material3 = { group = "androidx.compose.material3", name = "material3" }
```

В эту секции (в конец или в начало) добавим строку

```
androidx-lifecycle-viewmodel-compose = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycleRuntimeKtx" }
```

Например, при добавлении в начало получится примерно так:

```
[libraries]
androidx-lifecycle-viewmodel-compose = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycleRuntimeKtx" }
 
androidx-core-ktx = { group = "androidx.core", name = "core-ktx", version.ref = "coreKtx" }
junit = { group = "junit", name = "junit", version.ref = "junit" }
```

Далее в файл build.gradle.kts (Module :app) в секцию dependencies добавим саму зависимость

```
dependencies {
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    ...................................
```
И для синхронизации проекта также нажмем на кнопку "Sync Now":

![](https://metanit.com/kotlin/jetpack/pics/20.6.png)

## Добавление зависимости с установкой версии
В предыдущем примере библиотека "androidx-lifecycle-viewmodel-compose" использовала ту же версию, что и библиотека "androidx-lifecycle-runtime-ktx" - они обе ссылались на одно и то же имя - "lifecycleRuntimeKtx", поскольку они используются вместе

```
[libraries]
androidx-lifecycle-viewmodel-compose = { module = "androidx.lifecycle:lifecycle-viewmodel-compose", version.ref = "lifecycleRuntimeKtx" }
................................
androidx-lifecycle-runtime-ktx = { group = "androidx.lifecycle", name = "lifecycle-runtime-ktx", version.ref = "lifecycleRuntimeKtx" }
```

И для этого имени в секции [versions] устанавливалась версия 2.7.0:

```
[versions]
.............................
lifecycleRuntimeKtx = "2.7.0" # версия библиотек
```

Для других библиотек можно указать свою версию. Например, возьмем библиотеку Room, которая используется для взаимодействия с базой данных. Для ее добавления в файле libs.versions.toml в секции [libraries] сначала укажем саму библиотеку:

```
[libraries]
............................
androidx-room-runtime = { module = "androidx.room:room-runtime", version.ref = "roomRuntime" }
```

Далее в секции [versions] укажем версию этой библиотеки:

```
[versions]
..................
roomRuntime = "2.6.1"
```
Наконец, в файле подключим эту зависимость:

```
dependencies {
    implementation(libs.androidx.room.runtime)
}
```
И для синхронизации конфигурации с проектом нажмем на кнопку "Sync Now"

## Обновление зависимостей
Если вдруг появится новая версия какой-то библиотеки, то мы увидим соответствующее уведомление в файле libs.versions.toml

![](https://metanit.com/kotlin/jetpack/pics/20.7.png)