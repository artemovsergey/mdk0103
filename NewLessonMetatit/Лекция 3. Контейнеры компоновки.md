# Лекция 3. Контейнеры компоновки

В Jetpack Compose за расположение и компоновку компонентов в приложении отвечает специальный компонент - Layout. Он имеет следующую сигнатуру:

```kotlin
@Composable inline fun Layout(
    content: @Composable () -> Unit,
    modifier: Modifier = Modifier,
    measurePolicy: MeasurePolicy
)
```

Он имеет следующие параметры:

- content: Composable-функция, которая хранит все вложенные компоненты
- modifier: объект Modifier, которые устанавливает функции-модификаторы, применяемые для стилизации компонента
- measurePolicy: объект, который отвечает за вычисление размеров компонентов и их определение их расположения

Создание своего алгоритма вычисления размеров компонентов внутри компонента-контейнера, должная компоновка вложенных компонентов представляют трудоемкую работу, поэтому фреймворк Compose предоставляет ряд встроенных компонентов-контейнеров, которые автоматически выполняют эту работу. Основными из них являются Box, Row и Column. Рассмотрим эти контейнеры.

## Box
Компонент Box является наиболее простым контейнером, позволяя позиционировать вложенное содержимое. Он представляет некоторую область экрана. Функция данного компонента принимает четыре параметра:

```kotlin
@Composable
inline fun Box(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    propagateMinConstraints: Boolean = false,
    content: @Composable BoxScope.() -> Unit
): @Composable Unit
```

- modifier: объект Modifier, который позволяет настроить внешний вид и поведение компонента с помощью модификаторов

- contentAlignment: объект Alignment, который устанавливает расположение компонента. По умолчанию имеет значение Alignment.TopStart (расположение вначале контейнера в верхнем углу)

- propagateMinConstraints: значение типа Boolean, который указывает, надо ли применять к содержимому ограничения по минимальным размерам. По умолчанию равно false (ограничения не применяются)

- content: объект интерфейса BoxScope, который представляет вложенное содержимое

## Modifier
Контейнер Box может использоваться как самодостаточный компонент без какого-либо вложенного содержимого:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
 
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box(
                modifier = Modifier.size(300.dp, 250.dp).background(Color.Blue)
            )
        }
    }
}
```

Для установки визуальных свойств объекта Box применяется свойство modifier, которое представляет объект Modifier, рассмотренный в прошлой главе. Как и для других компонентов, для компонента Box мы можем вызвать функцию size(), которая принимает ширину и длину контейнера - в данном случае ширина 300 единиц и высота 250 единиц.

```kotlin
Modifier.size(300.dp, 250.dp)
```

Эта функция опять же возвращает объект Modifier, у которого далее вызыватся другая функция - background(), которая устанавливает фоновый цвет контейнера - в данном случае синий цвет или значение Color.Blue

```kotlin
Modifier.size(300.dp, 250.dp).background(Color.Blue)
```

В итоге мы увидим на экране синюю прямоугольную область размером 300 x 250.

![](https://metanit.com/kotlin/jetpack/pics/2.3.png)

### Установка размеров Box
По умолчанию Box занимает те размеры на экране, которые необходимы, чтобы вместить содержимое. Но выше в Box никакого вложенного содержимого не было, поэтому чтобы установить размеры, применялся объект Modifier и его функция size()

```kotlin
Modifier.size(300.dp, 250.dp)
```
Если необходимо растянуть элемент по всей ширине и длине экрана, то, как и в общем случае, применяется функция - fillMaxSize():

```kotlin
Modifier.fillMaxSize().background(Color.Blue)
```

## Позиционирование внутри Box
Например, определим простейший элемент Box с вложенным элементом Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box {
                Text("Hello METANIT.COM", fontSize = 28.sp,)
            }
        }
    }
}
```

Здесь мы видим, что вложенный компонент Text позиционируется в левом верхнем углу контейнера Box.

![](https://metanit.com/kotlin/jetpack/pics/2.2.png)

Есть три причины подобного позиционирования

- Элемент Box сам по умолчанию располагается в верхнем левом углу устройства

- Для Box не задано размеров, он будет стремиться занять пространство, необходимое для вложенного содержимого.

- Если вложенное содержимое меньше размеров контейнера Box, то для его позиционирования внутри Box будет использоваться настройка contentAlignment. А по умолчанию применяет значение Alignment.TopStart (расположение вначале контейнера в верхнем углу)

### contentAlignment
Для позиционирования внутри Box данный компонент определяет параметр contentAlignment, которому передаются свойства объекта Alignment:

- Alignment.BottomCenter: внизу по центру
- Alignment.BottomEnd: внизу в конце
- Alignment.BottomStart: внизу в начале
- Alignment.Center: по центру по вертикали и горизонтали
- Alignment.CenterEnd: по центру про вертикали и в конце по горизонтали
- Alignment.CenterStart: по центру про вертикали и в начале по горизонтали
- Alignment.TopCenter: вверху по центру
- Alignment.TopEnd: вверху в конце
- Alignment.TopStart: вверху в начале

Здесь для определения расположения применяются такие слова как "начало" (Start) и "конец" (End). В зависимости от яхыка системы и системы письма - правосторонняя или левосторонняя начало и конец как может находиться справа, так и слева. Например, для подавляющего числа языков (в том числе русского) начало находится слева, а конец - справа.

Например, расположим вложенные элементы по центру:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box(
                contentAlignment = Alignment.Center,
                modifier = Modifier.fillMaxSize()
            ){
                Text("Hello METANIT.COM", fontSize = 28.sp,)
            }
        }
    }
}
```

Значение Alignment.Center указывает, что содержимое будет позиционироваться по центру как по горизонтали, так и по вертикали. А чтобы Box был растянут по всей площади экрана, применяется модификатор Modifier.fillMaxSize():

![](https://metanit.com/kotlin/jetpack/pics/2.4.png)

## Наложение компонентов
Если Box содержит несколько вложенных компонентов, то умолчанию они будут накладываться друг на друга в порядке следования (последний компонент располагается поверх предыдущих)

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center )
            {
                Box(modifier = Modifier.background(Color.DarkGray).size(320.dp))
                Box(modifier = Modifier.background(Color.LightGray).size(280.dp))
                Text("Hello METANIT.COM", fontSize = 28.sp, modifier =Modifier.padding(10.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.5.png)

## Выравнивание вложенных компонентов
В Box мы можем задать расположение не только для всех вложенных компонентов в целом, но и для каждого компонента по отдельности. При определении компонентов внутри Box на компонентах можно определить модификатор align, который принимает вышерассмотренный объект Alignment и позволяет настроить положение каждого отдельного компонентов внутри Box:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Box( modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center )
            {
                Text("TopStart", fontSize = 28.sp, modifier =Modifier.align(Alignment.TopStart))
                Text("TopEnd", fontSize = 28.sp, modifier =Modifier.align(Alignment.TopEnd))
                Text("Center", fontSize = 28.sp, modifier =Modifier.align(Alignment.Center))
                Text("BottomStart", fontSize = 28.sp, modifier =Modifier.align(Alignment.BottomStart))
                Text("BottomEnd", fontSize = 28.sp, modifier =Modifier.align(Alignment.BottomEnd))
            }
        }
    }
}

```

![](https://metanit.com/kotlin/jetpack/pics/2.14.png)


# Column

Контейнер Column позволяет выстроить вложенные компоненты в столбик. Функция Column принимает четыре параметра:

```kotlin
@Composable
inline fun Column(
    modifier: Modifier = Modifier,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    content: @Composable ColumnScope.() -> Unit
): @Composable Unit
```

- modifier: объект Modifier, который позволяет настроить внешний вид и поведение компонента

- verticalArrangement: объект Arrangement.Vertical, который устанавливает выравнивание компонента по вертикали. По умолчанию имеет значение Arrangement.Top (расположение в верху)

- horizontalAlignment: объект Alignment.Horizontal, который устанавливает выравнивание компонента по горизонтали. По умолчанию имеет значение Alignment.Start (расположение в начале - слева для языков с левосторонним письмом и справа для языков с правосторонним письмом)

- content: объект интерфейса BoxScope, который представляет вложенное содержимое

Так, изменим код MainActivity.kt следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Kotlin", fontSize = 28.sp)
                Text("Java", fontSize = 28.sp)
                Text("JavaScript", fontSize = 28.sp)
                Text("Python", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.1.png)

## Установка размеров Column
Если ни у одного вложенного компонента НЕ указан вес, Column занимает то пространство, которое необходимо, чтобы вместить вложенные компоненты. Если подобный размер контейера нежелателен, то можно задать конкретный размер с помощью модификатора Modifier.height:

```kotlin
Column(modifier = Modifier.height(550.dp))
```

С помощью модификатора Modifier.fillMaxHeight можно растянуть контейер по всей длине экрана.

```kotlin
Column(modifier = Modifier.fillMaxSize())
```

сли как минимум для одного вложенного компонента указан вес, то в модификаторе Modifier.fillMaxHeight нет смысла. Однако в этот случае по прежнему можно использовать модификаторы Modifier.height и Modifier.size для ограничения длины контейера.

### Позиционирование по вертикали и verticalArrangement

Если высота контейера Column больше суммы высот его вложенных компонентов, то для позиционирования этих компонентов может применяться параметр verticalArrangement, который может принимать следующие значения:
- Arrangement.Center: расположение по центру
- Arrangement.Bottom: расположение внизу
- Arrangement.Top: расположение вверху
- Arrangement.SpaceAround: компоненты равномерно распределяются по всей высоте с равномерными отступами между элементами, при этом отступы между первым и последним элементами и границами контейнера равен половине отступов между элементами
- Arrangement.SpaceBetween: компоненты равномерно распределяются по всей высоте с равномерными отступами между элементами, при этом первый и последний элементы прижимаются к границам контейнера
- Arrangement.SpaceEvenly: компоненты равномерно распределяются по всей высоте с равномерными отступами между элементами, при этом отступы между первым и последним элементами и границами контейнера равны отступам между элементами

![](https://metanit.com/kotlin/jetpack/pics/column_arrangement_visualization.gif)

Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(modifier = Modifier.fillMaxSize(), verticalArrangement = Arrangement.SpaceBetween )
            {
                Box(modifier = Modifier.background(Color.Red).fillMaxWidth().height(100.dp))
                Box(modifier = Modifier.background(Color.DarkGray).fillMaxWidth().height(100.dp))
                Box(modifier = Modifier.background(Color.Blue).fillMaxWidth().height(100.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.8.png)

### Выравнивание элементов по горизонтали

Параметр horizontalAlignment позволяет выровнить содержимое вложенных компонентов. Этому параметру можно передать одно из следующих значений:

- Alignment.Start: выравнивание в начале (по умолчанию)
- Alignment.End: выравнивание в конце
- Alignment.CenterHorizontally: выравнивание по центру

Начало и конец в зависимости от направления написания для текущего языка может означать левый или правый край. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(horizontalAlignment = Alignment.End, modifier = Modifier.fillMaxSize())
            {
                Text("Kotlin", fontSize = 28.sp)
                Text("Java", fontSize = 28.sp)
                Text("JavaScript", fontSize = 28.sp)
                Text("Python", fontSize = 28.sp)
            }
        }
    }
}
```

Здесь идет выравнивание по правому краю:

![](https://metanit.com/kotlin/jetpack/pics/2.15.png)

## Модификаторы ColumnScope
Поскольку вложенные компоненты в Row определяются внутри ColumnScope, то ColumnScope предоставляет вложенным компонентам еще ряд модификаторов:

- align(): определяет выравнивание компонента по вертикали и может принимать значения:
- Alignement.Start: выравнивание по началу контейнера (в зависимости от ориентации это правая или левая сторона)
- Alignement.CenterHorizontally: выравнивание по центру
- Alignement.End: выравнивание по концу контейнера (в зависимости от ориентации это правая или левая сторона)
- alignBy(): выравнивает компонент относительно определенной вертикальной линии
- weight(): задает вес компонента

Например, установка выравнивания по горизонтали отдельно для каждого компонента с помощью модификатора align:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column(modifier = Modifier.fillMaxSize())
            {
                Text("Start", fontSize = 28.sp, modifier = Modifier.align(Alignment.Start))
                Text("Center", fontSize = 28.sp, modifier = Modifier.align(Alignment.CenterHorizontally))
                Text("End", fontSize = 28.sp, modifier = Modifier.align(Alignment.End))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.19.png)

### Установка веса компонентов
Вес (weight) внутри Column позволяет назначить вложенным компонентам высоту в соответствии с некоторым коэффициентом. Для указания веса применяется модификатор ColumnScope.weight. Стоит учитывать, что если контейнер Column обеспечивает вертикальную прокрутку или располагается в контейере, который предполагает вертикальную прокрутку, то веса компонентов игнорируются, поскольку общее пространство по вертикали условно бесконечно.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Box(modifier = Modifier.background(Color.Red).fillMaxWidth().weight(1f))
                Box(modifier = Modifier.background(Color.DarkGray).fillMaxWidth().weight(3f))
                Box(modifier = Modifier.background(Color.Blue).fillMaxWidth().weight(2f))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.6.png)

Обратите внимание, как передается вес:

```kotlin
Modifier.background(Color.Red).fillMaxWidth().weight(1f)
```

В качестве веса в функцию weight() фактически передается доля пространства в единицах f. Так, первый элемент Box имеет вес 1f, второй - 3f, третий - 2f. Соовокупный вес всех комонентов, таким образом, будет 1f + 3f + 2f = 6f. И в итоге получится, что первый элемент получит от пространства 1f/6f часть или одну шестую. Второй элемент - 3f/6f или половину простанства, а третий - 2f/6f или одну третью пространства. Таким образом будет распределено пространство по вертикали между вложенными элементами.

Однако веса управляют только распределением пространства по вертикали, то есть для установки высоты. Ширина же устанавливается либо исходя из явно указанных значений ширины, либо исходя из вложенного содержимого. В данном случае по умолчанию вложенные элементы Box получат нулевую ширину, поэтому, чтобы их бло видно, в данном случае растягивает элементы по всей ширине с помощью модификатора fillMaxWidth().

Стоит отметить, что модификатор weight() может принимать второй параметр - булевое значение, которое указывает, будет ли ему выделяться пространство в соответствии с его весом. Если этот параметр равен false, то его вес не учитывается:

```kotlin
Box(modifier = Modifier.background(Color.Yellow).fillMaxWidth().weight(3f, fill=false))
```

### Сочетание весов и точных размеров

Если у компонента не указан вес, то контейер сначала запрашивает его предпочтительную высоту. Затем оставшее простанство распределяется между компонентами, для которых указан вес, в соответствии с их весом.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Box(modifier = Modifier.background(Color.Red).fillMaxWidth().weight(1f))
                Box(modifier = Modifier.background(Color.DarkGray).fillMaxWidth().height(150.dp))
                Box(modifier = Modifier.background(Color.Blue).fillMaxWidth().weight(2f))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.7.png)

Здесь для второго элемента Box установлена высота в 150 единиц, а для остальных установлены веса - 1f и 2f. Таким образом, получится, что от всей длины контейера Column (а он будет растягиваться на весь экран) второй элемент получит высоту в 150 единиц. Оставшееся пространство затем будет распределено между первым и третим элементами в соответствии с их весами.



# Row

Контейнер Row располагает вложенные компоненты в строку. Функция Row принимает четыре параметра:

```kotlin
@Composable
inline fun Row(
    modifier: Modifier = Modifier,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
    verticalAlignment: Alignment.Vertical = Alignment.Top,
    content: @Composable RowScope.() -> Unit
): @Composable Unit
```

- modifier: объект Modifier, который позволяет настроить внешний вид и поведение компонента
- horizontalArrangement: объект Arrangement.Horizontal, который устанавливает выравнивание компонента по горизонтали. По умолчанию имеет значение Arrangement.Start (расположение в вначале: слева для левосторонних языков и справа для правосторонних языков)
- verticalAlignment: объект Alignment.Vertical, который устанавливает выравнивание компонента по вертикали. По умолчанию имеет значение Alignment.Top (расположение вверху)
- content: объект интерфейса RowScope, который представляет вложенное содержимое

Разместим в Row несколько элементов Box:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row {
                Box(modifier = Modifier.background(Color.Red).height(150.dp).width(100.dp))
                Box(modifier = Modifier.background(Color.DarkGray).height(150.dp).width(100.dp))
                Box(modifier = Modifier.background(Color.Blue).height(150.dp).width(100.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.9.png)

Установка размеров Row
Если ни у одного вложенного компонента НЕ указан вес, Row занимает то пространство, которое необходимо, чтобы вместить вложенные компоненты. Если подобный размер контейера не желателен, то можно задать конкретный размер с помощью модификатора Modifier.width:

```kotlin
Row(modifier = Modifier.width(350.dp))
```
С помощью модификатора Modifier.fillMaxWidth можно растянуть контейер по всей длине экрана.

```kotlin
Row(modifier = Modifier.fillMaxWidth())
```

Если как минимум для одного вложенного компонента указан вес, то в модификаторе Modifier.fillMaxWidth нет смысла. Однако в этот случае по прежнему можно использовать модификаторы Modifier.width и Modifier.size для ограничения ширины контейера.

### Позиционирование по горизонтали и horizontalArrangement

Если ширина контейера Row больше суммы ширин его вложенных компонентов, то для позиционирования этих компонентов по горизонтали может применяться параметр horizontalArrangement, который может принимать следующие значения:

- Arrangement.Center: расположение по центру

- Arrangement.End: расположение в конце (справа - для левосторонних языков, слева - для правосторонних языков)

- Arrangement.Start: расположение в начале (слева - для левосторонних языков, справа - для правосторонних языков)

- Arrangement.SpaceAround: компоненты равномерно распределяются по всей ширине с равномерными отступами между элементами, при этом отступы между первым и последним элементами и границами контейнера равен половине отступов между элементами

- Arrangement.SpaceBetween: компоненты равномерно распределяются по всей ширине с равномерными отступами между элементами, при этом первый и последний элементы прижимаются к границам контейнера

- Arrangement.SpaceEvenly: компоненты равномерно распределяются по всей ширине с равномерными отступами между элементами, при этом отступы между первым и последним элементами и границами контейнера равны отступам между элементами

![](https://metanit.com/kotlin/jetpack/pics/row_arrangement_visualization.gif)

Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly)
            {
                Box(modifier = Modifier.background(Color.Red).height(150.dp).width(100.dp))
                Box(modifier = Modifier.background(Color.DarkGray).height(150.dp).width(100.dp))
                Box(modifier = Modifier.background(Color.Blue).height(150.dp).width(100.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.12.png)

Выравнивание по вертикали
Параметр verticalAlignment в Row позволяет установить выравнивание по вертикали для вложенных компонентов и принимает объект интерфейса Alignment.Vertical. В частности, мы можем использовать одно из следующих значений:

- Top: выравнивание по верху
- CenterVertically: выравнивание по центру
- Bottom: выравнивание по нижнему краию контейнера

Например, применим выравнивание по центру строки:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row(modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.SpaceEvenly,
                verticalAlignment = Alignment.CenterVertically)
            {
                Text("Kotlin", fontSize = 28.sp)
                Text("JavaScript", fontSize = 28.sp)
                Text("Python", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.16.png)

## Модификаторы RowScope
Поскольку вложенные компоненты в Row определяются внутри RowScope, то RowScope предоставляет вложенным компонентам еще ряд модификаторов:

- align(): определяет выравнивание компонента по вертикали и может принимать значения:

- Alignement.Top: выравнивание по верху контейнера
- Alignement.CenterVertically: выравнивание по центру
- Alignement.Bottom: выравнивание по нижней стороне контейнера

- alignBy(): выравнивает компонент относительно определенной горизонтальной линии

- alignByBaseline(): выравнивает базовую линию компонента относительно базовой линии другого сестринского компонента, применяется для выравнивания текста компонентов по одной линии

- paddingFrom(): добавляет отступ при выравнивании

- weight(): задает вес компонента

Например, установка вертикального выравнивания для каждого компонента по отдельности с помощью модификатора align:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row(modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.SpaceEvenly)
            {
                Text("Top", fontSize = 28.sp, modifier = Modifier.align(Alignment.Top))
                Text("CenterVertically", fontSize = 28.sp, modifier = Modifier.align(Alignment.CenterVertically))
                Text("Bottom", fontSize = 28.sp, modifier = Modifier.align(Alignment.Bottom))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.17.png)

## Установка веса компонентов

Вес (weight) позволяет назначить вложенным компонентам ширину в соответствии с некоторым коэффициентом. Для указания веса применяется модификатор RowScope.weight. Стоит учитывать, что если контейнер Row обеспечивает горизонтальную прокрутку или располагается в контейере, который предполагает горизонтальную прокрутку, то веса компонентов игнорируются, поскольку общее пространство по горизонтали условно бесконечно.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.height
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row{
                Box(modifier = Modifier.background(Color.Red).height(150.dp).weight(1f))
                Box(modifier = Modifier.background(Color.DarkGray).height(150.dp).weight(3f))
                Box(modifier = Modifier.background(Color.Blue).height(150.dp).weight(2f))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.10.png)

Обратите внимание, как передается вес:

```kotlin
Box(modifier = Modifier.background(Color.Red).height(150.dp).weight(1f))
```

В качестве веса в функцию weight() фактически передается доля пространства в единицах f. Так, первый элемент Box имеет вес 1f, второй - 3f, третий - 2f. Соовокупный вес всех комонентов, таким образом, будет 1f + 3f + 2f = 6f. И в итоге получится, что первый элемент получит от пространства 1f/6f часть или одну шестую. Второй элемент - 3f/6f или половину простанства, а третий - 2f/6f или одну третью пространства по горизонтали. Таким образом будет распределено пространство по горизонтали между вложенными элементами.

## Сочетание весов и точных размеров

Если у компонента не указан вес, то контейнер сначала запрашивает его предпочтительную ширину. Затем оставшее простанство распределяется между компонентами, для которых указан вес, в соответствии с их весом.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Row{
                Box(modifier = Modifier.background(Color.Red).height(150.dp).weight(1f))
                Box(modifier = Modifier.background(Color.DarkGray).height(150.dp).width(150.dp))
                Box(modifier = Modifier.background(Color.Blue).height(150.dp).weight(2f))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.11.png)

Здесь для второго элемента Box установлена ширина в 150 единиц, а для остальных установлены веса - 1f и 2f. Таким образом, получится, что от всей ширины контейера Row (а он будет растягиваться на весь экран) второй элемент получит ширину в 150 единиц. Оставшееся пространство затем будет распределено между первым и третим элементами в соответствии с их весами.







# Композиции контейнеров

Используя различные типы контейнеров, можно создавать более сложные композиции компоновок. Например, возьмем приложение со следующим кодом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin",0xff16a085),
                Language("Java",0xff2980b9),
                Language("JavaScript",0xffe74c3c),
                Language("Python", 0xffd35400))
            Column{
                for(lang in langs){
                    Row(modifier = Modifier.padding(10.dp).fillMaxWidth()){
                        Box(modifier=Modifier.size(50.dp).background(Color(lang.hexColor)))
                        Text(text = lang.name, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                    }
                }
            }
        }
    }
}
data class Language(val name: String, val hexColor:Long)
```

В данном случае приложение выводит список некоторых данных. Для представления данных применяется data-класс Language, который определяет два свойства - name (название языка программирования) и hexColor (цвет в шестнадцатеричном формате).

Для создания компоновки для вывода списка объектов Language применяется сразу три основных типа контейнров - Column, Row и Box. В Column с помощью цикла проходим по всем элементам в списке langs и для каждого из них создаем строку Row.

```kotlin
Column{
    for(lang in langs){
        Row( .....................
    }
}
```

Каждую строку растягиваем по ширине окна и делаем отступы от границ контейнера в 10 пикселей. Внутри каждой строки используем компонент Box для отрисовки цвета, который берем из свойства hexColor, и компонент Text для вывода названия языка:

```kotlin
Row(modifier = Modifier.padding(10.dp).fillMaxWidth()){
    Box(modifier=Modifier.size(50.dp).background(Color(lang.hexColor)))
    Text(text = lang.name, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
}
```

Таким образом, у нас получается простейший список.

![](https://metanit.com/kotlin/jetpack/pics/2.18.png)



# Surface

Компонент Surface является ключевым компонентом компоновки в Material Design, предоставляя для вложенного содердимого множество стилизаций по умолчанию. Он имеет несколько версий. Возьмем простейшую из них:

```kotlin
@Composable
@NonRestartableComposable
fun Surface(
    modifier: Modifier = Modifier,
    shape: Shape = RectangleShape,
    color: Color = MaterialTheme.colorScheme.surface,
    contentColor: Color = contentColorFor(color),
    tonalElevation: Dp = 0.dp,
    shadowElevation: Dp = 0.dp,
    border: BorderStroke? = null,
    content: @Composable () -> Unit
): Unit
```

Данная версия функции компонента принимает следующие параметры:

- modifier: применяемые к контейнеру функции модификатора
- shape: форма компонента в виде объекта Shape
- color: фоновый цвет
- contentColor: предпочитаемый цвет содержимого
- tonalElevation: эффект анимации при нажатии
- shadowElevation: высота тени
- border: параметры границы в виде объекта BorderStroke

Например, простейший Surface:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Surface(
                Modifier.fillMaxSize(),
                contentColor = Color.LightGray,
                color = Color.DarkGray
            ){
                Text("Hello METANIT.COM", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.75.png)

В данном случае мы видим, что текст в качестве цвета использовал настройки Surface.

При этом Surface может одновременно содержать только один компонент, поэтому при использовании множества компонентов, их следует оборачивать в другой контейнер типа Box, Row или Column:



```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Python")
            Surface(
                Modifier.fillMaxSize(),
                contentColor = Color.LightGray,
                color = Color.DarkGray
            ){
                Column {
                    Text("Языки программирования", fontSize = 28.sp)
                    for(lang in langs){
                        Text(lang, fontSize = 22.sp)
                    }
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.76.png)


# Списки LazyColumn и LazyRow

Если необходимо отобразить большое количество элементов (или список неизвестной длины), использование стандартных контейнеров как Column или Row может вызвать проблемы с производительностью, так как все вложенные элементы будут скомпонованы внутри контейнера независимо от того, видимы они или нет. Для более эффективной работы со вложенными компонентами Jetpack Compose предоставляет такие компоненты-контейнеры как LazyColumn и LazyRow. Они компонуют и добавляют только те элементы, которые видны в окне просмотра компонента. При прокрутке в контейнер компонуются новые элементы, а старые удаляются. При обратной прокрутке происходит повторная компоновка старых элементов. Собственно название контейнеров уже говорит о том, что они производят так называюмую lazy-загрузку (или ленивую загрузку), когда элементы загружаются не сразу, а по мере необходимости.

### LazyColumn

LazyColumn создает список с вертикальной прокруткой, а LazyRow создает список с горизонтальной прокруткой и имеет следующие параметры:

```kotlin
@Composable
fun LazyColumn(
    modifier: Modifier = Modifier,
    state: LazyListState = rememberLazyListState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,
    horizontalAlignment: Alignment.Horizontal = Alignment.Start,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyListScope.() -> Unit
): Unit
```

- modifier: применяемые к контейнеру модификаторы
- state: объект состояния LazyListState, применяемый для управления состоянием контейнера
- contentPadding: отступы вокруг содержимого
- reverseLayout: при значении true располагает элементы в обратном порядке
- verticalArrangement: настройки расположения элементов по вертикали
- horizontalAlignment: выравнивание элементов по горизонтали
- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец. Представляет объект FlingBehavior
- userScrollEnabled: указывает, доступна ли прокрутка жестами либо через специальные инструменты управления доступом
- content: устанавливает содержимое контейнера с помощью функции типа LazyListScope.() -> Unit.

Одно из отличий lazy-контейнеров, в частности, LazyColumn от других контейнеров, например, от Column состоит в принципе установки содержимого. За это отвечает функция типа LazyListScope.() -> Unit. Внутри блока этой функции можно использовать специальные методы для добавления других компонентов:

- LazyListScope.item(): для добавления одного элемента
- LazyListScope.items(): для добавления нескольких элементов
- LazyListScope.itemsIndexed(): для добавления нескольких элементов с использованием индексов

Например, применение функции LazyListScope.item() для добавление в LazyColumn одного элемента:

```kotlin
LazyColumn( Modifier.fillMaxSize()){
    item { Text("Hello METANIT.COM", fontSize = 28.sp) }
}
```

В данном случае добавляется компонент Text.

Функция LazyListScope.items() принимает список значений для каждого из которых создается элемент в LazyColumn:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
 
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Python", "C#", "C++", "Rust")
            LazyColumn(
                Modifier.fillMaxSize()
            ){
                items(langs){lang -> Text(lang, fontSize = 24.sp)}
            }
        }
    }
}
```
Здесь для создания содержимого в LazyColumn применяется список langs. Функция items принимает этот список в качестве параметра и для каждого его элемента вызывает функцию @Composable() (LazyItemScope.(item: T) -> Unit). Здесь в качестве такой функции выступает функция {lang -> Text(lang, fontSize = 24.sp)}, которая для каждого элемента списка создает компонент Text

![](https://metanit.com/kotlin/jetpack/pics/4.77.png)

Причем для создания элементов можно сочетать сразу несколько функций item()/items():

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Python", "C#", "C++", "Rust")
            LazyColumn(
                Modifier.fillMaxSize()
            ){
                item { Text("Языки программирования", fontSize = 29.sp) }
                items(langs){lang -> Text(lang, fontSize = 24.sp)}
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.78.png)

Еще одна функция itemsIndexed() аналогично items() принимает список/массив элементов, но при переборе позволяет получить их индекс. Например, применим индекс для определения фонового цвета компонента:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf("Kotlin", "Java", "JavaScript", "Python", "C#", "C++", "Rust")
            LazyColumn(
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(5.dp)
            ){
                item { Text("Языки программирования", fontSize = 29.sp) }
                itemsIndexed(langs){index,lang -> Text(lang, fontSize = 23.sp,
                    modifier=Modifier.background(
                        if(index%2==0) Color(0xffdddddd) else Color.Transparent
                    ).padding(8.dp).fillMaxWidth())}
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.79.png)

### LazyRow

Контейнер LazyRow создает список с горизонтальной прокруткой. Он имеет следующие параметры:

```kotlin
@Composable
fun LazyRow(
    modifier: Modifier = Modifier,
    state: LazyListState = rememberLazyListState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    horizontalArrangement: Arrangement.Horizontal = if (!reverseLayout) Arrangement.Start else Arrangement.End,
    verticalAlignment: Alignment.Vertical = Alignment.Top,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyListScope.() -> Unit
): Unit
```

- modifier: применяемые к контейнеру модификаторы

- state: объект состояния LazyListState, применяемый для управления состоянием контейнера

- contentPadding: отступы вокруг содержимого

- reverseLayout: при значении true располагает элементы в обратном порядке

- horizontalArrangement: настройки расположения элементов по горизонтали

- verticalAlignment: выравнивание элементов по вертикали

- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец. Представляет объект FlingBehavior

- userScrollEnabled: указывает, доступна ли прокрутка жестами либо через специальные инструменты управления доступом

- content: устанавливает содержимое контейнера с помощью функции типа LazyListScope.() -> Unit.

В целом LazyRow похож на LazyColumn, таким же образом устанавливает элементы, только располагает их по горизонтали. Например, простейший горизонтальный список:

```kotlin
val langs = listOf("Kotlin", "Java", "JavaScript", "Python")
LazyRow {
    items(langs) {lang -> Text(lang)}
}
```

Также это может быть более сложное содержимое:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xffd35400),
                Language("Python", 0xff2c3e50))
            LazyRow{
                items(langs) {lang ->
                    Column(Modifier.padding(8.dp), horizontalAlignment = Alignment.CenterHorizontally){
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 24.sp,modifier= Modifier.padding(8.dp))
                    }
                }
            }
        }
    }
}
 
data class Language(val name:String, val hexColor: Long)
```

![](https://metanit.com/kotlin/jetpack/pics/4.80.png)

















# Грид

Компоненты LazyVerticalGrid и LazyHorizontalGrid обеспечивают отображение элементов в виде сетки. Эти компоненты похожи на списки LazyColumn/LazyRow, только для описания содержимого применяют интерфейс LazyGridScope

LazyHorizontalGrid
LazyHorizontalGrid отображает элементы в горизонтально прокручиваемом контейнере, распределенном по нескольким строкам, и имеет следующие параметры:

```kotlin
@Composable
fun LazyHorizontalGrid(
    rows: GridCells,
    modifier: Modifier = Modifier,
    state: LazyGridState = rememberLazyGridState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    horizontalArrangement: Arrangement.Horizontal = if (!reverseLayout) Arrangement.Start else Arrangement.End,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyGridScope.() -> Unit
): Unit
```

- rows: представляет тип GridCells, который описывает количество и размер строк

- modifier: применяемые к контейнеру модификаторы

- state: объект состояния LazyGridState, применяемый для управления состоянием контейнера

- contentPadding: отступы вокруг содержимого

- reverseLayout: при значении true располагает элементы в обратном порядке

- verticalArrangement: настройки расположения элементов по горизонтали

- horizontalArrangement: выравнивание элементов по вертикали

- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец. Представляет объект FlingBehavior

- userScrollEnabled: указывает, доступна ли прокрутка жестами либо через специальные инструменты управления доступом

- content: устанавливает содержимое контейнера с помощью функции типа LazyGridScope.() -> Unit.

Для установки содержимого интерфейс LazyGridScope предоставляет несколько функций:

- LazyListScope.item(): для добавления одного элемента

- LazyListScope.items(): для добавления нескольких элементов

- LazyListScope.itemsIndexed(): для добавления нескольких элементов с использованием индексов

Для определения количества и размера ячеек применяется интерфейс GridCells. В частности, он предоставляет следующие методы:

- GridCells.Adaptive: определяет сетку с максимально возможным количеством строк или столбцов при условии, что каждая ячейка имеет как минимум пространство minSize и все дополнительное пространство распределено равномерно.

- GridCells.Исправлено: определяет сетку с фиксированным количеством строк или столбцов.

- GridCells.FixedSize: определяет сетку с максимально возможным количеством строк или столбцов при условии, что каждая ячейка занимает ровное пространство.

Например, определим простейший грид из текстовых элементов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyHorizontalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val itemsList = (0..12).toList()
            LazyHorizontalGrid(
                rows = GridCells.Fixed(3),
                modifier = Modifier.fillMaxSize()
            ){
                items(itemsList) {item ->
                    Text("Item $item", fontSize = 28.sp,modifier= Modifier.padding(8.dp))
                }
            }
        }
    }
}
```

В данном случае для создания грида применяется список itemsList из 13 элементов. С помощью параметра

```kotlin
rows = GridCells.Fixed(3)
```

определяем три строки. Для заполнения этих строк вызывается функция items()

```kotlin
items(itemsList) {item ->
    Text("Item $item", fontSize = 28.sp,modifier= Modifier.padding(8.dp))
}
```

Таким образом, все элементы будут последовательно располагаться в первом столбце, когда последняя строка будет заполнена, создается новый столбец и т.д.

![](https://metanit.com/kotlin/jetpack/pics/4.81.png)

Данный могут более сложными по композиции, и соответственно для их отображения могут использоваться более сложные композиции компонентов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.ui.Alignment
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyHorizontalGrid
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
            LazyHorizontalGrid(
                rows = GridCells.Fixed(2),
                modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.Center
            ){
                items(langs) {lang ->
                    Column(Modifier.padding(8.dp).size(125.dp), horizontalAlignment = Alignment.CenterHorizontally){
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 24.sp,modifier= Modifier.padding(5.dp))
                    }
                }
            }
        }
    }
}
 
data class Language(val name:String, val hexColor: Long)
```

Здесь для представления данных применяется класс Language, который хранит название языка программирования и связанный с ним цвет. А список langs хранит набор объектов Language. Для вывода этого списка в грид создается компонент LazyHorizontalGrid с 2-мя столбцами. Внутри каждой ячейки отображаем Box, закрашенный в определенный цвет, и текст с названием языка.

![](https://metanit.com/kotlin/jetpack/pics/4.82.png)

Обратите внимание, что два элемента не поместились на экране смартфона, и для их просмотра надо использовать горизонтальную прокрутку.

### LazyVerticalGrid
LazyVerticalGrid отображает элементы в вертикально прокручиваемом контейнере, распределенном по нескольким столбцам, и имеет следующие параметры:

```kotlin
@Composable
fun LazyVerticalGrid(
    columns: GridCells,
    modifier: Modifier = Modifier,
    state: LazyGridState = rememberLazyGridState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalArrangement: Arrangement.Vertical = if (!reverseLayout) Arrangement.Top else Arrangement.Bottom,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyGridScope.() -> Unit
): Unit
```

- columns: представляет объект GridCells, который описывает количество и размер столбцов

- modifier: применяемые к контейнеру модификаторы

- state: объект состояния LazyGridState, применяемый для управления состоянием контейнера

- contentPadding: отступы вокруг содержимого

- reverseLayout: при значении true располагает элементы в обратном порядке

- verticalArrangement: настройки расположения элементов по вертикали

- horizontalArrangement: выравнивание элементов по горизонтали

- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец. Представляет объект FlingBehavior

- userScrollEnabled: указывает, доступна ли прокрутка жестами либо через специальные инструменты управления доступом

- content: устанавливает содержимое контейнера с помощью функции типа LazyGridScope.() -> Unit.

LazyVerticalGrid во многом аналогичен LazyHorizontalGrid. Так, перепишем предыдущий пример с использованием LazyVerticalGrid:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.ui.Alignment
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
            LazyVerticalGrid(
                columns = GridCells.Fixed(2),
                modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.Center
            ){
                items(langs) {lang ->
                    Column(Modifier.padding(8.dp), horizontalAlignment = Alignment.CenterHorizontally){
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 24.sp,modifier= Modifier.padding(5.dp))
                    }
                }
            }
        }
    }
}
 
 
data class Language(val name:String, val hexColor: Long)
```

![](https://metanit.com/kotlin/jetpack/pics/4.83.png)

Здесь практически то же самое, только в LazyVerticalGrid вместо строк здесь задаем 2 столбца. Соответственно сначала элементы заполняются 2 стобца первой строки. Если после этого еще есть элементы, то создается вторая строка и так далее. А чтобы просмотреть те элементы, которые не поместились на экране, надо использовать вертикальную прокрутку.

## Адаптивные размеры
В примерах выше применялось точное количество строк/столбцов. Для этого использовался метод GridCells.Fixed(), в который передавалось количество строк/столбцов. Теперь рассмотрим другие возможности установки размеров. Так, метод GridCells.Adaptive(). Он определяет сетку с максимально возможным количеством строк или столбцов при условии, что каждая ячейка имеет как минимум размер minSize и все дополнительное пространство распределено равномерно. Значение minSize, которе указывает на минимаьную высоту строки или минимальную ширину столбца, передается в метод GridCells.Adaptive() в качестве единственного параметра. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.ui.Alignment
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.material3.Text
 
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
            LazyVerticalGrid(
                columns = GridCells.Adaptive(minSize=120.dp),
                modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.Center
            ){
                items(langs) {lang ->
                    Column(Modifier.padding(7.dp), horizontalAlignment = Alignment.CenterHorizontally){
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 24.sp)
                    }
                }
            }
        }
    }
}
 
data class Language(val name:String, val hexColor: Long)
```
В данном случае создается вертикальный грид, в котором минимальная ширина каждой ячейки равна 120 пикселей:

```kotlin
columns = GridCells.Adaptive(minSize=120.dp)
```

Минимальную ширину в данном случае я определил на основе содержимого ячейки. В итоге при вертикальной ориентации на моем устройстве будет создано 3 столбца

![](https://metanit.com/kotlin/jetpack/pics/4.84.png)

Тогда как при горизонтальной ориентации будет создаваться аж 5 столбцов

![](https://metanit.com/kotlin/jetpack/pics/4.85.png)

Данный подход может показать лучше, чем установка фиксированного количества строк/столбцов, поскольку экранное пространство устройства расходуется более экономично.

## Установка точных размеров
Еще один метод GridCells.FixedSize() позволяет задать точный размер ячейки (ширину столбцов или высоту строк). В этом случае создается максимально возможное количество строк или столбцов при условии, что каждая ячейка имеет указанный размер. Значение размера передается в метод GridCells.FixedSize() в качестве единственного параметра. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.ui.Alignment
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.material3.Text
 
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
            LazyVerticalGrid(
                columns = GridCells.FixedSize(size=140.dp),
                modifier = Modifier.fillMaxSize(),
                horizontalArrangement = Arrangement.Center
            ){
                items(langs) {lang ->
                    Column(Modifier.padding(7.dp), horizontalAlignment = Alignment.CenterHorizontally){
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 24.sp)
                    }
                }
            }
        }
    }
}
 
data class Language(val name:String, val hexColor: Long)
```

В данном случае создается вертикальный грид, в котором ширина каждой ячейки должна быть равна 140 пикселей:

```kotlin
columns = GridCells.FixedSize(size=140.dp)
```

В итоге при вертикальной ориентации на моем устройстве будет создано 2 столбца

![](https://metanit.com/kotlin/jetpack/pics/4.86.png)

Тогда как при горизонтальной ориентации будет создаваться 4 столбца

![](https://metanit.com/kotlin/jetpack/pics/4.87.png)




# LazyVerticalStaggeredGrid и LazyHorizontalStaggeredGrid


В прошлой статье были рассмотрены гриды - компоненты LazyVerticaldGrid и LazyHorizontalGrid, которые позволяют табличные представления со строками и столбцами. Но эти компоненты имеют недостаток - все ячейки этих гридов имеют одинаковый размер (в рамках одной строки или столбца). И для решения этой проблемы были предложены новые типы компонентов - LazyVerticalStaggeredGrid и LazyHorizontalStaggeredGrid

LazyVerticalStaggeredGrid
Компонент LazyVerticalStaggeredGrid представляет вертикальную сетку. Как и другие lazy-контейнеры, этот компонент компонует и размещает только элементы, которые видимые в данный момент на экране. Он имеет следующие параметры:

```kotlin
@Composable
fun LazyVerticalStaggeredGrid(
    columns: StaggeredGridCells,
    modifier: Modifier = Modifier,
    state: LazyStaggeredGridState = rememberLazyStaggeredGridState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalItemSpacing: Dp = 0.dp,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.spacedBy(0.dp),
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyStaggeredGridScope.() -> Unit
): Unit
```

- columns: представляет размер и количество столбцов в виде объекта StaggeredGridCells

- modifier: применяемые к компоненту модификаторы

- state: состояние в виде объекта LazyStaggeredGridState. Для его создания применяется функция rememberLazyStaggeredGridState()

- contentPadding: отступы вокруг контента

- reverseLayout: указывает, будут ли элементы грида располагаться в обратном порядке

- horizontalArrangement: определяет расположение элементов по горизонтали

- verticalItemSpacing: вертикальные отступы между элементами

- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец.

- userScrollEnabled: указывает, будет ли доступна прокрутка

- content: представляет функцию типа LazyStaggeredGridScope.() -> Unit, которая задает вложенные компоненты. Для добавления элементов в грид можно использовать функции LazyStaggeredGridScope.items() (для списка объектов) или LazyStaggeredGridScope.item() (для одного элемента)

Рассмотрим на примере. Возьмем следующее приложение:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.lazy.staggeredgrid.LazyVerticalStaggeredGrid
import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import kotlin.random.Random
 
class MainActivity : ComponentActivity() {
 
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            LazyVerticalStaggeredGrid(
                columns = StaggeredGridCells.Fixed(3),  // 3 столбца
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(8.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp),
                verticalItemSpacing = 8.dp
            ){
                items(50) {_ ->
                    Box(Modifier
                        .fillMaxWidth()
                        .height(Random.nextInt(50, 200).dp)
                        .background(Color(
                            Random.nextInt(255),
                            Random.nextInt(255),
                            Random.nextInt(255),
                            255
                        ))
                    )
                }
            }
        }
    }
}
```

Для LazyVerticalStaggeredGrid устанавливаем три столбца:

```kotlin
columns = StaggeredGridCells.Fixed(3)
```

Расстояние от границ контейнера до содержимого будет составлять 8 пикселей:

```kotlin
contentPadding = PaddingValues(8.dp)
```

Расстояние между столбцами по горизонтали будет также составлять 8 пикселей:

```kotlin
horizontalArrangement = Arrangement.spacedBy(8.dp)
```

И также 8 пикселей будет составлять вертикальные расстояния между элементами в столбце:

```kotlin
verticalItemSpacing = 8.dp
```

Для создания вложенных элементов здесь применяется функция LazyStaggeredGridScope.items(). Ей передается количество создаваемых элементов - в данном случае 50. Причем каждый элемент представляет компонент Box:

```kotlin
items(50) {_ ->
    Box(Modifier
        .fillMaxWidth()
        .height(Random.nextInt(50, 200).dp)
        .background(Color(
            Random.nextInt(255),
            Random.nextInt(255),
            Random.nextInt(255),
            255
        ))
    )
}
```
Для показательности высота и цвет компонентов Box устанавливается на основе случайных чисел. В итоге мы получим зубчатое расположение элементов наподобие следующего:

![](https://metanit.com/kotlin/jetpack/pics/2.49.png)


## LazyHorizontalStaggeredGrid
Компонент LazyHorizontalStaggeredGrid представляет горизонтальную сетку. Как и другие lazy-контейнеры, этот компонент компонует и размещает только элементы, которые видимые в данный момент на экране. Он имеет следующие параметры:

```kotlin
@Composable
fun LazyHorizontalStaggeredGrid(
    rows: StaggeredGridCells,
    modifier: Modifier = Modifier,
    state: LazyStaggeredGridState = rememberLazyStaggeredGridState(),
    contentPadding: PaddingValues = PaddingValues(0.dp),
    reverseLayout: Boolean = false,
    verticalArrangement: Arrangement.Vertical = Arrangement.spacedBy(0.dp),
    horizontalItemSpacing: Dp = 0.dp,
    flingBehavior: FlingBehavior = ScrollableDefaults.flingBehavior(),
    userScrollEnabled: Boolean = true,
    content: LazyStaggeredGridScope.() -> Unit
): Unit
```

- rows: представляет размер и количество строк в виде объекта StaggeredGridCells
- modifier: применяемые к компоненту модификаторы
- state: состояние в виде объекта LazyStaggeredGridState. Для его создания применяется функция rememberLazyStaggeredGridState()
contentPadding: отступы вокруг контента
- reverseLayout: указывает, будут ли элементы грида располагаться в обратном порядке
- verticalArrangement: определяет расположение элементов по вертикали
- horizontalItemSpacing: горизонтальные отступы между элементами
- flingBehavior: описывает поведение при таком типе прокрутки, когда пользователь быстро перетаскивает что-то и поднимает палец.
- userScrollEnabled: указывает, будет ли доступна прокрутка
- content: представляет функцию типа LazyStaggeredGridScope.() -> Unit, которая задает вложенные компоненты. Для добавления элементов в грид можно использовать функции LazyStaggeredGridScope.items() (для списка объектов) или LazyStaggeredGridScope.item() (для одного элемента)

Изменим предыдущий пример, использовав LazyHorizontalStaggeredGrid:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.staggeredgrid.LazyHorizontalStaggeredGrid
import androidx.compose.foundation.lazy.staggeredgrid.StaggeredGridCells
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import kotlin.random.Random
 
class MainActivity : ComponentActivity() {
 
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            LazyHorizontalStaggeredGrid(
                rows = StaggeredGridCells.Fixed(3),
                modifier = Modifier.fillMaxSize(),
                contentPadding = PaddingValues(8.dp),
                horizontalItemSpacing = 8.dp,
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ){
                items(50) {_ ->
                    Box(Modifier
                        .fillMaxHeight()
                        .width(Random.nextInt(50, 200).dp)
                        .background(Color(
                            Random.nextInt(255),
                            Random.nextInt(255),
                            Random.nextInt(255),
                            255
                        ))
                    )
                }
            }
        }
    }
}
```

Здесь все почти аналогично, только теперь создаем три строки.

```kotlin
LazyHorizontalStaggeredGrid(
    rows = StaggeredGridCells.Fixed(3),
```

Кроме того, у компонентов Box в качестве ширины устанавливаем случайное значение. В итоге мы получим интерфейс наподобие следующего:

```kotlin
https://metanit.com/kotlin/jetpack/pics/2.49.png
```


# FlowRow и FlowColumn

Flow-контейнеры (FlowRow и FlowColumn) предназначены для потокового размещения содержимого, когда содержимое автоматические помещается на следующую строку или столбец, если в текущей строке/столбце место заканчилось.

## FlowRow
FlowRow располагает элементы слева направо при левосторонней ориентации или справа налево при правосторонней ориентации, а когда заканчивается место, переходит к следующей строке и продолжает заполнять компоненты, пока они не закончатся. Этот компонент имеет следующие параметры:

```kotlin
@Composable
@ExperimentalLayoutApi
fun FlowRow(
    modifier: Modifier = Modifier,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    maxItemsInEachRow: Int = Int.MAX_VALUE,
    maxLines: Int = Int.MAX_VALUE,
    overflow: FlowRowOverflow = FlowRowOverflow.Clip,
    content: @Composable FlowRowScope.() -> Unit
): Unit
```

- modifier: применяемые к компоненту функции модификатора.

- horizontalArrangement: расположение вложенных компонентов по горизонтали.

- verticalArrangement: расположение вложенных компонентов по вертикали.

- maxItemsInEachRow: максимальное количество элементов в строке

- maxLines: максимальное количество строк

- overflow: принцип переноса элементов

- content: содержимое контейнера

Простейший пример FlowRow:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalLayoutApi::class) {
            val rects = listOf(
                Rect(50f,0xff16a085), Rect(100f,0xff8e44ad),
                Rect(75f,0xff2980b9), Rect(125f,0xff2c3e50),
                Rect(100f,0xfff39c12), Rect(75f,0xff27ae60),
                Rect(50f,0xffd35400), Rect(110f,0xfff6b93b),
                Rect(100f,0xff0a3d62), Rect(75f,0xffb71540)
            )
            FlowRow(Modifier.fillMaxSize(), maxItemsInEachRow = 4){
                rects.forEach({rect ->
                    Box(Modifier.size(Dp(rect.width), 100.dp).padding(5.dp).background(Color(rect.hexColor)))
                })
            }
        }
    }
}
data class Rect(val width: Float, val hexColor: Long)
```

Здесь для представления данных используется класс Rect, который представляет условный прямоугольник и принимает через конструктор ширину прямоугольника и его цвет в виде числа.

При вызове метода setContent() определяется список rects из объектов Rect, и затем из них создается компонент Box, которые помещаются в FlowRow:

```kotlin
FlowRow(Modifier.fillMaxSize(), maxItemsInEachRow = 4){
    rects.forEach({rect ->
        Box(Modifier.size(Dp(rect.width), 100.dp).padding(5.dp).background(Color(rect.hexColor)))
    })
}
```
С помощью параметра maxItemsInEachRow = 4 указываем, что строка будет иметь не более 4 элементов:

![](https://metanit.com/kotlin/jetpack/pics/2.20.png)

Стоит отметить, что FlowRow на момент написания текущей статьи находится в экспериментальном режиме, поэтому перед компонентом, который использует FlowRow указывается аннотация @OptIn(ExperimentalLayoutApi::class)

## FlowColumn
FlowColumn располагает элементы сверху вниз, а когда в столбце заканчивается место, переходит к следующему столбцу и продолжает размещать элементы, пока они не закончатся. Этот компонент имеет следующие параметры:

```kotlin
@Composable
@ExperimentalLayoutApi
fun FlowColumn(
    modifier: Modifier = Modifier,
    verticalArrangement: Arrangement.Vertical = Arrangement.Top,
    horizontalArrangement: Arrangement.Horizontal = Arrangement.Start,
    maxItemsInEachColumn: Int = Int.MAX_VALUE,
    maxLines: Int = Int.MAX_VALUE,
    overflow: FlowColumnOverflow = FlowColumnOverflow.Clip,
    content: @Composable FlowColumnScope.() -> Unit
): Unit
```

- modifier: применяемые к компоненту функции модификатора.

- horizontalArrangement: расположение вложенных компонентов по горизонтали.

- verticalArrangement: расположение вложенных компонентов по вертикали.

- maxItemsInEachColumn: максимальное количество элементов в столбце

- maxLines: максимальное количество строк

- overflow: принцип переноса элементов

- content: содержимое контейнера

Для демонстрации FlowColumn рассмотрим следующий пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowColumn
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalLayoutApi::class) {
            val rects = listOf(
                Rect(50f,0xff16a085), Rect(100f,0xff8e44ad),
                Rect(75f,0xff2980b9), Rect(125f,0xff2c3e50),
                Rect(100f,0xfff39c12), Rect(75f,0xff27ae60),
                Rect(50f,0xffd35400), Rect(110f,0xfff6b93b),
                Rect(100f,0xff0a3d62), Rect(75f,0xffb71540)
            )
            FlowColumn(Modifier.fillMaxSize(), maxItemsInEachColumn = 4){
                rects.forEach({rect ->
                    Box(Modifier.size(100.dp, Dp(rect.height)).padding(5.dp).background(Color(rect.hexColor)))
                })
            }
        }
    }
}
data class Rect(val height: Float, val hexColor: Long)
```

Здесь также для представления данных используется класс Rect, который представляет условный прямоугольник и принимает через конструктор высоту прямоугольника и его цвет.

При вызове метода setContent() определяется список rects из объектов Rect, и затем из них создается компонент Box, которые помещаются в FlowRow:

```kotlin
FlowColumn(Modifier.fillMaxSize(), maxItemsInEachColumn = 4){
    rects.forEach({rect ->
        Box(Modifier.size(100.dp, Dp(rect.height)).padding(5.dp).background(Color(rect.hexColor)))
    })
}
```

С помощью параметра maxItemsInEachColumn = 4 указываем, что каждый столбец будет иметь не более 4 элементов:

![](https://metanit.com/kotlin/jetpack/pics/2.21.png)

Как и FlowRow, компонент FlowColumn на момент написания текущей статьи находится в экспериментальном режиме, поэтому перед компонентом, который использует FlowColumn указывается аннотация @OptIn(ExperimentalLayoutApi::class)

## Применение FlowRow и FlowColumn
Возьмем чуть более сложный пример с FlowRow:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalLayoutApi::class) {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
 
            FlowRow(Modifier.fillMaxSize(), maxItemsInEachRow = 3){
                langs.forEach({lang ->
                    Column(Modifier.padding(7.dp).size(115.dp, 140.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 22.sp, modifier = Modifier.padding(5.dp))
                    }
                })
            }
        }
    }
}
data class Language(val name:String, val hexColor: Long)
```

Здесь данные представлены классом Language, который представляет условный язык программирования и через конструктор получает название языка и цвет. Во FlowRow задаем ограничение - не более трех элементов в 1 строке:

![](https://metanit.com/kotlin/jetpack/pics/2.22.png)

Аналогичный пример с FlowColumn:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowColumn
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalLayoutApi::class) {
            val langs = listOf(Language("Kotlin", 0xff16a085),
                Language("Java", 0xff2980b9),
                Language("JavaScript", 0xff8e44ad),
                Language("Python", 0xff2c3e50),
                Language("Rust",0xffd35400),
                Language("C#",0xff27ae60),
                Language("C++",0xfff39c12),
                Language("Go",0xff1abc9c))
            FlowColumn(Modifier.fillMaxSize(), maxItemsInEachColumn = 3){
                langs.forEach({lang ->
                    Column(Modifier.padding(7.dp).size(115.dp, 140.dp), horizontalAlignment = Alignment.CenterHorizontally) {
                        Box(Modifier.size(100.dp).background(Color(lang.hexColor)))
                        Text(lang.name, fontSize = 22.sp, modifier = Modifier.padding(5.dp))
                    }
                })
            }
        }
    }
}
data class Language(val name:String, val hexColor: Long)
```

Здесь располагаем не более 3 элементов в одном столбце:

![](https://metanit.com/kotlin/jetpack/pics/2.23.png)

Стоит отметить, что если элементов много, то какая-то часть FlowRow/FlowColumn окажется вне области обзора, соответственно для просмотра невидимой части следует использовать прокрутку. По умолчанию для FlowRow/FlowColumn прокрутка автоматически не создается. Нам самим надо определять прокрутку, например, с помощью модификатора Modifier.horizontalScroll() (для FlowColumn) или verticalScroll() (для FlowRow)




# IntrinsicSize

Один из способов, с помощью которого Compose может быстро и эффективно отображать пользовательский интерфейс, заключается в ограничении измерения каждого компонента только один раз во время операции рекомпозиции. Однако иногда возникают ситуации, когда родительскому контейнеру необходимо знать информацию о размерах своих дочерних элементов, прежде чем они будут измерены в рамках рекомпозиции. Например, может потребоваться, чтобы ширина столбца соответствовала ширине его самого широкого дочернего элемента. Хотя родительский контейнер не может измерить свои вложенные компоненты, информацию о размерах можно получить, не нарушая правила "измерить один раз", используя intrinsic-измерения.

Родительский контейнер может получить информацию о размерах своих дочерних элементов, обратившись к значениям Max и Min перечисления IntrinsicSize. Это перечисление предоставляет родительскому контейнеру информацию о максимально или минимально возможной ширине или высоте его самого широкого или самого высокого дочернего элемента. Это позволяет контейнеру принимать решения о размерах, исходя из потребностей своих вложенных компонентах в размерах.

Например, установка высоту строки в зависимости от размеров вложенных компонентов:

```kotlin
Row(modifier = modifier.height(IntrinsicSize.Min)) {
............................ 
}
```

В итоге когда происходит рендеринг данной строки, ее высота будет установлена на минимально возможную высоту, которая необходима для отображения ее самого высокого дочернего элемента. налогично, следующий код настраивает ширину столбца на максимально возможную ширину его самого широкого дочернего элемента:

```kotlin
Column(modifier = modifier.width(IntrinsicSize.Max)) {
............................ 
}
```

Таким образом, используя IntrinsicSize контейнеры устанавливают свой размер в соответствии с требованиями к пространству их дочерних элементов, что особенно может быть полезно, когда один или несколько дочерних элементов подвергаются динамическим изменениям размера.

Посмотрим на примере. Пусть у нас есть следующий простейший интерфейс:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.IntrinsicSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Column(Modifier.padding(5.dp)) {
                Text("Hello METANIT.COM", Modifier.padding(start = 4.dp), fontSize = 28.sp)
                Box(Modifier.height(10.dp).fillMaxWidth().background(Color.Blue))
            }
        }
    }
}
```

Здесь в столбце Column расположены два компонента: Text и Box. При этом компонент Box растянут по всей ширине столбца, чтобы создать некоторую полоску под текстом:

![](https://metanit.com/kotlin/jetpack/pics/2.43.png)

Но проблема здесь в том, что Box под текстом по ширине не соответствует тексту, так как столбец растягивается по всей ширине экрана. Мы могли бы установить для столбца точную ширину, подогнав ее под длину текста, но в этом случае при динамическом изменении текста у нас опять же были бы проблемы с размерами. И поэтому теперь применим IntrinsicSize.Max:

![](package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.IntrinsicSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Column(Modifier.padding(5.dp).width(IntrinsicSize.Max)) {
                Text("Hello METANIT.COM", Modifier.padding(start = 4.dp), fontSize = 28.sp)
                Box(Modifier.height(10.dp).fillMaxWidth().background(Color.Blue))
            }
        }
    }
})

Теперь благодаря установке для ширины столбца значения IntrinsicSize.Max этот столбец занимает ровно ту ширину, которая необходима для его содержимого:

![](https://metanit.com/kotlin/jetpack/pics/2.44.png)

Однако компонент Text также может отображать многострочный текст. Это означает, что один и тот же текст потенциально может быть размещен в нескольких строках, что значительно уменьшит ширину, необходимую для отображения этого текста. Минимальная ширина (если нет других ограничений по высоте) компонента Text может соответствовать длине его самого длинного слова. Это значение соответствует значению IntrinsicSize.Min:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.IntrinsicSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Column(Modifier.padding(5.dp).width(IntrinsicSize.Min)) {
                Text("Hello METANIT.COM", Modifier.padding(start = 4.dp), fontSize = 28.sp)
                Box(Modifier.height(10.dp).fillMaxWidth().background(Color.Blue))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/2.45.png)




# Программная прокрутка


Кроме автоматической прокрутки с помощью пролистывания пальцев на экране устройства Jetpack Compose также поддерживает программную прокрутку, которую можно выполнить из кода Kotlin. Это может быть полезно, когда нам надо изменить текущую позицию в списке, перейти к какому-то определенному элементу в этом списке.

## Column и Row
При работе со контейнерами Column и Row программную прокрутку можно выполнить с помощью функций объекта ScrollState:

- animateScrollTo(value: Int) - плавная прокрутка до указанной позиции пикселя в списке с использованием анимации

- scrollTo(value: Int) - мгновенная прокрутка до указанной позиции пикселя

Печальная сторона этих функций заключается в том, что их параметры представляют позицию в пикселях, а не номер элемента. То есть начало списка представлено позицией пикселя 0, но позиция пикселя, представляющая конец списка, может быть менее очевидной. К счастью, максимальную позицию прокрутки можно определить, обратившись к свойству maxValue:

```kotlin
val maxScrollPosition = scrollState.maxValue
```

Также стоит учитывать, что это suspend-функции, поэтому их необходимо вызывать из корутин.

Например, определим код для прокрутки в последнему элементу в контейнере Column:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val scrollState = rememberScrollState()
            val coroutineScope = rememberCoroutineScope()
            Column(Modifier.verticalScroll(scrollState)) {
                Text("В конец", Modifier.padding(8.dp).background(Color.DarkGray).padding(5.dp).clickable {
                    coroutineScope.launch() {
                        scrollState.animateScrollTo(scrollState.maxValue)
                    }
                }, fontSize = 28.sp, color = Color.White)
                repeat(20){
                    Text("Item $it", Modifier.padding(8.dp), fontSize = 28.sp)
                }
            }
        }
    }
}
```

В начале контейнера Column здесь определен компонент Text, по нажатию на который вызывается корутина, которая выполняет функцию scrollState.animateScrollTo()

![](https://metanit.com/kotlin/jetpack/pics/2.48.png)

## LazyColumn и LazyRow
Для программной прокрутки списков LazyColumn и LazyRow применяются функции объекта LazyListState, который можно получить с помощью вызова функции rememberLazyListState():

```kotlin
val listState = rememberLazyListState()
```

Затем этои объект передается параметру state:

```kotlin
LazyColumn(state = listState....
```

Для собственно прокрутки вызываются следующие методы LazyListState:

- animateScrollToItem(index: Int) — плавная прокрутка к указанному элементу списка (где 0 — первый элемент)

- scrollToItem(index: Int) — мгновенная прокрутка к указанному элементу списка (где 0 — первый элемент)

Это тоже suspend-функции, которые должны запускаться из корутин. Применение:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val listState = rememberLazyListState()
            val coroutineScope = rememberCoroutineScope()
            LazyColumn(state=listState) {
                item{Text("В конец", Modifier.padding(8.dp).background(Color.DarkGray).padding(5.dp).clickable {
                    coroutineScope.launch() {
                        listState.animateScrollToItem(19)
                    }
                }, fontSize = 28.sp, color = Color.White)
                }
                items(20){
                    Text("Item $it", Modifier.padding(8.dp), fontSize = 28.sp)
                }
            }
        }
    }
}
```

В данном случае создается аналогичный список с 20 компонентами Text плюс начальный Text, который выполняет роль кнопки перехода к 19-му элементу в списке.


# Прикрепленные заголовки

LazyColumn и LazyRow позволяют использовать прикрепленные заголовки или sticky headers. То есть мы можем сгруппировать элементы списка под соответствующим заголовком. И припрепленные заголовки остаются видимыми на экране во время прокрутки текущей группы. Как только группа прокручивается из поля зрения, ее место занимает заголовок следующей группы.

Для создания прикрепленных заголовков применяется функция LazyListScope.stickyHeader(). А содержимое списка должно храниться в массиве или списке, который трансформируется в группы с помощью функции Kotlin groupBy(). Функция groupBy() принимает лямбду-селектор, которая определяет, как данные должны быть сгруппированы. Этот селектор затем служит ключом для доступа к элементам каждой группы.

Рассмотрим, например, следующий список, содержащий модели смартфонов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalFoundationApi::class){
            // начальные данные
            val phones = listOf("Apple iPhone 15 Pro", "Realme 11 PRO", "Google Pixel 5", "Samsung Galaxy S24 Ultra", "Google Pixel 6",
                "Samsung Galaxy S21 FE", "Apple iPhone 15 Pro Max", "Xioami Redmi Note 12", "Xiaomi Redmi 12",
                "Apple iPhone 13", "Google Pixel 6", "Apple iPhone 14",
                "Realme C30s", "Realme Note 50")
            // создаем группы
            val groups = phones.groupBy { it.substringBefore(" ") }
            LazyColumn(
                contentPadding = PaddingValues(5.dp)
            ){
                groups.forEach { (brand, models) ->
                    stickyHeader {
                        Text(
                            text = brand,
                            fontSize = 28.sp,
                            color = Color.White,
                            modifier = Modifier.background(Color.Gray).padding(5.dp).fillMaxWidth()
                        )
                    }
                    items(models) { model ->
                        Text(model, Modifier.padding(5.dp), fontSize = 28.sp)
                    }
                }
            }
        }
    }
}
```
Прежде всего стоит отметить, что на момент написания текущей статьи функциональность LazyListScope.stickyHeader() является экспериментальной, поэтому компонент, который использует данную функцию, надо предварять аннотацией @OptIn(ExperimentalFoundationApi::class)

```kotlin
setContent @OptIn(ExperimentalFoundationApi::class){
.....
}
```

Сами выводимые данные представляют список phones, который содержит названия моделей смартфонов. С помощью функцию groupBy() группируем элементы этого списка по начальной подстроке:

val groups = phones.groupBy { it.substringBefore(" ") }

Здесь it - это каждая строка из списка, соответственно выражение it.substringBefore(" ") получает в каждой строке списка подстроку, которая идет до пробела. Например, из строки "Apple iPhone 15 Pro" получаем подстроку "Apple". В данном случае мы условимся, что эта подстрока будет представлять производителя смартфона. И функция groupBy группирует все данные по полученным подстрокам-производителям. В итоге получается словарь типа Map<String, List<String>>, где ключами являются подстрокам-производители, а значениями - подсписок смартфонов конкретно данного производителя.

Далее перебираем весь этот словарь:

```kotlin
groups.forEach { (brand, models) ->
    stickyHeader {
        Text(
            text = brand,
            fontSize = 28.sp,
            color = Color.White,
            modifier = Modifier.background(Color.Gray).padding(5.dp).fillMaxWidth()
        )
    }
    items(models) { model ->
        Text(model, Modifier.padding(5.dp), fontSize = 28.sp)
    }
}
```

И для каждого элемента словаря для ключа используем функцию stickyHeader() - в ней создаем компонент Text, который будет представлять собственно заголовок и будет отображать ключ -производителя смартфонов. И также для каждого элемента словаря применяется функция items(), которая отображает список смартфонов конкретного данного производителя. В итоге мы получим следующее приложение:

![](https://metanit.com/kotlin/jetpack/pics/2.46.png)

Обратите внимание, что хотя группа Apple частично прокручивается вне поля зрения, заголовок остается в верхней части экрана.

Другой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent @OptIn(ExperimentalFoundationApi::class){
            // начальные данные
            val people = listOf(
                Person("Tom", "Microsoft"), Person("Alice", "Microsoft"),
                Person("Bob", "Google"), Person("Sam", "JetBrains"),
                Person("Kate", "Google"), Person("Mark", "Google"),
                Person("Bill", "Microsoft"), Person("Sandra", "JetBrains"),
                Person("Lisa", "Apple"), Person("Alex", "Apple")
            )
            // создаем группы
            val groups = people.groupBy { it.company }
            LazyColumn(
                contentPadding = PaddingValues(5.dp)
            ){
                groups.forEach { (company, employees) ->
                    stickyHeader {
                        Text(
                            text = company,
                            fontSize = 28.sp,
                            color = Color.White,
                            modifier = Modifier.background(Color.Gray).padding(5.dp).fillMaxWidth()
                        )
                    }
                    items(employees) { employee ->
                        Text(employee.name, Modifier.padding(5.dp), fontSize = 28.sp)
                    }
                }
            }
        }
    }
}
 
data class Person(val name:String, val company: String)
```

Здесь данные представляют сложные данные объекта Person, который определяет два свойства: name и company. Группировка идет по свойству company:

![](https://metanit.com/kotlin/jetpack/pics/2.47.png)