# Лекция 2. Модификаторы и визуальный интерфейс

## Что такое модификаторы 

Для настройки внешнего вида и стилизации большинства встроенных компонентов в Jetpack Compose применяются так называемые модификаторы. Модификаторы представляют функции, которые задают какой-то отдельный аспект для компонентов (или иными словами "модифицируют" внешний вид компонента), например, установка размеров компонента или его фонового цвета и т.д.

Большинство встронных компонентов поддерживают применение модификаторов через параметр modifier. Например, возьмем ранее встречавшийся простой компонент Text, который выводит некоторый текст. Данный компонент, как и другие компоненты в Jetpack Compose, определен в виде функции с аннотацией @Compose, которая имеет ряд параметров:


```kotlin
@Composable
fun Text(
    value: String,
    modifier: Modifier = Modifier,
     
    //..... остальные параметры
     
): @Composable Unit
```

Из определения функции компонента мы видим, что она имеет параметр modifier, который представляет тип (а если точнее интерфейс) Modifier. Его цель хранить конфигурационные настройки, которые применябтся к компонентами Composable. И тип Modifier предоставляет огромное количество встроенных функций-модификаторов, которые изменяют (модифицируют) отдельные аспекты компонентов. Далее отдельно рассмотрим отдельные группы этих функций. Большинство из них более или менее универсальны, применяются ко многим компонентам. А пока посмотрим на примере компонента Text, как применять модификаторы.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize = 28.sp,
                modifier = Modifier.background(Color.LightGray)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.1.png)

Здесь для компонента Text задается три параметра. Первый параметр представляет отображаемый текст. Второй параметр - fontSize задает размер шрифта - 28 единиц. Третий параметр задает модификаторы, которые применяются к компоненту:

```kotlin
modifier = Modifier.background(Color.LightGray)
```

В данном случае применяется только один модификатор - функция background(), которая устанавливает фоновый цвет. В нее передается определение цвета - здесь желтый цвет, предоставленный встроенным значением Color.LightGray.

Стоит учитывать, что функции модификаторы, как и используемые ими значения, необходимо импортировать:

```kotlin
import androidx.compose.foundation.background
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
```

## Применение нескольких модификаторов

К компоненту можно применять множество модификаторов по цепочке:

```kotlin
Modifier.модификатор1().модификатор2().модификатор3()...модификаторN()
```

Например, применим к компоненту Text несколько модификаторов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize = 28.sp,
                modifier = Modifier
                    .background(Color.LightGray)
                    .padding(30.dp)
            )
        }
    }
}
```

Здесь к компоненту Text применяются три функции-модификатора. Первая задает фоновый цвет:

```kotlin
Modifier.background(Color.LightGray)
```

Второй модификатор устанавливает отступы (30 единиц) от границ контейнера:

```kotlin
padding(30.dp)
```

![](https://metanit.com/kotlin/jetpack/pics/3.2.png)

Стоит отметить, что порядок модификаторов может играть большую роль. Так, в примере выше сначала применяется фоновый цвет к элементу Text, затем его содержимое сдвигается на 30 единиц от границ контейнера. Но попробуем изменить порядок модификаторов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(30.dp)
                    .background(Color.LightGray)
            )
        }
    }
}
```

Теперь сначала содержимое Text сдвигается на 30 единиц, а потом к нему применяется фоновый цвет. И в итоге мы получим несколько иной результат:

![](https://metanit.com/kotlin/jetpack/pics/3.11.png)

# Установка цвета

Для установки фонового цвета применяется модификатор background(). Есть две версии этой функции. Первая версия:

```kotlin
fun Modifier.background(color: Color, shape: Shape = RectangleShape): Modifier
```

- color: значение цвета в виде объекта Color

- shape: закрашиваемая форма - объект Shape. По умолчанию это прямоугольная форма

Вторя версия:

```kotlin
fun Modifier.background(
    brush: Brush,
    shape: Shape = RectangleShape,
    alpha: Float = 1.0f
): Modifier
```

- brush: применяемая для покрытия цветом кисть в виде объекта Brush

- shape: закрашиваемая форма - объект Shape. По умолчанию это прямоугольная форма

- alpha: значение прозрачности. Оно должно находится в диапазоне от 0 (полностью прозрачно) до 1 (отсутствие прозрачности)

В данном случае разберем только установку цвета.

## Color. Определение цвета
В Jetpack Compose цвет представлен классом Color из пакета androidx.compose.ui.graphics..

Есть несколько способов создания цвета. Рассмотрим некоторые:

- Color(value): в конструктор передается шестнадцатеричное значение цвета. Например

```kotlin
val myColor: Color = Color(0xFF0000FF)
```

- Color(red, green, blue, alpha): в конструктор передается числовые значения для каждой отдельной компоненты цвета.

```kotlin
val myColor: Color = Color(red = 0xFF, green = 0xFF, blue = 0xFF, alpha = 0xFF)
```

Например, зададим фоновый цвет для компонента Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val myColor = Color(red = 0xF1, green = 0xAA, blue = 0x55, alpha = 0xFF)
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.background(myColor).padding(30.dp)
 
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.3.png)

Также есть ряд встроенных значений:

- Color.Black
- Color.Blue
- Color.Cyan
- Color.DarkGray
- Color.Gray
- Color.Green
- Color.LightGray
- Color.Magenta
- Color.Red
- Color.Transparent
- Color.White
- Color.Yellow

Пример применения:

```kotlin
modifier = Modifier.background(Color.Yellow)
```

# Установка размеров

Для установки размеров компонентов в Jetpack Compose определен целый ряд модификаторов:

- Modifier.height(): устанавливает высоту
- Modifier.width(): устанавливает ширину
- Modifier.fillMaxHeight(): растягивает компонент по всей длине контейнера
- Modifier.heightIn(): устанавливает минимальную и максимальную высоту
- Modifier.widthIn(): устанавливает минимальную и максимальную ширину
- Modifier.size(): устанавливает размер
- Modifier.sizeIn(): устанавливает минимальный и максимальный размер

Для установки применяются единицы dp (device-independent pixels/density-independent pixels или независимые от устройства/плотности пиксели).

Например, установим для компонента Text высоту и ширину:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.background(color=Color.LightGray).width(300.dp).height(200.dp)
            )
        }
    }
}
```

Обратите внимание, как устанавливаются значения - после числа перед dp идет точка.

![](https://metanit.com/kotlin/jetpack/pics/3.4.png)

Модификаторы width и height, как и другие модификаторы установки размеров, определены в пакете androidx.compose.foundation.layout. Мы их можем импортировать по отдельности:

```kotlin
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.width
```

Также можно подключить сразу все подобные модификаторы, что удобно при использовании сразу нескольких из них:

```kotlin
import androidx.compose.foundation.layout.*
```
С помощью модификатора size() можно объединить установку высоты и ширины:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.background(color=Color.LightGray).size(width = 300.dp, height= 200.dp)
            )
        }
    }
}
```
Если высота и ширина совпадают, то можно передать в функцию size() только одно общее значение. Например, установка ширины и высоты в 300 единиц:

```kotlin
modifier = Modifier.background(color=Color.LightGray).size(300.dp)
```

## Установка минимальных и максимальных размеров
Модификаторы heightIn() и widthIn() принимают два значения - минимальные и максимальные значения. Например:

```kotlin
modifier = Modifier.background(color=Color.LightGray)
                    .widthIn(min = 100.dp, max = 400.dp)
                    .heightIn(min=50.dp, max=300.dp)
```

С помощью sizeIn можно сократить определение размеров:

```kotlin
modifier = Modifier.background(color=Color.LightGray)
                    .sizeIn(minWidth = 100.dp, maxWidth = 400.dp, minHeight= 50.dp, maxHeight= 300.dp)

```

## Растяжение по всей длине и ширине контейнера

Отдельная группа модификаторов позволяет растянуть компонент по все длине и(или) ширине контейнера:

- Modifier.fillMaxWidth(): растягивает компонент по всей ширине контейнера
- Modifier.fillMaxHeight(): растягивает компонент по всей высоте контейнера
- Modifier.fillMaxSize(): растягивает компонент по всей длине и ширине контейнера

Например, растянем компонент Text по всей ширине и длине контейнера:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.background(color=Color.LightGray).fillMaxSize()
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.5.png)

В качестве параметра модификаторы Modifier.fillMaxWidth(), Modifier.fillMaxHeight() и Modifier.fillMaxSize() принимают множитель, который устанавливает, какую часть от размеров контейнера займет компонент. Это значение имеет тип Float и находится в диапазоне от 0.0 до 1.0. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.background(color=Color.LightGray).fillMaxSize(0.5f)
            )
        }
    }
}
```

Переданное в функцию fillMaxSize() значение 0.5f указывает, что компонент получит половину (или 0.5) от ширины и длины контейнера.

![](https://metanit.com/kotlin/jetpack/pics/3.6.png)


# Установка отступов и смещения

## Отступы
Для установки отступов внутри компонента применяется модификатор padding(), которые имеет несколько вариантов:

```kotlin
// устанавливает отступы от каждой стороны по отдельности
fun Modifier.padding(start: Dp = 0.dp, top: Dp = 0.dp, end: Dp = 0.dp, bottom: Dp = 0.dp): Modifier
// устанавливает отступы по вертикали и по горизонтали
fun Modifier.padding(horizontal: Dp = 0.dp, vertical: Dp = 0.dp): Modifier
// устанавливает одно значение для отступов от всех четырех сторон
fun Modifier.padding(all: Dp): Modifier
// устанавливает отступы в виде объекта PaddingValues
fun Modifier.padding(paddingValues: PaddingValues): Modifier
```

В качестве значения отступов применяются единицы dp. Применим данный модификатор:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.padding(30.dp)
            )
        }
    }
}
```

В данном случае устанавливается отступ в 30 единиц между границами компонента Text и его содержимым.

![](https://metanit.com/kotlin/jetpack/pics/3.7.png)

Установка отступов по отдельности:

```kotlin
Modifier.padding(start = 30.dp, top=30.dp, bottom = 25.dp)
```

Причем необязательно устанавливать отступы от всех четырех сторон, можно задать только те отступы, которые нужны.

Установка отступов по горизонтали и вертикали:

```kotlin
Modifier.padding(horizontal = 25.dp, vertical = 25.dp)
```

**PaddingValues**
Тип PaddingValues применяет значения для установки отступов:

```kotlin
public fun PaddingValues(
    start: Dp,
    top: Dp,
    end: Dp,
    bottom: Dp
): PaddingValues
```

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            val innerPadding = PaddingValues(top = 20.dp, start = 15.dp)
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.padding(innerPadding)
            )
        }
    }
}
```
### Порядок применения отступов
При использовании отступов следует учитывать очередность их применения, например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.fillMaxSize()
                    .padding(20.dp)     // отступы перед закрашенной областью
                    .background(color= Color.Yellow)
                    .padding(30.dp)     // отступы перед текстом
            )
        }
    }
}
```
Здесь компонент Text растягивается по всей длине и ширине экрана. При этом к компоненту применяются два отступа. Но один отступ применяется до установки фонового цвета, а другой отступ - после.

![](https://metanit.com/kotlin/jetpack/pics/3.8.png)

В итоге получится, что сначала применяется модификатор padding(20.dp), который устанавливает отступ в 20 единиц между границами компонента и закрашиваемой областью. Затем применяется модификатор padding(30.dp), который устанавливает отступ в 30 единиц между границами закрашенной области и содержимым - текстом.

## Сдвиг
Для сдвига содержимого компонента по горизонтали и вертикали применяется модификатор offset. Он имеет следующие версии:

```kotlin
fun Modifier.offset(x: Dp = 0.dp, y: Dp = 0.dp): Modifier
fun Modifier.offset(offset: Density.() -> IntOffset): Modifier
```
Посмотрим на использование первой версии модификатора:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.offset
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.background
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "Hello METANIT.COM",
                fontSize=28.sp,
                modifier = Modifier.size(width=300.dp, height=200.dp)
                    .background(color= Color.LightGray)
                    .offset(x=30.dp, y=50.dp)
            )
        }
    }
}
```

В данном случае сдвигаем содержимое компонента Text на 30 единиц по горизонтали и на 50 единиц по вертикали.

![](https://metanit.com/kotlin/jetpack/pics/3.9.png)

Как и в случае с отступами следует учитывать порядок применения модификаторов. Так, изменим из предыдущего примера компонент Text следующим образом:

```kotlin
Text(
    "Hello METANIT.COM",
    fontSize=28.sp,
    modifier = Modifier.size(width=300.dp, height=200.dp)
                    .offset(x=30.dp, y=50.dp)
                    .background(color= Color.LightGray)
)
```

В предыдущем примере сначала применялся фоновый цвет, а лишь затем смещение. Теперь же, наоборот, соответственно мы увидим, что сначала будет производиться смешение содержимого компонента, а затем окрашивание фоновым цветом:

![](https://metanit.com/kotlin/jetpack/pics/3.10.png)

При этом можно передавать не только положительные, но отрицательные значения. В этом случае сдвиг идет в противоположном направлении.


# Создание прокрутки

Вполне может оказаться, содержимое какого-либо компонента больше размера контейнера. В этом случае очевидным решением будет создание прокрутки. Однако по умолчанию она отстутсвует, ее необходимо добавлять вручную. Рассмотрим, как это сделать

## Прокрутка по горизонтали
Для добавления прокрутки содержимого по горизонтали применяется модификатор Modifier.horizontalScroll:

```kotlin
fun Modifier.horizontalScroll(
    state: ScrollState,
    enabled: Boolean = true,
    flingBehavior: FlingBehavior? = null,
    reverseScrolling: Boolean = false
): Modifier
```

Параметры модификатора:

- state: представляет объект ScrollState и описывает состояние полосы прокрутки

- enabled: значение типа Boolean, которое указывает, будет ли прокрутка доступна. По умолчанию имеет значение true

- flingBehavior: представляет объект FlingBehavior и описывает поведение при завершении прокрутки. По умолчанию имеет значение ScrollableDefaults.flingBehavior

- reverseScrolling: устанавливает направление. При значении true прокрутка идет в обратном направлении. По умолчанию имеет значение false

Применим горизонтальную прокрутку к компоненту Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.ScrollState
import androidx.compose.foundation.horizontalScroll
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "What is Lorem Ipsum?\n" +
                    "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n" +
                    "\n" +
                   "...............",
                fontSize=22.sp,
                modifier = Modifier.horizontalScroll(ScrollState(0))
            )
        }
    }
}
```
Здесь в модификатор .horizontalScroll(ScrollState(0)) передается объект ScrollState, которые инициализирован числом 0 - это начальное положение полосы прокрутки, а именно 0 пикселей. Соответственно, если мы хотим, чтобы скролл устанавливался на каком-то другом положении, то можно передать другое значение.

![](https://metanit.com/kotlin/jetpack/pics/3.12.png)

**Тип rememberScrollState**

Хотя мы можем сами определять состояние полосы покрутки с помощью объекта ScrollState, но Jetpack Compose также предлагает встроенную реализацию в виде типа rememberScrollState:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.horizontalScroll
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "What is Lorem Ipsum?\n" +
                    "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n" +
                    "\n" +
                   "...............",
                fontSize=22.sp,
                modifier = Modifier.horizontalScroll(rememberScrollState())
            )
        }
    }
}
```

**Прокрутка по вертикали**

Для добавления прокрутки содержимого по вертикали применяется модификатор Modifier.verticalScroll:

```kotlin
fun Modifier.verticalScroll(
    state: ScrollState,
    enabled: Boolean = true,
    flingBehavior: FlingBehavior? = null,
    reverseScrolling: Boolean = false
): Modifier
```
Данный модификатор принимает те же значения и работает в приниципе также, как и horizontalScroll, только по вертикали. Применим данный модификатор:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent{
            Text(
                "What is Lorem Ipsum?\n" +
                    "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n" +
                    "\n" +
                   "...............",
                fontSize=22.sp,
                modifier = Modifier.verticalScroll(rememberScrollState())
            )
        }
    }
}
```

### Сочетание прокруток по горизонтали и вертикали
Применяя оба модификатора - horizontalScroll() и verticalScroll(), можно совместить прокрутку по горизонтали и вертикали:

```kotlin
Text(
    "What is Lorem Ipsum?\n" +
        "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n" +
        "\n" +
        "...............",
    fontSize=22.sp,
    modifier = Modifier
                .verticalScroll(rememberScrollState())
                .horizontalScroll(rememberScrollState())
)
```

# Создание границы. Модификатор border

Модификатор border позволяет определить границу вокруг компонента. Этот модификатор имеет следующие определения:

```kotlin
Modifier.border(border: BorderStroke, shape: Shape = RectangleShape)
Modifier.border(width: Dp, brush: Brush, shape: Shape = RectangleShape)
Modifier.border(width: Dp, color: Color, shape: Shape = RectangleShape)
```

Первый вариант в качестве первого параметра принимает объект BorderStroke, в который через конструктор передается ширина линии в единицах dp и ее цвет в виде объекта Brush:

```kotlin
BorderStroke(width: Dp, brush: Brush)
```

Последний параметр представляет объект Shape, который определяет форму контура вокруг компонента. По умолчанию это RectangleShape, который представляет прямоугольную область.

Второй и третий варианты по сути повторяют первый вариант, только в третьем случае для установки цвета применяется объект Color.

Определим границу вокруг компонента Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM!",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(10.dp)
                    .border(width = 2.dp, color = Color.Black)
            )
        }
    }
}
```

Здесь вокруг текста создается граница черного цвета толщиной в 2 единицы:

![](https://metanit.com/kotlin/jetpack/pics/3.13.png)

По умолчанию граница примыкает к содержимому элементов. Чтобы между ними было пространство, можно использовать отступы после установки границы:

```kotlin
Text("Hello METANIT.COM!",
    fontSize = 28.sp,
    modifier = Modifier
                .padding(10.dp)     // отступы между границей компонента и границами контейнера
                .border(width = 2.dp, color = Color.Black)
                .padding(10.dp)     // отступы между границей и содержимым компонента
)
```

![](https://metanit.com/kotlin/jetpack/pics/3.14.png)

Аналогичным образлм можно закрасить область внутри границы:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp

import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM!",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(10.dp)
                    .border(width = 2.dp, color = Color.DarkGray)
                    .background(Color.LightGray)
                    .padding(10.dp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.15.png)

По умолчанию в качестве формы границы применяется объект RectangleShape, который определяет прямоугольную область. В частности, одна из наиболее используемых - это округлая форма с закруглениями вместо углов. Для ее создания можно применять объект RoundedCornerShape, в конструктор которого передается радиус:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM!",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(10.dp)
                    .border(width = 2.dp, color = Color.DarkGray, shape= RoundedCornerShape(20.dp))
                    .padding(10.dp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.16.png)


# Модификатор clip. Создание фрагмента компонента

Модификатор clip применяется для определения фрагмента компонента. Он имеет следующее определение:

```kotlin
fun Modifier.clip(shape: Shape): Modifier
```

В качестве параметра он принимает объект интерфейса Shape, который определяет вырезаемую форму.

Распространенным сценарием использования этого модификатора является создание фрагмента компонента на основе непрямоугольной формы, например, в виде овала или круга. Например, образуем из компонента Text округлую форму:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM!",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(10.dp)
                    .clip(shape= RoundedCornerShape(30.dp))
                    .background(Color.LightGray)
                    .padding(15.dp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.17.png)

К фрагменту мы можем добавить границу:

```kotlin
Text("Hello METANIT.COM!",
        fontSize = 28.sp,
        modifier = Modifier
                .padding(10.dp)
                .clip(shape= RoundedCornerShape(30.dp))
                .border(width = 2.dp, color = Color.DarkGray, shape= RoundedCornerShape(30.dp))
                .background(Color.LightGray)
                .padding(15.dp)
)
```

![](https://metanit.com/kotlin/jetpack/pics/3.18.png)

Модификатор clip упрощает создание более сложных по композиции визуализаций компонентов. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM!",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(10.dp)     // отступ от границ контейнера
                    .background(Color.DarkGray)
                    .padding(25.dp)    // отступ от границ фрагмента
                    .clip(shape= RectangleShape)
                    .border(width = 2.dp, color = Color.White)
                    .background(Color.LightGray)
                    .padding(20.dp)     // отступ между границей во фрагменте и текстом
            )
        }
    }
}
```

Разберем использованные здесь модификаторы. Сначала устанавливаем отступ от границ контейнера:

```kotlin
.padding(10.dp)
```

Затем для всей области компонента Text устанавливается темно-серый цвет

```kotlin
.background(Color.DarkGray)
```

Далее внутри этой области устанавливаем отступ до границ фрагмента

```kotlin
.padding(25.dp)
```
Далее определяем прямоугольный фрагмент, для чего используем форму RectangleShape:

```kotlin
.clip(shape= RectangleShape)
```
Затем для фрагмента устанавливаем границу белого цвета:

```kotlin
.border(width = 2.dp, color = Color.White)
```

Фрагмент компонента Text закрашиваем в светло-серый цвет:

```kotlin
.background(Color.LightGray)
```

В конце устанавливаем отстут между содержимым компонента - собственно текстом и границей во фрагменте:

```kotlin
.padding(20.dp)
```

![](https://metanit.com/kotlin/jetpack/pics/3.19.png)


# Создание тени и модификатор shadow

Модификатор shadow позволяет создать тень вокруг элемента. Этот модификатор имеет следующую форму:

```kotlin
fun Modifier.shadow(
    elevation: Dp,
    shape: Shape = RectangleShape,
    clip: Boolean = elevation > 0.dp,
    ambientColor: Color = DefaultShadowColor,
    spotColor: Color = DefaultShadowColor
): Modifier
```

Функция модификатора принимает следующие параметры:

- elevation: высота тени в dp

- shape: определяет форму тени с помощью объекта Shape

- clip: если равно true, то создается фрагмент с использованием формы из параметра shape

- ambientColor: цвет затенения на компоненте

- spotColor: цвет тени вокруг компонента

Для создания тени нам достаточно задать ее высоту. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(20.dp)
                    .shadow(3.dp)
                    .padding(15.dp)
            )
        }
    }
}
```

В данном случае вокруг компонента Text создается тень высотой в 3 единицы:

![](https://metanit.com/kotlin/jetpack/pics/3.20.png)

Параметр shape позволяет задать форму тени. Он принимает объект интерфейса Shape. Например, определим округлую тень и для этого используем встроенный класс CircleShape:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text("Hello METANIT.COM",
                fontSize = 28.sp,
                modifier = Modifier
                    .padding(20.dp) 
                    .shadow(4.dp, shape= CircleShape)
                    .padding(20.dp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/3.21.png)


# Обработка нажатий

Объект Modifier позволяет добавить компонентам возможность обработки нажатия. Для этого он предоставляет функцию clickable():

```kotlin
fun Modifier.clickable(
    enabled: Boolean = true,
    onClickLabel: String? = null,
    role: Role? = null,
    onClick: () -> Unit
): Modifier
```

Параметры функции:

- enabled: значение типа Boolean, которое указывает, будет ли доступен компонент для нажатия. По умолчанию имеет значение true, то есть компонент будет доступен для нажатия. При значении false обработка нажатий оключена.

- onClickLabel: предоставляет значение типа String? и задает метку, с помощью которой можно быстро обратиться к компоненту. По умолчанию равен null

- role: объект типа Role?, который устанавливает тип визуального элемента. По умолчанию равен null

- onClick: функция типа () -> Unit, которая собственно и обрабатывает нажатие.

Например, определим простейшую обработку нажатия для компонента Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.clickable
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val count = remember{mutableStateOf(0)}
 
            Text("Clicks: ${count.value}",
                fontSize = 28.sp,
                modifier = Modifier.clickable( onClick = { count.value += 1 })
            )
        }
    }
}
```

В данном случае мы определяем переменную count, которая будет хранить количество нажатий. Однако это не просто число. Она будет предоставлять - объект типа MutableState<Int>, который создается функцией mutableStateOf(). В дальнейшем мы подробнее разберем объект MutableState и функцию mutableStateOf, а пока достуточно знать, что в эту функцию передается собственно хранимое значение, которое затем можно получить с помощью свойства value объекта MutableState<T>. А функция remember позволяет сохранить это значение.

Обратившись к свойству value мы можем получить значение и вывести его в строке в компоненте Text:

```kotlin
Text("Clicks: ${count.value}"
```

А в функцию Modifier.clickable через параметр onClick передаем обработчик нажатия, котором это значение увеличивается на единицу:

```kotlin
onClick = { count.value += 1 }
```
В итоге при нажатии на компонент изменится значение в переменной count и соответственно изменится текст компонента Text.

![](https://metanit.com/kotlin/jetpack/pics/2.13.png)


# Переопределение и объединение модификаторов

Модификаторы по умолчанию и переопределение модификаторов
Большинство (если не все) компонентов принимают модификатор через один из своих параметров. При этом для многих из подобных компонентов применяется некоторый модификатор по умолчанию. Если мы явным образом не передаем компоненту никаких функций-модификаторов, то применяется модификатор по умолчанию. И мы можем делать подобным образом при определении своих компонентов. Рассмотрим простейший пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.Composable
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Message("Hello METANIT.COM")
        }
    }
}
 
@Composable
fun Message(text:String, textModifier:Modifier=Modifier.fillMaxWidth().padding(10.dp)){
    Text(text, textModifier, fontSize = 28.sp, textAlign = TextAlign.Center)
}
```

Здесь определен компонент Message, который по сути является оберткой над встроенным компонентом Text. Функция Message принимает два параметра: выводимый текст и функции модификатора:

```kotlin
fun Message(text:String, textModifier:Modifier=Modifier.fillMaxWidth().padding(10.dp)){
```

Второй параметр имеет значение по умолчанию - модификатор, который устанавливает растяжение по всей ширине экрана и отступ в 10 пикселей от границ контейнера. Таким образом, мы можем передавать модификатор через второй параметр, либо не передавать (если он не нужен).

В методе setContent() вызываем компонент Message, не передавая ему никаких модификаторов:

```kotlin
Message("Hello METANIT.COM")
```

В итоге будет применяться модификатор по умолчанию:

![](https://metanit.com/kotlin/jetpack/pics/3.22.png)

Теперь переопределим модификатор по умолчанию:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.Composable
 
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val myModifier = Modifier
                .fillMaxWidth()
                .padding(10.dp)
                .border(width = 2.dp, color = Color.DarkGray)
                .background(Color.LightGray)
                .padding(20.dp)
            Message("Hello METANIT.COM", myModifier)
        }
    }
}
 
@Composable
fun Message(text:String, textModifier:Modifier =Modifier.fillMaxWidth().padding(10.dp)){
    Text(text, textModifier, fontSize = 28.sp, textAlign = TextAlign.Center)
}
```

В данном случае в компонент Message передается модификатор myModifier, который устанавливает границу, фон и отступы от границ контейнера

![](https://metanit.com/kotlin/jetpack/pics/3.23.png)

## Объединение модификаторов

Может возникнуть ситуация, когда к компоненту необходимо применить несколько модификаторов. Например, если мы определяем набор модификаторов по умолчанию, которые в любом случае применяются к компоненту, но также хотим, чтобы динамически при вызове компонента в него также передавалиь еще какие-нибудь модификаторы. Для объединения модификаторов у объекта Modifier применяется метод then. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.runtime.Composable
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val customModifier = Modifier
                .border(width = 2.dp, color = Color.DarkGray, shape= CircleShape)
                .clip(shape= CircleShape)
                .background(Color.LightGray)
                .padding(20.dp)
            Message("Hello METANIT.COM", customModifier)
        }
    }
}
 
@Composable
fun Message(text:String, textModifier: Modifier=Modifier){
    val defaultModifier = Modifier.fillMaxWidth().padding(10.dp)
    Text(text, defaultModifier.then(textModifier), fontSize = 28.sp, textAlign = TextAlign.Center)
}
```
Здесь компонент Message также принимает два параметра: выводимый текст и функции модификатора, которые по умолчанию равны пустому модификатору.

```kotlin
fun Message(text:String, textModifier: Modifier=Modifier){
```

Таким образом, мы можем передавать модификатор через второй параметр, либо не передавать. Внутри функции Message создается модификатор по умолчанию, который растягивает компонент по всей ширине и устанавливает отступы от границ контейнера в 10 пикселей:

```kotlin
val defaultModifier = Modifier.fillMaxWidth().padding(10.dp)
```

Затем вызываем компонент Text, устанавливая у него текст, модификаторы и выравнивание текста по центру:

```kotlin
Text(text, defaultModifier.then(textModifier), fontSize = 28.sp, textAlign = TextAlign.Center)
```

При этом происходит объединение модификаторов - к defaultModifier присоединяются модификаторы из textModifier:

```kotlin
defaultModifier.then(textModifier)
```

В методе setContent() вызываем компонент Message, передавая ему модификатор customModifier:

```kotlin
val customModifier = Modifier
    .border(width = 2.dp, color = Color.DarkGray, shape= CircleShape)
    .clip(shape= CircleShape)
    .background(Color.LightGray)
    .padding(20.dp)
Message("Hello METANIT.COM", customModifier)
```

Кастомный модификатор customModifier устанавливает границу, получает округлый сегмент компонента и задает цвет и отступ от границы до содержимого. В конечном итоге defaultModifier объединяется с customModifier:

![](https://metanit.com/kotlin/jetpack/pics/3.24.png)

# Переопределение и объединение модификаторов

## Модификаторы по умолчанию и переопределение модификаторов
Большинство (если не все) компонентов принимают модификатор через один из своих параметров. При этом для многих из подобных компонентов применяется некоторый модификатор по умолчанию. Если мы явным образом не передаем компоненту никаких функций-модификаторов, то применяется модификатор по умолчанию. И мы можем делать подобным образом при определении своих компонентов. Рассмотрим простейший пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.Composable
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Message("Hello METANIT.COM")
        }
    }
}
 
@Composable
fun Message(text:String, textModifier:Modifier=Modifier.fillMaxWidth().padding(10.dp)){
    Text(text, textModifier, fontSize = 28.sp, textAlign = TextAlign.Center)
}
```

Здесь определен компонент Message, который по сути является оберткой над встроенным компонентом Text. Функция Message принимает два параметра: выводимый текст и функции модификатора:

```kotlin
fun Message(text:String, textModifier:Modifier=Modifier.fillMaxWidth().padding(10.dp)){
```

Второй параметр имеет значение по умолчанию - модификатор, который устанавливает растяжение по всей ширине экрана и отступ в 10 пикселей от границ контейнера. Таким образом, мы можем передавать модификатор через второй параметр, либо не передавать (если он не нужен).

В методе setContent() вызываем компонент Message, не передавая ему никаких модификаторов:

```kotlin
Message("Hello METANIT.COM")
```
В итоге будет применяться модификатор по умолчанию:

![](https://metanit.com/kotlin/jetpack/pics/3.22.png)

Теперь переопределим модификатор по умолчанию:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.runtime.Composable
 
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val myModifier = Modifier
                .fillMaxWidth()
                .padding(10.dp)
                .border(width = 2.dp, color = Color.DarkGray)
                .background(Color.LightGray)
                .padding(20.dp)
            Message("Hello METANIT.COM", myModifier)
        }
    }
}
 
@Composable
fun Message(text:String, textModifier:Modifier =Modifier.fillMaxWidth().padding(10.dp)){
    Text(text, textModifier, fontSize = 28.sp, textAlign = TextAlign.Center)
}
```

В данном случае в компонент Message передается модификатор myModifier, который устанавливает границу, фон и отступы от границ контейнера

![](https://metanit.com/kotlin/jetpack/pics/3.23.png)


## Объединение модификаторов
Может возникнуть ситуация, когда к компоненту необходимо применить несколько модификаторов. Например, если мы определяем набор модификаторов по умолчанию, которые в любом случае применяются к компоненту, но также хотим, чтобы динамически при вызове компонента в него также передавалиь еще какие-нибудь модификаторы. Для объединения модификаторов у объекта Modifier применяется метод then. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.runtime.Composable
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val customModifier = Modifier
                .border(width = 2.dp, color = Color.DarkGray, shape= CircleShape)
                .clip(shape= CircleShape)
                .background(Color.LightGray)
                .padding(20.dp)
            Message("Hello METANIT.COM", customModifier)
        }
    }
}
 
@Composable
fun Message(text:String, textModifier: Modifier=Modifier){
    val defaultModifier = Modifier.fillMaxWidth().padding(10.dp)
    Text(text, defaultModifier.then(textModifier), fontSize = 28.sp, textAlign = TextAlign.Center)
}
```
Здесь компонент Message также принимает два параметра: выводимый текст и функции модификатора, которые по умолчанию равны пустому модификатору.

```kotlin
fun Message(text:String, textModifier: Modifier=Modifier){
```
Таким образом, мы можем передавать модификатор через второй параметр, либо не передавать. Внутри функции Message создается модификатор по умолчанию, который растягивает компонент по всей ширине и устанавливает отступы от границ контейнера в 10 пикселей:

```kotlin
val defaultModifier = Modifier.fillMaxWidth().padding(10.dp)
```

Затем вызываем компонент Text, устанавливая у него текст, модификаторы и выравнивание текста по центру:

```kotlin
Text(text, defaultModifier.then(textModifier), fontSize = 28.sp, textAlign = TextAlign.Center)
```

При этом происходит объединение модификаторов - к defaultModifier присоединяются модификаторы из textModifier:

```kotlin
defaultModifier.then(textModifier)
```

В методе setContent() вызываем компонент Message, передавая ему модификатор customModifier:

```kotlin
val customModifier = Modifier
    .border(width = 2.dp, color = Color.DarkGray, shape= CircleShape)
    .clip(shape= CircleShape)
    .background(Color.LightGray)
    .padding(20.dp)
Message("Hello METANIT.COM", customModifier)
```

Кастомный модификатор customModifier устанавливает границу, получает округлый сегмент компонента и задает цвет и отступ от границы до содержимого. В конечном итоге defaultModifier объединяется с customModifier:

![](https://metanit.com/kotlin/jetpack/pics/3.24.png)

