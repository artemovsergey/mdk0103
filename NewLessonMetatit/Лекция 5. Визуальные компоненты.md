# Визуальные компоненты

# Text

Неотъемлемой частью визуального интерфейса является текст. Для отображения текста Jetpack Compose предоставляет ряд встроенных компонентов. Прежде всего это компонент Text, который имеет следующее определение:

```kotlin
@Composable
fun Text(
    text: String,
    modifier: Modifier = Modifier,
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontStyle: FontStyle? = null,
    fontWeight: FontWeight? = null,
    fontFamily: FontFamily? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    textDecoration: TextDecoration? = null,
    textAlign: TextAlign? = null,
    lineHeight: TextUnit = TextUnit.Unspecified,
    overflow: TextOverflow = TextOverflow.Clip,
    softWrap: Boolean = true,
    maxLines: Int = Int.MAX_VALUE,
    minLines: Int = 1,
    onTextLayout: ((TextLayoutResult) -> Unit)? = null,
    style: TextStyle = LocalTextStyle.current
): Unit
```

Параметры компонента:

- text: объект String, который представляет выводимый текст

- modifier: объект Modifier, который представляет применяемые к компоненту модификаторы

- color: объект Color, который представляет цвет текста. По умолчанию имеет значение Color.Unspecified

- fontSize: объект TextUnit, который представляет размер шрифта. По умолчанию равен TextUnit.Unspecified

- fontStyle: объект FontStyle?, который представляет стиль шрифта. По умолчанию равен null

- fontWeight: объект FontWeight?, который представляет толщину шрифта. По умолчанию равен null

- fontFamily: объект FontFamily?, который представляет тип шрифта. По умолчанию равен null

- letterSpacing: объект TextUnit, который представляет отступы между символами. По умолчанию равен TextUnit.Unspecified

- textDecoration: объект TextDecoration?, который представляет тип декораций (например, подчеркивание), применяемых к тексту. По умолчанию равен null

- textAlign: объект TextAlign?, который представляет выравнивание текста. По умолчанию равен null

- lineHeight: объект TextUnit, который представляет высоту строки текста. По умолчанию равен TextUnit.Unspecified

- overflow: объект TextOverflow, который определяет поведение текста при его выходе за границы контейнера. По умолчанию равен TextOverflow.Clip

- softWrap: объект Boolean, который определяет, должен ли текст переносится при завершении строки. При значении false текст не переносится, как будто строка имеет бесконечную длину. По умолчанию равен true

- maxLines: объект Int, который представляет максимальное количество строк. Если текст превысил установленное количество строк, то он усекается в соответствии с параметрами overflow и softWrap. По умолчанию равен Int.MAX_VALUE

- minLines: минимальное количество строк

- onTextLayout: объект (TextLayoutResult) -> Unit, который представляет функцию, выполняемую при определении компоновки текста.

- style: объект TextStyle, который представляет стиль текста. Значение по умолчанию - LocalTextStyle.current

## Размер шрифта
Размер шрифта определяется параметром fontSize. В качестве параметру может передаваться значение типов Int, Double и Float, после которых указывается тип единиц. Это могут быть масштабируемые пиксели (единицы sp, например, 22.sp), либо это может быть относительный размер шрифта в единицах em (например, 18.em). Значение TextUnit.Unspecified указывает, что высота шрифта наследуется от настроек родительного компонента

Простейшее применение компонента:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.foundation.layout.Column
import androidx.compose.ui.unit.em
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Hello Jetpack Compose!", fontSize=25.sp)
                Text("Hello Jetpack Compose!", fontSize=6.em)
            }
        }
    }
}
```

**Цвет шрифта**
За определение цвета шрифта отвечает параметр color, который представляет объект Color, ранее рассмотренный в пункте "Установка цвета".

```kotlin
import androidx.compose.ui.graphics.Color
//..........
Column {
    Text("Hello Jetpack Compose!",  fontSize=22.sp, color=Color.Red)
    Text("Hello Jetpack Compose!",  fontSize=22.sp, 
        color= Color(red = 0x44, green = 0x55, blue = 0x88, alpha = 0xFF))
}
```

## Стиль шрифта
Стиль шрифта определяется параметром fontStyle, который представляет класс FontStyle?. Для определения этот класс предоставляет два встроенных значения:

- FontStyle.Italic (наклоннный шрифт)
- FontStyle.Normal (стандартный шрифт)

```kotlin
import androidx.compose.ui.text.font.FontStyle
//..........
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontStyle = FontStyle.Italic)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontStyle = FontStyle.Normal)
```

## Толщина шрифта
Толщина шрифта задается параметром fontWeight, который представляет класс FontWeight.

Есть два способа установки толщины шрифта. Прежде всего можно использовать конструктор этого класса, в который передается числовое значение от 1 до 1000. Чем больше значение, тем толще будет шрифт:

```kotlin
FontWeight(600)
```
Второй способ заключается в применении встроенных значений:

- FontWeight.Black (Эквивалентно значению W900)
- FontWeight.Bold (Эквивалентно значению W700)
- FontWeight.ExtraBold (Эквивалентно значению W800)
- FontWeight.ExtraLight (Эквивалентно значению W200)
- FontWeight.Light (Эквивалентно значению W300)
- FontWeight.Medium (Эквивалентно значению W500)
- FontWeight.Normal (Эквивалентно W400 - значение по умолчанию)
- FontWeight.SemiBold (Эквивалентно значению W600)
- FontWeight.Thin (Эквивалентно значению W100

Так, следующие определения компонента Text будут аналогичны:

```kotlin
import androidx.compose.ui.text.font.FontWeight
//..........
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight.Bold)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight.W700)
Text("Hello Jetpack Compose!",  fontSize=22.sp, fontWeight= FontWeight(700))
```

### Тип шрифта
Тип или семейство шрифта определяется параметром fontFamily, который представляет объект FontFamily?

Для определения шрифта FontFamily предоставляет ряд встроенных констант:

- FontFamily.Cursive (курсивный, рукописный шрифт)
- FontFamily.Monospace
- FontFamily.Serif
- FontFamily.SansSerif
- FontFamily.Default (шрифт по умолчанию на текущей платформе)
- FontFamily.SansSerif

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily= FontFamily.Cursive)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Monospace)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.SansSerif)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Serif)
                Text("Hello METANIT.COM", fontSize=28.sp, fontFamily=FontFamily.Default)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.1.png)


## Расстояния между символами
Параметр letterSpacing задает расстояние между символами и представляет класс TextUnit. В данном случае мы можем установить расстояние, так как и размер шрифта, с помощью единиц sp или em:

```kotlin
Text("Hello Jetpack Compose!",  fontSize=22.sp, letterSpacing= 1.3.sp)
Text("Hello Jetpack Compose!",  fontSize=22.sp, letterSpacing= 0.3.em)
```

## Декорации текста
Параметр textDecoration позволять задать декорации для текста. Данный параметр принимает объект класса TextDecoration, который предоставляет несколько встроенных значений:

- TextDecoration.LineThrough (зачеркивает текст)
- TextDecoration.Underline (подчеркивает текст)
- TextDecoration.None (отсутствие декораций)

```kotlin
import androidx.compose.ui.text.style.TextDecoration
//...........
Column {
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.LineThrough)
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.Underline)
    Text("Hello Jetpack Compose!",  fontSize=28.sp, textDecoration = TextDecoration.None)
}  
```

![](https://metanit.com/kotlin/jetpack/pics/4.61.png)

### Выравнивание текста
Параметр textAlign управляет выравниванием текста и представляет объект класса TextAlign. В качестве значения этому параметру можно передать значение одного из свойств класса TextAlign:

- TextAlign.Center: выравнивание текста по центру контейнера
- TextAlign.Justify: текст равномерно растягивается по всей ширине контейнера
- TextAlign.End: выравнивание текста по конечному краю контейнера (в зависимости от ориентации текста это может быть левый или правый край)
- TextAlign.Start: выравнивание текста по началу контейнера (в зависимости от ориентации текста это может быть левый или правый край)
- TextAlign.Left: выравнивание текста по левому краю контейнера
- TextAlign.Right: выравнивание текста по правому краю контейнера

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column {
                Text("Center", modifier = Modifier.fillMaxWidth(1f) , fontSize=28.sp, textAlign = TextAlign.Center)
                Text("Justify", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Justify)
                Text("Left", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Left)
                Text("Right", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Right)
                Text("Start", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.Start)
                Text("End", modifier = Modifier.fillMaxWidth(1f), fontSize=28.sp, textAlign = TextAlign.End)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.2.png)


## Усечение текста
Параметр overflow управляет тем, как будет обрабатываться текст при его выходе за границы контейнера. Этот параметр принимает значение класса TextOverflow. В качестве значения параметру можно передать значение одного из свойств данного класса:

- TextOverflow.Clip: выходящий за границы контейнера текст усекается
- TextOverflow.Ellipsis: текст усекается, а в конце текста добавляется многоточие
- TextOverflow.Visible: весь текст может отображаться

## Перенос текста
Параметр softWrap управляет переносом текста. Если он равен true, то текст переносится. Если false, то нет.

## Стиль текста
Параметр style управляет стилем текста. Он предоставляет класс TextStyle , который по сути объединяет ряд вышеупомянутых и несколько дополнительных параметров в одну сущность. Он несколько конструкторов с кучей параметров, например, один из них:

```kotlin
TextStyle(
    color: Color,
    fontSize: TextUnit,
    fontWeight: FontWeight?,
    fontStyle: FontStyle?,
    fontSynthesis: FontSynthesis?,
    fontFamily: FontFamily?,
    fontFeatureSettings: String?,
    letterSpacing: TextUnit,
    baselineShift: BaselineShift?,
    textGeometricTransform: TextGeometricTransform?,
    localeList: LocaleList?,
    background: Color,
    textDecoration: TextDecoration?,
    shadow: Shadow?,
    drawStyle: DrawStyle?,
    textAlign: TextAlign,
    textDirection: TextDirection,
    lineHeight: TextUnit,
    textIndent: TextIndent?,
    platformStyle: PlatformTextStyle?,
    lineHeightStyle: LineHeightStyle?,
    lineBreak: LineBreak,
    hyphens: Hyphens,
    textMotion: TextMotion?
)
```

Основные параметры конструктора в принципе дублируют стандартные свойства компонента Text:

- color: объект Color, который представляет цвет текста. По умолчанию имеет значение Color.Unspecified
- background: объект Color, который фоновый цвет компонента. По умолчанию имеет значение Color.Unspecified
- fontSize: объект TextUnit, который представляет размер шрифта. По умолчанию равен TextUnit.Unspecified
- fontStyle: объект FontStyle?, который представляет стиль шрифта. По умолчанию равен null
- fontWeight: объект FontWeight?, который представляет толщину шрифта. По умолчанию равен null
- fontFamily: объект FontFamily?, который представляет тип шрифта. По умолчанию равен null
- fontFeatureSettings: объект String?, который определяет, как будут применяться настройки толщины шрифта и его наклон (то есть значения параметров fontWeight и fontStyle), если используемый шрифт не поддерживает выделение жирным и (или) наклон. По умолчанию равен null
- letterSpacing: объект TextUnit, который представляет отступы между символами. По умолчанию равен TextUnit.Unspecified
- baselineShift: объект BaselineShift?, который определяет, насколько текст будет сдвигаться относительно базовой линии (baseline). По умолчанию равен null
- textGeometricTransform: представляет применяемые к тексту геометрические трансформации в виде объекта TextGeometricTransform?. По умолчанию равен null
- localeList: объект LocaleList?, который представляет список со специфичными для егиона символами. По умолчанию равен null
- textDecoration: объект TextDecoration?, который представляет тип декораций (например, подчеркивание), применяемых к тексту. По умолчанию равен null
- textAlign: объект TextAlign?, который представляет выравнивание текста. По умолчанию равен null
- textDirection: объект TextDirection?, который представляет направление текста. По умолчанию равен null
- lineHeight: объект TextUnit, который представляет высоту строки текста. По умолчанию равен TextUnit.Unspecified
- shadow: объект Shadow?, который определяет применяемый к тексту эффект тени. По умолчанию равен null

textIndent: объект TextIndent?, который представляет отступ от начала текста. По умолчанию равен null

Поскольку большая часть этих параметров применяется непосредственно в функции компонента Text, рассмотрим некоторые параметры, которые отстуствуют в функции компонента Text.

### Геометрические трансформации

Параметр TextGeometricTransform задает геометрические трансформации текста с помощью объекта TextGeometricTransform:

```kotlin
TextGeometricTransform(scaleX: Float = 1.0f, skewX: Float = 0f)
```

Первый параметр - scaleX указывает на увеличение текста. Если значение меньше 1.0f, то текст сжимается, если больше - то увеличивается.

Второй параметр - skewX указывает на сдвиг текста. Например, точка с координатами (x, y), будет трансформирована в точку (x + y * skewX, y). Значение по умолчанию - 0.0f. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextGeometricTransform
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val content = "Все мы сейчас желаем кушать, потому что утомились"
            val textSize = 25.sp
            Column {
                Text(
                    content,
                    fontSize = textSize,
                    style = TextStyle(textGeometricTransform = TextGeometricTransform(0.5f))
                )
                Text(
                    content,
                    fontSize = textSize,
                    style = TextStyle(textGeometricTransform = TextGeometricTransform(1.5f))
                )
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.4.png)

### Создание тени для текста
Параметр shadow задает затенение текста с помощью объекта Shadow:

```kotlin
Shadow(color: Color, offset: Offset, blurRadius: Float)
```

Первый параметр - color устанавливает цвет тени.

Второй параметр - offset смещение тени в виде объекта Offset.

Третий параметр - blurRadius задает радиус размытия.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shadow
import androidx.compose.ui.text.TextStyle
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(text = "Hello Metanit.com",
                fontSize = 30.sp,
                style = TextStyle(shadow = Shadow(Color.LightGray , Offset(10.0f, 16.5f), 1.0f)))
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.5.png)

### Направление текста
Параметр textDirection устанавливает направление текста и может принимать следующие значения:

- TextDirection.Content: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm

- TextDirection.ContentOrLtr: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm, либо представляет направление слева направо

- TextDirection.ContentOrRtl: направление текста зависит от первого направляющего символа в соответствии с алгоритмом Unicode Bidirectional Algorithm, либо представляет направление справа налево

- TextDirection.Ltr: текс направлен слева направо

- TextDirection.Rtl: текст направлен справо налево

Например:

```kotlin
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextDirection
//............
Text(
    "Все мы сейчас желаем кушать, потому что утомились",
    fontSize=22.sp,
    style = TextStyle(textDirection = TextDirection.Rtl)
)
```

## TextIndent

Параметр textIndent позволяет установить отступ от первого символа в тексте и от остального текста. Этот параметр представляет класс TextIndent, конструктор которого принимает два значения. Первое значение указывает на отступ от первого символа. Второе значение применяется, если текст многострочный и устанавливает отступ от остальных символов на второй и последующих строках. Для установки отступа применяются единицы sp. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.ui.unit.sp
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.style.TextIndent
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                text = "Все мы сейчас желаем кушать, потому что утомились и уже четвертый час",
                fontSize = 22.sp,
                style = TextStyle(textIndent = TextIndent(50.sp, 25.sp))
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.3.png)









# Аннотированные строки

Аннотированные строки (Annotated strings) позволяют разбить текст на сегменты, каждый из которых будет иметь свою собственную стилизацию. Аннотированные строки представляют объект AnnotatedString. Для его создания применяется функция buildAnnotatedString(), которой передается отображаемый текст и стили.

Поддерживаются два типа стилей: SpanStyle и ParagraphStyle

## SpanStyle
Первый тип стилей представляет объект SpanStyle и используется для стилизации отдельных символов в строке. SpanStyle имеет следующий конструктор:

```kotlin
SpanStyle(
    color: Color = Color.Unspecified,
    fontSize: TextUnit = TextUnit.Unspecified,
    fontWeight: FontWeight? = null,
    fontStyle: FontStyle? = null,
    fontSynthesis: FontSynthesis? = null,
    fontFamily: FontFamily? = null,
    fontFeatureSettings: String? = null,
    letterSpacing: TextUnit = TextUnit.Unspecified,
    baselineShift: BaselineShift? = null,
    textGeometricTransform: TextGeometricTransform? = null,
    localeList: LocaleList? = null,
    background: Color = Color.Unspecified,
    textDecoration: TextDecoration? = null,
    shadow: Shadow? = null,
    platformStyle: PlatformSpanStyle? = null,
    drawStyle: DrawStyle? = null
)
```

Из конструктора мы видим, какие параметры текста устанавливает SpanStylе:

- color: цвет текста

- fontSize: высота шрифта

- fontWeight: вес шрифта.

- fontStyle: стиль шрифта.

- fontSynthesis: устанавливает синтез толщины и/или стиля шрифта, если запрошенную толщину или стиль невозможно найти в предоставленном семействе шрифтов.

- fontFamily: семейство шрифтов.

- fontFeatureSettings: настройки типографии шрифта

- letterSpacing: расстояние между буквами.

- baselineShift: величина, на которую сдвигается текст вверх относительно базовой линии.

- textGeometricTransform: применяемые к тексту геометрические трансформации.

- localeList: список локалей, который используется для выбора специфичных для языка глифов

- background: фоновый цвет текста.

- textDecoration: декорации текста.

- shadow: тень текста.

- platformStyle: платформозависимые параметры стиля.

- drawStyle: стиль заполнения текста.

Для создания и применения SpanStyle используется следующий синтаксис:

```kotlin
buildAnnotatedString {
 
    withStyle(style = SpanStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    withStyle(style = SpanStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    ...................................
}
```

Для добавления сегмента в текст применяется функция append(), в которую передается добавляемая подстрока. Если append() вызывается в контексте функции withStyle(), то к добавляемому тексту применяется стилизация определенная с помощью SpanStyle.

Применение SpanStyle:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
 
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.SpanStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                buildAnnotatedString {
                    withStyle(SpanStyle(fontWeight = FontWeight.Bold, fontSize = 30.sp)) {
                        append("H")
                    }
                    append("ello ")
 
                    withStyle(SpanStyle(fontWeight = FontWeight.Bold, fontSize = 23.sp, color = Color.Blue)) {
                        append("METANIT.COM")
                    }
                }
            )
        }
    }
}
```

В данном случае текст разбивается на три сегмента. Первый сегмент состоит из одной буквы "H", к которой применяется некоторое форматирование. Второй сегмент - "ello" не использует никакого форматирования и добавляется в текст как есть. И затем добавляется третий сегмент, к которому также применяется некоторая стилизация:

![](https://metanit.com/kotlin/jetpack/pics/4.88.png)

## ParagraphStyle
Второй способ стилизации предоставляет класс ParagraphStyle. Он применяется к отдельным параграфам и имеет следующие параметры:

```kotlin
ParagraphStyle(
    textAlign: TextAlign = TextAlign.Unspecified,
    textDirection: TextDirection = TextDirection.Unspecified,
    lineHeight: TextUnit = TextUnit.Unspecified,
    textIndent: TextIndent? = null,
    platformStyle: PlatformParagraphStyle? = null,
    lineHeightStyle: LineHeightStyle? = null,
    lineBreak: LineBreak = LineBreak.Unspecified,
    hyphens: Hyphens = Hyphens.Unspecified,
    textMotion: TextMotion? = null
)
```

- textAlign: выравнивание текста в параграфе
- textDirection: направление текста (слева направо или справо налево)
- lineHeight: высота строк
- textIndent: настройки отступа в параграфе
- platformStyle: платформо-зависимые параметры
- lineHeightStyle: конфигурация для установки высоты строк. Применяется, если параметр lineHeight установлен
- lineBreak: настройка разрыва строк
- hyphens: настройки переносов
- textMotion: настройки размещения текстовых символов, оптимизация для анимированного или статического текста.

Для создания и применения ParagraphStyle используется следующий синтаксис:

```kotlin
buildAnnotatedString {
 
    withStyle(style = ParagraphStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    withStyle(style = ParagraphStyle( настройки_стилей)) { 
        append(стилизуемый_текст)
    }
 
    ...................................
}
```

Применение ParagraphStyle:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
 
import androidx.compose.ui.text.ParagraphStyle
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.style.TextIndent
import androidx.compose.ui.text.withStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Text(
                buildAnnotatedString {
                    append("Все мы сейчас желаем кушать, потому что утомились и уже четвертый час, но это")
                    withStyle(ParagraphStyle(lineHeight = 25.sp, textIndent = TextIndent(firstLine = 30.sp, restLine = 8.sp))) {
                        append("Все мы сейчас желаем кушать, потому что утомились и уже четвертый час, но это")
                    }
                },
                fontSize = 22.sp)
        }
    }
}
```

Здесь определены два идентифных параграфа/абзаца, но ко второму применяется дополнительная стилизация, в частности, отступы в 30 пикселей для первой строки и 8 пикселей для остальных строк, а также 25 пикселей высота строки.

![](https://metanit.com/kotlin/jetpack/pics/4.89.png)





















































# Кнопка Button

Для создания кнопок в Jetpack Compose применяется компонент Button, который имеет следующее определение:

```kotlin
@Composable
fun Button(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.shape,
    colors: ButtonColors = ButtonDefaults.buttonColors(),
    elevation: ButtonElevation? = ButtonDefaults.buttonElevation(),
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Параметры функции компонента:

- onClick: представляет функцию-обработчик нажатия кнопки
- modifier: представляет объект Modifier, который определяет модификаторы кнопки
- enabled: значение типа Boolean устанавливает, доступна ли кнопка для нажатия. По умолчанию равно true (то есть кнопка доступна для нажатия)
- interactionSource: представляет объект типа MutableInteractionSource, который устанавливает поток взаимодействий для кнопки. Значение по умолчанию - remember { MutableInteractionSource() }
- elevation: объект типа ButtonElevation?, который определяет анимацию для кнопки. По умолчанию равно ButtonDefaults.elevation()
- shape: объект типа Shape, который устанавливает форму кнопки. По умолчанию равно MaterialTheme.shapes.small
- border: объект типа BorderStroke?, который устанавливает границу кнопки. По умолчанию равно null
- colors: объект типа ButtonColors, который устанавливает цвета кнопки. По умолчанию равно ButtonDefaults.buttonColors()
- contentPadding: объект типа PaddingValues, который устанавливает отступы между границами кнопки и ее содержимым. По умолчанию равно ButtonDefaults.ContentPadding
- content: содержимое кнопки в виде строки Row

Определим простейшую кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {}){
                Text("Click", fontSize = 25.sp)
            }
        }
    }
}
```

Здесь надо отметить следующие моменты. Прежде всего, необходимо определить как минимум один параметр - onClick, однако в данном случае это пустая функция, которая ничего не делает.

Второй момент - кнопка представляет сложный компонент, который может содержать другие компоненты. Таким образом мы можем создавать комплексные кнопки с различным содержимым. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.Alignment
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},)
            {
                Column(horizontalAlignment = Alignment.CenterHorizontally){
                    Text("Button Header", fontSize = 18.sp)
                    Text("Button Text", fontSize = 25.sp)
                    Text("Button footer", fontSize = 18.sp)
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.11.png)

### Обработка нажатия
Для обработки нажатия параметру onClick передается функция, которая будет выполняться при нажатии.

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val label = remember{mutableStateOf("Click")}
            Button(onClick = {label.value = "Hello"}){
                Text(label.value, fontSize = 28.sp)
            }
        }
    }
}
```

В данном случае мы определяем переменную label, которая будет хранить текст для компонента Text. Однако это не просто строка - объект типа String, а объект MutableState<T>, который создается функцией mutableStateOf(). В эту функцию передается собственно хранимое значение, которое затем можно получить с помощью свойства value объекта MutableState<T> и которое в данном случае мы отображаем в компоненте Text:

```kotlin
Text(label.value, fontSize = 25.sp)
```

А в обработчике нажатия мы изменяем это значение:

```kotlin
onClick = {label.value = "Hello"}
```

В итоге при нажатии на кнопку изменится ее текст.

![](https://metanit.com/kotlin/jetpack/pics/4.7.png)


## Форма кнопки

Как видно из предыдущих скриншотов, по умолчанию кнопка имеет округлую форму. Но с помощью параметра shape можно задать любую другую форму, которая представляет объект интерфейса Shape. Например, для создания прямоугольной формы можно использовать встроенный объект RectangleShape. Для создания кнопки с закругленными углами можно использовать встроенный класс RoundedCornerShape, в конструктор которого передается радиус закругления:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material3.Button
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.RectangleShape
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Column{
                Button(onClick = {},
                    shape = RectangleShape,     // прямоугольная кнопка
                    modifier = Modifier.padding(10.dp)
                ){ Text("Button 1", fontSize = 28.sp) }
 
                Button(onClick = {},
                    shape = RoundedCornerShape(15.dp),  // округлая кнопка
                    modifier = Modifier.padding(10.dp)
                ){ Text("Button 2", fontSize = 28.sp) }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.63.png)


## elevation
Параметр elevation определяет анимацию для кнопки в разных состояниях и представляет объект интерфейса ButtonElevation. По умолчанию этот параметр в качестве значения имеет компонент ButtonDefaults.elevation:

```kotlin
@Composable
fun elevation(
    defaultElevation: Dp = 2.dp,
    pressedElevation: Dp = 8.dp,
    disabledElevation: Dp = 0.dp
): @Composable ButtonElevation
```

Этот компонент определяет ряд параметров, между значениями которых будет идти анимация при переключении состояния кнопки:

- defaultElevation: определяет анимацию, когда кнопка доступна для нажатия и когда для нее не определено других объектов Interaction, которые определяют состояние для кнопки.
- pressedElevation: определяет анимацию для кнопки в нажатом состоянии.
- defaultElevation: определяет анимацию для кнопки в отключенном состоянии.

## Цвета кнопки
Цвета кнопки задаются с помощью параметра colors, который предоставляет объект ButtonColors и по умолчанию равен компоненту ButtonColors.buttonColors:

```kotlin
@Composable
public final fun buttonColors(
    containerColor: Color = FilledButtonTokens.ContainerColor.toColor(),
    contentColor: Color = FilledButtonTokens.LabelTextColor.toColor(),
    disabledContainerColor: Color = FilledButtonTokens.DisabledContainerColor.toColor()                 
        .copy(alpha = FilledButtonTokens.DisabledContainerOpacity),
    disabledContentColor: Color = FilledButtonTokens.DisabledLabelTextColor.toColor()             
        .copy(alpha = FilledButtonTokens.DisabledLabelTextOpacity)
): ButtonColors
```

- containerColor: определяет фоновый цвет, когда кнопка доступна для нажатия.
- contentColor: определяет цвет содержимого, когда кнопка доступна для нажатия.
- disabledBackgroundColor: определяет фоновый цвет, когда кнопка не доступна для нажатия.
- disabledContentColor: определяет цвет содержимого, когда кнопка не доступна для нажатия.

Для установки цветов кнопки мы можем создать свой класс или компонент интерфейса ButtonColors, либо воспользоваться встроенным компонентом ButtonDefaults.buttonColors. Применим второй способ:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},
                colors = ButtonDefaults.buttonColors(
                    contentColor = Color(0xff004D40),       // цвет текста
                    containerColor = Color(0xff9ed6df))     // цвет фона
            ){ Text("Click", fontSize = 28.sp) }
        }
    }
}
```

Здесь в качестве фонового цвета применяется красный, а в качестве цвета содержимого - черный:

![](https://metanit.com/kotlin/jetpack/pics/4.9.png)

## Граница кнопки
За установки границы кнопки (а именно ее толщины и цвета) отвечает параметр border, который представляет класс BorderStroke со следующими конструкторами:

```kotlin
BorderStroke(width: Dp, color: Color)
BorderStroke(width: Dp, brush: Brush)
```

Первый параметр конструкторов устанавливает толщину границы, а второй - ее цвет с помощью объекта Brush или Color. Например, определим границу у кнопку:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.BorderStroke
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Button(onClick = {},
                colors = ButtonDefaults.buttonColors(containerColor = Color.LightGray, contentColor = Color.Black),
                border = BorderStroke(3.dp, Color.DarkGray)
            ){ Text("Click", fontSize = 28.sp) }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.10.png)

## OutlinedButton
Компонент OutlinedButton также представляет кнопку и имеет тот же набор параметров:

```kotlin
@Composable
fun OutlinedButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.outlinedShape,
    colors: ButtonColors = ButtonDefaults.outlinedButtonColors(),
    elevation: ButtonElevation? = null,
    border: BorderStroke? = ButtonDefaults.outlinedButtonBorder,
    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Он работает похожим образом. Главное отличие от стандартных кнопок - немного иная стилизация, которая по умолчанию добавляет ярко выраженную границу компонента и применяет иную цветоую гамму. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedButton
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            OutlinedButton({}){
                Text("Hello", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.28.png)


## TextButton
Компонент TextButton представляет еще один встроенный тип кнопок, который не имеет границы и имеет прозрачный фон. Он имеет тот же набор параметров, что и Button и OutlinedButton:

```kotlin
@Composable
fun TextButton(
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    shape: Shape = ButtonDefaults.textShape,
    colors: ButtonColors = ButtonDefaults.textButtonColors(),
    elevation: ButtonElevation? = null,
    border: BorderStroke? = null,
    contentPadding: PaddingValues = ButtonDefaults.TextButtonContentPadding,
    interactionSource: MutableInteractionSource? = null,
    content: @Composable RowScope.() -> Unit
): Unit
```

Используем TextButton:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            TextButton({}){
                Text("Hello", fontSize = 28.sp)
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.29.png)









































# Ввод текста, TextField и OutlinedTextField

Для ввода текста в приложении предназначен компонент TextField. Он имеет несколько версий, возьмем одну из них:

```kotlin
@Composable
fun TextField(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    readOnly: Boolean = false,
    textStyle: TextStyle = LocalTextStyle.current,
    label: (@Composable () -> Unit)? = null,
    placeholder: (@Composable () -> Unit)? = null,
    leadingIcon: (@Composable () -> Unit)? = null,
    trailingIcon: (@Composable () -> Unit)? = null,
    prefix: (@Composable () -> Unit)? = null,
    suffix: (@Composable () -> Unit)? = null,
    supportingText: (@Composable () -> Unit)? = null,
    isError: Boolean = false,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    keyboardActions: KeyboardActions = KeyboardActions.Default,
    singleLine: Boolean = false,
    maxLines: Int = if (singleLine) 1 else Int.MAX_VALUE,
    minLines: Int = 1,
    interactionSource: MutableInteractionSource? = null,
    shape: Shape = TextFieldDefaults.shape,
    colors: TextFieldColors = TextFieldDefaults.colors()
): Unit
```

Основные параметры компонента:

- value: представляет введенное в текстовое поле значение в виде строки, то есть объекта String
- onValueChange: функция обработки изменения введенного значения. Представляет функцию типа (String) -> Unit

- modifier: объект типа Modifier, который задает модификаторы компонента

- enabled: устанавливает, будет ли поле доступно для ввода. Представляет значение типа Boolean. По умолчанию равно true, то есть поле доступно для ввода

- readOnly: устанавливает, будет ли поле доступно только для чтения. Представляет значение типа Boolean. По умолчанию равно false, то есть поле доступно не только для чтения, но для изменения значения

- textStyle: объект типа TextStyle, который устанавливает стиль текста. Значение по умолчанию - LocalTextStyle.current

- label: устанавливает дополнительную метку, которая отображается внутри поля. Для установки метки применяется функция типа () -> Unit. Значение по умолчанию - null

- placeholder: плейсхолдер - временный текст, который отображается внутри поля. Для установки этого текста применяется функция типа () -> Unit. Значение по умолчанию - null

- leadingIcon: устанавливает иконку, которая отображается перед текстом. Для установки применяется функция типа () -> Unit. Значение по умолчанию - null

- trailingIcon: устанавливает иконку, которая отображается после текста. Для установки применяется функция типа () -> Unit. Значение по умолчанию - null

- isError: указывает, является ли текущее введенное в поле значение некорректным. Представляет значение типа Boolean. По умолчанию равно false, то есть введенное значение корректно. Если равно true, то для поля устанавливаютс соответствующие индикаторы - метка, иконка, выделение цветом, которые поддчеркивают, что введенное значение некорректно.

- visualTransformation: объект типа VisualTransformation, который задает визуальные трансформации для вводимого текста. Значение по умолчанию - VisualTransformation.None

- keyboardOptions: объект KeyboardOptions, который задает параметры клавиатуры (например, ее тип). Значение по умолчанию - KeyboardOptions.Default

- keyboardActions: KeyboardActions, который задает набор функций, которые вызываются в ответ на некоторые действия пользователя. Значение по умолчанию - KeyboardActions()

- singleLine: устанавливает, будет ли текст однострочным. По умолчанию равно false, то есть поле будет многосточным

- maxLines: задает максимальное количество строк в поле. По умолчанию равно Int.MAX_VALUE

- minLines: задает минимальное количество строк в поле. По умолчанию равно 1

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для поля ввода. Значение по умолчанию - remember { MutableInteractionSource() }

- shape: представляет объект Shape, который задает форму для поля ввода. Значение по умолчанию - MaterialTheme.shapes.small.copy(bottomEnd = ZeroCornerSize, bottomStart = ZeroCornerSize)

- colors: объект TextFieldColors, который задает цвета для поля ввода. Значение по умолчанию - TextFieldDefaults.textFieldColors()

Определение простейшего поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.TextField
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            TextField(value = "Hello Work", onValueChange = {})
        }
    }
}
```

При создании поля необходимо задать как минимум два параметра - текущее значение (параметр value) и функцию обработки ввода текста (параметр onValueChange).

![](https://metanit.com/kotlin/jetpack/pics/4.12.png)

## Обработка ввода текста
Параметр onValueChange принимает функцию обработки ввода текста. Она в качестве параметра получает введенный тек

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
 
            Column {
                Text(message.value, fontSize = 28.sp)
                TextField(
                    value = message.value,
                    textStyle = TextStyle(fontSize=25.sp),
                    onValueChange = {newText -> message.value = newText}
                )
            }
        }
    }
}
```

В данном случае мы определяем переменную message, которая будет хранить введенный текст. Однако это не просто строка. Она будет представлять объект типа MutableState<String>, который создается функцией mutableStateOf(). В дальнейшем мы подробнее разберем объект MutableState и функцию mutableStateOf, а пока достуточно знать, что в эту функцию передается собственно хранимое значение, которое затем можно получить с помощью свойства value объекта MutableState<T>. А функция remember позволяет сохранить это значение.

В коде с помощью свойства value мы привязываем значение переменной к свойству text компонента Text и свойству value компонента TextField:

```kotlin
Text(message.value, fontSize = 28.sp)
TextField( value = message.value,
```
А в функции обработки ввода текста передаем в переменную введенный текст:

```kotlin
onValueChange = {newText -> message.value = newText}
```

В данном случае функция задается с помощью лямбда-выражения, где параметр newText представляет введенный текст.

В итоге при ввода текста в поле изменится значение в переменной message и соответственно изменится текст компонента Text.

![](https://metanit.com/kotlin/jetpack/pics/4.13.png)

## Тип клавиатуры
В зависимости от задач приложения может потребоваться вводить разную информацию - когда буквы, когда числа и т.д. Для упрощения ввода Jetpack Compose предоставляет тип 

- KeyboardType, который позволяет настроить тип клавиатуры с помощью своих свойств:

- KeyboardType.Ascii: предоставляет ввод символов ASCII

- KeyboardType.Email: для ввода электронного адреса

- KeyboardType.Number: для ввода цифр

- KeyboardType.NumberPassword: для ввода пароля из цифр

- KeyboardType.Password: для ввода пароля

- KeyboardType.Phone: для ввода номера телефона

- KeyboardType.Text: предоставляет стандартную клавиатуру

- KeyboardType.Uri: предоставляет клавиатуру для ввода URI

С помощью параметра keyboardOptions, который представляет класс KeyboardOptions, можно задать тип клавиатуры. Например, применим клавиатуру для ввода номера телефона:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val phone = remember{mutableStateOf("")}
 
            TextField(
                phone.value,
                {phone.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.14.png)

## Установка иконок
Параметр leadingIcon задает иконку перед текстом, а параметр trailingIcon - иконку после текста. В качестве значения оба параметра принимают функцию типа () -> Unit. Определим иконки для поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Info
import androidx.compose.material3.Icon
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
 
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                leadingIcon = { Icon(Icons.Filled.Check, contentDescription = "Проверено") },
                trailingIcon = { Icon(Icons.Filled.Info, contentDescription = "Дополнительная информация") }
            )
        }
    }
}
```
Для определения иконок применяется встроенный тип androidx.compose.material.Icon, в функцию которого передается значок иконки. В данном случае применяются встроенные иконки Icons.Filled.Check и Icons.Filled.Info. Второй параметр - contentDescription позволяет указать к иконке описание.

![](https://metanit.com/kotlin/jetpack/pics/4.15.png)

## Плейсхолдер
Параметр placeholder устанавливает плейсхолдер или заменитель текста, отображаемый в поле ввода, в виде другого компонента:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("")}
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                placeholder = { Text("Hello Work!") }
            )
        }
    }
}
```

Установка цветовой палитры поля ввода
Параметр colors, который представляет объект интерфейса TextFieldColors, задает цвета для поля ввода. По умолчанию он принимает компонент TextFieldDefaults.textFieldColors()/TextFieldDefaults.colors(), который устанавливает цвета для самых различных состояний:

- focusedTextColor: цвет, используемый для ввода текста этого текстового поля при фокусировке.
- unfocusedTextColor: цвет, используемый для ввода текста этого текстового поля, когда он не сфокусирован
- disabledTextColor: цвет, используемый для ввода текста этого текстового поля, когда он отключен.
- errorTextColor: цвет, используемый для ввода текста этого текстового поля в состоянии ошибки.
- focusedContainerColor: цвет контейнера текстового поля в фокусе.
- unfocusedContainerColor: цвет контейнера текстового поля, когда он не сфокусирован.

- disabledContainerColor: цвет контейнера текстового поля, когда он отключен.

- errorContainerColor: цвет контейнера текстового поля в состоянии ошибки.

- cursorColor: цвет курсора текстового поля

- errorCursorColor: цвет курсора текстового поля в состоянии ошибки.

- selectionColors: цвета, используемые при выборе входного текста этого текстового поля.

- focusedIndicatorColor: цвет индикатора текстового поля при фокусировке.

- unfocusedIndicatorColor: цвет индикатора текстового поля, когда оно не сфокусировано.

- disabledIndicatorColor: цвет индикатора текстового поля, когда он отключен.

- errorIndicatorColor: цвет индикатора текстового поля в состоянии ошибки.

- focusedLeadingIconColor: цвет ведущего значка текстового поля в фокусе.

- unfocusedLeadingIconColor: цвет ведущего значка текстового поля, когда он не сфокусирован.

- disabledLeadingIconColor: цвет ведущего значка текстового поля, когда он отключен.

- errorLeadingIconColor: цвет ведущего значка текстового поля в состоянии ошибки.

- focusedTrailingIconColor: цвет конечного значка текстового поля в фокусе.

- unfocusedTrailingIconColor: цвет конечного значка текстового поля, когда он не в фокусе.

- disabledTrailingIconColor: цвет конечного значка текстового поля, когда он отключен.

- errorTrailingIconColor: цвет конечного значка текстового поля в состоянии ошибки.

- focusedLabelColor: цвет метки текстового поля при фокусировке.

- unfocusedLabelColor: цвет метки текстового поля, когда оно не сфокусировано.

- disabledLabelColor: цвет метки текстового поля, когда он отключен.

- errorLabelColor: цвет метки текстового поля в состоянии ошибки.

- focusedPlaceholderColor: цвет заполнителя текстового поля в фокусе.

- unfocusedPlaceholderColor: цвет заполнителя текстового поля, когда он не сфокусирован.

- disabledPlaceholderColor: цвет заполнителя текстового поля, когда он отключен.

- errorPlaceholderColor: цвет заполнителя текстового поля в состоянии ошибки.

- focusedSupportingTextColor: вспомогательный цвет текста текстового поля при фокусе.

- unfocusedSupportingTextColor: вспомогательный цвет текста текстового поля, когда он не сфокусирован

- disabledSupportingTextColor: вспомогательный цвет текста текстового поля, когда он отключен.

- errorSupportingTextColor: вспомогательный цвет текста текстового поля в состоянии ошибки.

- focusedPrefixColor: цвет префикса текстового поля в фокусе.

- unfocusedPrefixColor: цвет префикса текстового поля, когда оно не сфокусировано.

- disabledPrefixColor: цвет префикса текстового поля, когда он отключен.

- errorPrefixColor: цвет префикса текстового поля в состоянии ошибки.

- focusedSuffixColor: цвет суффикса текстового поля в фокусе.

- unfocusedSuffixColor: цвет суффикса текстового поля, когда оно не сфокусировано.

- disabledSuffixColor: цвет суффикса текстового поля, когда он отключен.

- errorSuffixColor: цвет суффикса текстового поля в состоянии ошибки.

Мы можем использовать этот компонент для настройки цветовой гаммы поля ввода:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            TextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  28.sp),
                colors = TextFieldDefaults.colors(
                    unfocusedContainerColor = Color(0xffeeeeee),
                    unfocusedTextColor = Color(0xff888888),
                    focusedContainerColor = Color.White,
                    focusedTextColor = Color(0xff222222),
                )
            )
        }
    }
}
```

В данном случае для текста и фона устанавливаются разные цвета в зависимости от того, получило текстовое поле фокус или нет:

![](https://metanit.com/kotlin/jetpack/pics/4.16.png)

## OutlinedTextField
Компонент OutlinedTextField во многом похож на TextField за тем исключением, что он добавляет границу вокуг поля ввода. Простейшее определение компонента OutlinedTextField:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedTextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            OutlinedTextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  30.sp)
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.17.png)


В функции компонента OutlinedTextField мы видим, что в отличие от TextField, меняется стандартное значение для последнего параметра - colors, который устанавливает цвета. Теперь он по умолчанию равен компоненту TextFieldDefaults.outlinedTextFieldColors(). Фактически здесь мы можем установить те же самые цвета за тем исключением, что мы также можем настроить текст границы с помощью таких параметов как focusedBorderColor, unfocusedBorderColor, disabledBorderColor и errorBorderColor, который позволяют установить цвет границы для различных состояний поля ввода. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.OutlinedTextFieldDefaults
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val message = remember{mutableStateOf("Hello")}
            OutlinedTextField(
                message.value,
                {message.value = it},
                textStyle = TextStyle(fontSize =  30.sp),
                colors = OutlinedTextFieldDefaults.colors(
                    focusedBorderColor= Color(0xff16a085), // цвет при получении фокуса
                    unfocusedBorderColor = Color(0xffcccccc)  // цвет при отсутствии фокуса
                )
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.62.png)
























# Modifier.toggleable

Модификатор Modifier.toggleable устанавливает для компонента два состояния и позволяет переключаться между этими состояниями. Подобные компоненты в этом плане похожи на флажки (checkbox), в которых можно поставить отметку, а можно ее снять, тем самым изменив состояние флажка. Функция модификатора принимает следующие параметры:

```kotlin
fun Modifier.toggleable(
    value: Boolean,
    enabled: Boolean = true,
    role: Role? = null,
    onValueChange: (Boolean) -> Unit
): Modifier
```

- value хранит состояние компонента в виде объекта Boolean, поэтому состояние может принимать только два значения: true и false

- enabled указывает, будет ли компонент доступен для выбора. Если он имеет значение true (значение по умолчанию), то компонент будет доступен

- role представляет объект Role, который представляет тип элемента интерфейса

- onValueChange представляет функцию типа (Boolean) -> Unit, которая вызывается при нажатии на компонент

Создадим переключаемый компонент на основе компонента Text:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.selection.toggleable
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var checked = remember { mutableStateOf(false) }
            Text(
                modifier = Modifier.toggleable(value = checked.value, onValueChange = { checked.value = it }),
                text = checked.value.toString(),
                fontSize = 30.sp
            )
        }
    }
}
```

Для отслеживания состояния создается переменная checked, которая по умолчанию хранит значение false. Это значение передается в функцию модификатора toggleable параметру value. А с помощью другого параметра - onValueChange задаем функцию, которая получает новое состояние через параметр it и передает его переменной checked. Таким образом, при нажатии состояние компонента будет переключаться.

![](https://metanit.com/kotlin/jetpack/pics/4.27.png)

Мы можем пойти дальше и сделать с помощью модификатора что-то наподобие стандартного флажка или чекбокса:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.toggleable
import androidx.compose.ui.unit.sp
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var checked = remember { mutableStateOf(false) }
            Row{
                Box(modifier = Modifier.padding(10.dp).size(30.dp)
                    .background(Color.Black).padding(1.dp)
                    .background(
                        if(checked.value) Color.Black
                        else Color.White
                    ).toggleable(value = checked.value, onValueChange = { checked.value = it }))
                Text(checked.value.toString(),fontSize = 30.sp)
            }
        }
    }
}
```

В данном случае для изменения состояния применяется компонент Box. Для этого компонента устанавливаем отступ от границ контейнера и размер

```kotlin
Modifier.padding(10.dp).size(30.dp)
```

Далее устанавливаем границу черным цветом в 1 пиксель:

```kotlin
.background(Color.Black).padding(1.dp)
```

Затем устанавливаем фон компонента - он привязан к состоянию:

```kotlin
.background(
    if(checked.value) Color.Black
    else Color.White
)
```

То есть если состояние равно true, то Box получает черный цвет, иначе - белый цвет.

И далее с помощью модификатора toggable устанавливаем переключение состояния по нажатию на Box:

```kotlin
.toggleable(value = checked.value, onValueChange = { checked.value = it }))
```

Тектовое поле просто выводит значение состояния:

![](https://metanit.com/kotlin/jetpack/pics/4.64.png)






















































# Checkbox

Компонент Checkbox представляет флажок, который может быть в отмеченном и неотмеченном состоянии. Его функция принимает следующие параметры:


```kotlin
@Composable
fun Checkbox(
    checked: Boolean,
    onCheckedChange: ((Boolean) -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: CheckboxColors = CheckboxDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

- checked: указывает, будет ли отмечен флажок. Представляет значение Boolean. Если равен true, то флажок отмечен.

- onCheckedChange: представляет функции типа (Boolean) -> Unit, которая выполняется при изменении состояния флажка (установки или снятия отметки). В качестве параметра в функцию передается новое состояние флажка.

- modifier: объект Modifier, который устанавливает для флажка модификаторы

- enabled: указывает, будет ли доступен флажок. Представляет значение Boolean и по умолчанию равен true (то есть флажок будет доступен).

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для флажка. По умолчанию равен remember { MutableInteractionSource() }.

- colors: объект CheckboxColors, который задает цвета для флажка. По умолчанию равен CheckboxDefaults.colors().

Простейший флажок:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.material3.Checkbox
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Checkbox(
                checked = checkedState.value,
                onCheckedChange = { checkedState.value = it }
            )
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.65.png)


Здесь надо отметить два момента. Прежде всего для компонента Checkbox необходимо задать как минимум два параметра: checked и onCheckedChange. Для этого в примере выше определена переменная checkedState, которая представляет состояние флажка (отмечен или нет). Эта переменная представляет объект типа MutableState<Boolean>, который создается функцией mutableStateOf(). В эту функцию передается собственно хранимое значение - в данном случае значение true, которое затем можно получить с помощью свойства value объекта MutableState<T>. А функция remember позволяет сохранить это значение.

В коде с помощью свойства value мы привязываем значение переменной к свойству checked:

```kotlin
checked = checkedState.value
```

А в функции обработки изменения состояния флажка с помощью параметра it передаем в переменную новое состояние флажка (если отмечен - true, если отметка отсутвует - false):

```kotlin
onCheckedChange = { checkedState.value = it }
```

Второй момент, который надо отметить, флажок не предоставляет встроенных возможностей по установке текстовой метки. Однако, как правило, при флажке идет некоторый текст, который некоторым образом объясняет назначение флажка. Но в Jetpack Compose подобную текстовую метку нам надо устанавливать дополнительно:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Checkbox
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Row{
                Checkbox(
                    checked = checkedState.value,
                    onCheckedChange = { checkedState.value = it }
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.18.png)

Из параметров следует отметить параметр colors, который представляет тип CheckboxColors и устанавливает цветовую гамму флажка. По умолчанию он хранит компонент CheckboxDefaults.colors

![](@Composable
fun colors(
    checkedColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.SelectedContainerColor),
    uncheckedColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.UnselectedOutlineColor),
    checkmarkColor: Color = MaterialTheme.colorScheme.fromToken(CheckboxTokens.SelectedIconColor),
    disabledCheckedColor: Color = MaterialTheme.colorScheme                 
        .fromToken(CheckboxTokens.SelectedDisabledContainerColor)                 
        .copy(alpha = CheckboxTokens.SelectedDisabledContainerOpacity),
    disabledUncheckedColor: Color = MaterialTheme.colorScheme                 
        .fromToken(CheckboxTokens.UnselectedDisabledOutlineColor)                 
        .copy(alpha = CheckboxTokens.UnselectedDisabledContainerOpacity),
    disabledIndeterminateColor: Color = disabledCheckedColor
): @Composable CheckboxColors)

Его параметры:

- checkedColor: цвет флажка, когда он находится в отмеченном состоянии

- uncheckedColor: цвет флажка, когда он неотмечен

- checkmarkColor: цвет отметки флажка

- disabledCheckedColor: цвет флажка, когда он отмечен, но не доступен для нажатия

- disabledUncheckedColor: цвет флажка, когда он не отмечен и не доступен для нажатия

- disabledIndeterminateColor: цвет флажка типа TriStateCheckbox, когда он не доступен и одновременно находится в состоянии ToggleableState.Indeterminate

Используем данный параметр для настройки цветов:


```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CheckboxDefaults
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(true) }
            Row{
                Checkbox(
                    checked = checkedState.value,
                    onCheckedChange = { checkedState.value = it },
                    colors  = CheckboxDefaults.colors(checkedColor = Color(0xffffb6c1), checkmarkColor = Color.Red)
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.19.png)


## TriStateCheckbox
Компонент TriStateCheckbox расширяет Checkbox, добавляя возможность установить флажок в третье - неопределенное состояние

```kotlin
@Composable
fun TriStateCheckbox(
    state: ToggleableState,
    onClick: (() -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: CheckboxColors = CheckboxDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

Он принимает почти те же параметры, что и Checkbox, за исключением двух параметров. Так, параметр state представляет тип ToggleableState и устанавливает состояние флажка с помощью следующих значений:

- ToggleableState.Indeterminate: неопределенное состояние
- ToggleableState.Off: отметка снята
- ToggleableState.On: флажок отмечен

Второй отличающийся параметр - onClick задает функцию изменения состояния флажка.

Определим простейший компонент TriStateCheckbox:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Text
import androidx.compose.material3.TriStateCheckbox
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.state.ToggleableState
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val checkedState = remember { mutableStateOf(ToggleableState.Indeterminate) }
            Row{
                TriStateCheckbox(
                    state = checkedState.value,
                    onClick = {
                        if (checkedState.value == ToggleableState.Indeterminate || checkedState.value == ToggleableState.Off)
                            checkedState.value = ToggleableState.On
                        else checkedState.value = ToggleableState.Off
                    }
                )
                Text("Выбрано", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.20.png)




































# Выбираемый компонент и модификатор selectable

Модификатор Modifier.selectable позволяет сделать компонент выбираемым (или выделяемым). Данный модификатор имеет следующие параметры:

```kotlin
fun Modifier.selectable(
    selected: Boolean,
    enabled: Boolean = true,
    role: Role? = null,
    onClick: () -> Unit
): Modifier
```

- selected указывает, будет ли компонент выбран. Если он имеет значение true, то компонент выбран

- enabled указывает, будет ли компонент доступен для выбора. Если он имеет значение true (значение по умолчанию), то компонент будет доступен

- role представляет тип элемента графического интерфейса

- onClick представляет функцию типа () -> Unit, которая вызывается при нажатии на компонент

Рассмотрим простейший пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.selection.selectable
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val selected = remember { mutableStateOf(true) }
            Text(
                text= selected.value.toString(),
                fontSize = 30.sp,
                modifier = Modifier.selectable(
                    selected = selected.value,
                    onClick = { selected.value = !selected.value }
                )
            )
        }
    }
}
```

Здесь для компонента Text устанавливается модификатор Modifier.selectable:

```kotlin
modifier = Modifier.selectable(
    selected = selected.value,
    onClick = { selected.value = !selected.value }
)
```

Параметр selected модификатора, который указывает, будет ли выбран компонент, получает значение из переменной selected, которая представляет объект MutableState<Boolean>, то есть значение selected.value будет равно true или false.

А параметр onClick, который задает функцию, выполняемую при нажатии на компонент, будет переключать значение selected.value. То есть если это значение было равно true, оно становится равным false и наоброт.

![](https://metanit.com/kotlin/jetpack/pics/4.24.png)


## Выбор из группы компонентов
Обычно данный модификатор применяется для настройки выбора из нескольких компонентов. В этом случае все эти компоненты рассматриваются как единая группа, из которой одномоменто можно выбрать только один компонент. Рассмотрим небольшой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.selectable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val colors = listOf(Color.Red, Color.LightGray, Color.Blue)
            val selectedOption = remember { mutableStateOf(colors[0]) }
            Column(modifier =Modifier.padding(20.dp)) {
                Box( Modifier.padding(10.dp).size(100.dp).background(color = selectedOption.value))
 
                colors.forEach { color ->
                    val selected = selectedOption.value == color
                    Box(
                        Modifier.padding(8.dp)
                            .size(60.dp)
                            .background(color = color)
                            .selectable(
                                selected = selected,
                                onClick = { selectedOption.value = color }
                            )
                            .border(
                                width= if(selected) 3.dp else 0.dp,
                                color = Color.Black
                            )
                    )
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.25.png)

В данном случае у нас три варианта выбора, которые описываются списком colors:

```kotlin
val colors = listOf(Color.Red, Color.Green, Color.Blue)
```

Для хранения текущего выбранного элемента создаем переменную selectedOption, которая по умолчанию указывает на первый элемент из списка:

```kotlin
val selectedOption = remember { mutableStateOf(colors[0]) }
```

Каждый элемент списка представляет описание цвета. С помощью функции forEach() пробегаемся по каждому И для каждого из этих элементов мы создаем отдельный элемент Box:

```kotlin
colors.forEach { color ->
    val selected = selectedOption.value == color
    Box(
```

Условно говоря, закрепляем за каждым компонентом Box свой элемент из списка colors. В функцию forEach() передается лямбда-выражение, в которое в качестве параметра передается текущий элемент списка. Затем устанавливаем переменную selected, которая для данного элемента будет указывать, выбран ли данный элемент (иначе говоря равен ли он значению selectedOption.value)

В модификаторе selectable устанавливаем, что компонент выбран, если выбран текущий элемент списка colors:

```kotlin
.selectable(
    selected = selected,
    onClick = { selectedOption.value = color }
)
```

А в параметру onClick передается функция, которая при нажатии на данный компонент присваивает переменной selectedOption значение текщего элемента списка.

## Комплексные компоненты
Подобным образом мы можем определить список объектов своих классов и посредством выбора компонентов выбирать один из объектов из списка. Например, изменим код следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.selection.selectable
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val langs = listOf(Language("Kotlin",0xff16a085),
                Language("Java",0xff2980b9),
                Language("JavaScript",0xffe74c3c),
                Language("Python", 0xffd35400))
            val selectedOption = remember { mutableStateOf(langs[0]) }
            Column{
 
                Row(modifier = Modifier.padding(10.dp).fillMaxWidth()){
                    Box( Modifier.padding(10.dp).size(100.dp).background(color = Color(selectedOption.value.hexColor)))
                    Text(text = selectedOption.value.name, fontSize = 36.sp, modifier = Modifier.padding(10.dp))
                }
 
                for(lang in langs){
                    val selected = selectedOption.value == lang
                    Row(modifier = Modifier.padding(10.dp).fillMaxWidth()
                        .selectable(selected = selected, onClick = { selectedOption.value = lang }),
                        verticalAlignment = Alignment.CenterVertically
                    ){
                        Box(
                            Modifier.padding(8.dp)
                                .size(60.dp)
                                .background(Color(lang.hexColor))
                                .border(
                                    width= if(selected){2.dp} else{0.dp},
                                    color = Color.Black
                                )
                        )
                        Text(text = lang.name, fontSize = 28.sp)
                    }
                }
            }
        }
    }
}
data class Language(val name: String, val hexColor:Long)
```

![](https://metanit.com/kotlin/jetpack/pics/4.26.png)


В данном случае создаем класс Language, который описывает применяемые данные и который хранит два значения - имя языка программирования и шестнадцатериченое значение цвета. В коде MainActivity также создаем список данных, только теперь каждый элемент списка представляет объект Language. Далее проходим по каждому из этих объектов и для каждого из них создаем строку Row. Каждая строка Row содержит компонент Box, который отображает цвет языка, и компонент Text, который отображает название языка программирования.


# RadioButton

Компонент RadioButton представляет переключатель или радиокнопку и служит для создания группы радиокнопок, из которых одномоментно можно выбрать только один переключатель. Этот компонент имеет следующие параметры:

```kotlin
@Composable
fun RadioButton(
    selected: Boolean,
    onClick: (() -> Unit)?,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    colors: RadioButtonColors = RadioButtonDefaults.colors(),
    interactionSource: MutableInteractionSource? = null
): Unit
```

- selected: указывает, будет ли отмечена радиокнопка. Представляет значение Boolean. Если равен true, то радиокнопка отмечена.

- onClick: представляет функцию типа () -> Unit, которая выполняется при нажатия на радиокнопку.

- modifier: объект Modifier, который устанавливает для радиокнопки модификаторы

- enabled: указывает, будет ли доступна радиокнопка. Представляет значение Boolean и по умолчанию равен true (то есть радиокнопка будет доступна).

- interactionSource: объект MutableInteractionSource, который задает поток взаимодействий для радиокнопки. По умолчанию равен remember { MutableInteractionSource() }.

- colors: объект RadioButtonColors, который задает цвета для радиокнопки. По умолчанию равен RadioButtonDefaults.colors().

Создадим группу из двух радиокнопок:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val state = remember { mutableStateOf(true) }
            Column(Modifier.selectableGroup())
            {
                RadioButton(
                    selected = state.value,
                    onClick = { state.value = true }
                )
                RadioButton(
                    selected = !state.value,
                    onClick = { state.value = false }
                )
            }
        }
    }
}
```

Для создании группы радиокнопок, которые рассматриваются именно как группа или единое целое, у контейнера - компонента Column или Row устанавливается модификатор Modifier.selectableGroup(). В данном случае радиокнопки помещаются в Column и соответственно будут располагаться в столбик:

```kotlin
Column(Modifier.selectableGroup())
```

Хотя также можно было бы расположить радиокнопки в строку, поместив в контейнер Row.

Для хранения состояния радиокнопок определяется переменная state, которая представляет тип MutableState<Boolean>:

```kotlin
val state = remember { mutableStateOf(true) }
```

С помощью свойства value получаем хранимое в переменной значение (true или false) и передаем его параметру selected радиокнопок:

```kotlin
selected = state.value
```

Но поскольку только одна радиокнопка одномоментно может быть выбрана, то другой радиокнопке передается противоположеное значение:

```kotlin
selected = !state.value
```

А в обработчике нажатия из параметра onClick изменяем данное значение:

```kotlin
onClick = { state.value = true }
```

![](https://metanit.com/kotlin/jetpack/pics/4.21.png)

## Добавление текстовых меток к радиокнопкам
В примере выше мы видим, что для радиокнопок, как и для флажков, неопределяется никакой текстовой метки, которая несла бы самую минимальную информацию о радиокнопке. В этом случае необходимо самостоятельно комбинировать радиокнопку с текстовыми компонентами:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val state = remember { mutableStateOf(true) }
            Column {
                Text(text = if(state.value) {"Kotlin"} else {"Java"}, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    Row{
                        RadioButton(
                            selected = state.value,
                            onClick = { state.value = true }
                        )
                        Text("Kotlin", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
                    }
                    Row{
                        RadioButton(
                            selected = !state.value,
                            onClick = { state.value = false }
                        )
                        Text("Java", fontSize = 28.sp, modifier = Modifier.padding(4.dp))
                    }
                }
            }
        }
    }
}
```

В данном случае, если state хранит true, то выбирается радиокнопка с языком Kotlin, если state хранит false, то выбирается радиокнока с языком Java.

![](https://metanit.com/kotlin/jetpack/pics/4.22.png)

## Обработка выбора варианта в группе радиокнопок

Выше приведенный пример довольно прост в том плане, что у нас только две радиокнопки - когда у одной кнопки параметр selected равен true, у другой равен false. В этом плане довольно просто задать логику переключения между радиокнопками. Однако что если у нас 3 и более переключателей? Рассмотрим следующий пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
            val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
            Column {
                Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    languages.forEach { text ->
                        Row( Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)
                        {
                            RadioButton(
                                selected = (text == selectedOption),
                                onClick = { onOptionSelected(text) }
                            )
                            Text( text = text, fontSize = 24.sp )
                        }
                    }
                }
            }
        }
    }
}
```

![](https://metanit.com/kotlin/jetpack/pics/4.23.png)

В примере выше прежде всего все данные, которые будут представлять радиокнопки, помещаются в список languages:

```kotlin
val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
```

Здесь четыре элемента, соответственно мы будем создавать четыре радиокнопки для каждого из этих элементов.

Далее мы получаем объект MutableState<String>, который необходим для и отслеживания выбранного значения:

```kotlin
val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
```

В функцию mutableStateOf() передается первый элемент из списка, то есть по умолчанию будет выбран первый элемент списка languages.

Однако мы не просто берем объект MutableState<String>, а раскладываем его на два компонента - selectedOption и onOptionSelected. Значение selectedOption будет представлять отслеживаемый объектом MutableState<String> элемент списка languages. А onOptionSelected - функция типа (String) -> Unit, которая будет вызываться при изменении значения в MutableState<String> и которая в качестве параметра будет получать новое значение.

Выбранный элемент из selectedOption выводится в верхний компонент Text:

```kotlin
Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
```

Как и в примерах выше, чтобы задать группу выбираемых компонентов, для контейнера (в данном случае компонента Column) устанавливается модификатор selectableGroup:

```kotlin
Column(Modifier.selectableGroup()){ ........... }
```

Далее перебираем список languages с помощью функции forEach(), в которую передается функция, вызываемая для каждого перебираемого элемента:

```kotlin
languages.forEach { text ->
    Row( Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically)
    {
        RadioButton(
            selected = (text == selectedOption),
            onClick = { onOptionSelected(text) }
        )
        Text( text = text, fontSize = 24.sp )
    }
}
```

Фактически в данном случае за каждой строкой закрепляется определенный элемент из списка languages. И радиокнопка является выбранный, если значение selectedOption совпадает со значением элемента из списка languages, закрепленным за данным компонентом Row:

```kotlin
selected = (text == selectedOption)
```

При нажатии на компонент срабатывает функция из параметра onClick, в которой вызывается функция onOptionSelected:

```kotlin
onClick = { onOptionSelected(text) }
```

В функции onOptionSelected передается закрепленный за компонентом Row элемент из списка languages, благодаря чему изменится выбранный элемент.

## Выбор всей строки
Пример выше прекрасно работает, однако имеет один недостаток: чтобы выбрать радиокноку, необходимо пальцем попасть в этот небольшой кружок, который представляет радиокнопку. Было бы гораздо лучше, если бы мы могли нажать на любой место в строке, например, на текстовую метку, и тем самым выбрать радиокноку. Для этого изменим код следующим образом:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Text
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val languages = listOf("Kotlin", "Java", "Javascript", "Rust")
            val (selectedOption, onOptionSelected) = remember { mutableStateOf(languages[0]) }
            Column {
                Text(text = selectedOption, fontSize = 28.sp, modifier = Modifier.padding(10.dp))
                Column(Modifier.selectableGroup()) {
                    languages.forEach { text ->
                        Row( Modifier.fillMaxWidth()
                            .selectable(
                                selected = (text == selectedOption),
                                onClick = { onOptionSelected(text) }),
                            verticalAlignment = Alignment.CenterVertically)
                        {
                            RadioButton(
                                selected = (text == selectedOption),
                                onClick = { }
                            )
                            Text( text = text, fontSize = 24.sp )
                        }
                    }
                }
            }
        }
    }
}
```
Ключевым моментом здесь является установка модификатора Modifier.selectable:

```kotlin
Row(
    Modifier.selectable(
        selected = (text == selectedOption),
        onClick = { onOptionSelected(text) }
),
```

Модификатор Modifier.selectable() делает компонент (в данном случае компонент Row) выделяемым. То есть мы можем выбрать не просто радиокнопку, а всю строку. В примере выше компонент Row является выбранным, если значение selectedOption совпадает со значением элемента из списка languages, закрепленным за данным компонентом Row:

```kotlin
selected = (text == selectedOption)
```

При нажатии на компонент срабатывает функция из параметра onClick, в которой вызывается функция onOptionSelected:

```kotlin
onClick = { onOptionSelected(text) }
```

В функции onOptionSelected передается закрепленный за компонентом Row элемент из списка languages, благодаря чему изменится выбранный элемент.

Кроме того, также надо настроить радиокнопки, которые выводятся в строке Row:

```kotlin
RadioButton(
    selected = (text == selectedOption),
    onClick = {}
)
```

Для выбора радиокнопки действует тот же алгоритм, что и для контейнера Row: радиокнопка выбрана, если текущий элемент из languages совпадает со значением selectedOption.

И поскольку выбор элемента обрабатывается в родительском контейнере Row, то нет смысла обрабатывать выбор элемента в радиокнопке, поэтому ее параметру onClick передается значение {} (по сути пустая функция).

Таким образом, внешне мы получим тот же визуальный интерфейс, только теперь для выделения радиокнопки достаточно нажать на любое место в строке.

## Настройка цвета радиокнопок
За настройку цвета радиокнопок отвечает параметр colors компонента RadioButton. Для установки этого параметра можно использовать встроенную функцию RadioButtonDefaults.colors(), которая имеет следующее определение:

```kotlin
@Composable
public final fun colors(
    selectedColor: Color = RadioButtonTokens.SelectedIconColor.toColor(),
    unselectedColor: Color = RadioButtonTokens.UnselectedIconColor.toColor(),
    disabledSelectedColor: Color = RadioButtonTokens.DisabledSelectedIconColor             
        .toColor()             
        .copy(alpha = RadioButtonTokens.DisabledSelectedIconOpacity),
    disabledUnselectedColor: Color = RadioButtonTokens.DisabledUnselectedIconColor             
        .toColor()             
        .copy(alpha = RadioButtonTokens.DisabledUnselectedIconOpacity)
): RadioButtonColors
```

Таким образом, для отдельной радиокнопки мы можем установить 4 цвета:

- selectedColor: цвет, когда кнопка выбрана
- unselectedColor: цвет, когда кнопка не выбрана
- disabledSelectedColor: цвет, когда кнопка выбрана, но не доступна
- disabledUnselectedColor: цвет, когда кнопка не выбрана и не доступна

Например:

```kotlin
RadioButton(
    selected = (text == selectedOption),
    onClick = { },
    colors = RadioButtonDefaults.colors(selectedColor = Color.DarkGray, unselectedColor = Color.LightGray)
)
```