# Глава 1: Принципы проектирования

«Состояние» - сердце декларативных представлений

Первая парадигма, которую мы должны четко представлять при разработке декларативных представлений с помощью таких фреймворков, как ```Compose```
или ```SwiftUI```, является состояние.

Компонент пользовательского интерфейса объединяет в себе графическое представление (View) и состояние.

Любое свойство или данные, которые изменяются в компоненте пользовательского интерфейса, могут быть представлены в виде состояния.
Например, в UI-компоненте типа ```TextFiel``` текст, введенный пользователем, является переменной, которая может изменяться;
Поэтому value - это переменная, которая может быть представлена как состояние (имя), как показано в следующем коде
фрагмент 1.1.

```kotlin
TextField(
    label = { Text("User name") },
    value = name,
    onValueChange = onNameChange
)
```

![](image1.png)

Экран мобильного приложения может состоять из иерархии представлений, как показано на рисунке 1.1.

Каждое представление, в свою очередь, может содержать несколько переменных состояния. Например, все представления на рисунке 1.1 имеют состояние.
Представления, которые содержат или зависят от состояния, называются ```Stateful Views```, а представления, которые не имеют зависимости от состояния известны как представления без состояния.

И Google, и Apple рекомендуют в качестве хорошей практики разрабатывать, насколько это возможно, представления без состояния, поскольку
следующих преимуществ использования этого типа:
- Их можно использовать повторно.
- Они позволяют делегировать управление состоянием другим компонентам.
- Они функциональны и позволяют избежать побочных эффектов.

Согласно этим рекомендациям, проектирование должно быть ориентировано на представления без состояния и преобразование этих
```stateful views``` в ```stateless views```.

Применение «поднятия состояния» к состояниям делегатов

**Поднятие состояний** - это техника преобразования представлений с состояниями в представления без состояний. Это достигается за счет инверсии
управления, как показано в следующем фрагменте кода 1.2:



```kotlin
// This is a Stateful View
@Composable
fun OrderScreen() {

var name by remember { mutableStateOf("") }
var phone by remember { mutableStateOf("") }

ContactInformation(
    name = name,
    onNameChange = { name = it },
    phone = phone,
    onPhoneChange = { phone = it })
 }

// This is a Stateless View
@Composable
    fun ContactInformation(
        name: String,
        onNameChange: (String) -> Unit,
        phone: String,
        onPhoneChange: (String) -> Unit
    ) {


        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(8.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            TextField(
                label = {
                    Text("User name")
                },
                value = name,
                onValueChange = onNameChange
            )
            Spacer(Modifier.padding(5.dp))
            TextField(
                label = {
                    Text("Phone number")
                },
                value = phone,
                onValueChange = onPhoneChange
            )
            Spacer(Modifier.padding(5.dp))
            Button(
                onClick = {
                    println("Order generated for $name and phone $phone")
                },
            ) {
                Text("Pay order")
            }
        }
    }

```

В фрагменте кода управление состоянием имени и телефона делегировано экрану заказа, поэтому ```ContactInformation``` не заботится о состоянии своих данных и может быть повторно использована другими представлениями. ```OrderScreen``` становится stateful, а ContactInformation - stateless.


```kotlin
@Composable
 fun OrderScreen() {

 // States name and phone
 var name by remember { mutableStateOf("") }
 var phone by remember { mutableStateOf("") }

ContactInformation(
 name = name,
 onNameChange = { name = it },
 phone = phone,
 onPhoneChange = { phone = it })
 }

@Composable
fun ContactInformation(
    name: String,
    onNameChange: (String) -> Unit,
    phone: String,
    onPhoneChange: (String) -> Unit,
    payOrder: () -> Unit
 ) {
 // Code omitted for simplicity
}

```

В примере фрагмента кода инверсия управления достигается с помощью функций высшего порядка, позволяющих определения состояний и операций передавать в качестве аргументов представлению ```ContactInformation```.

# Определение «источника истины». 

> Кто отвечает за обеспечение состояния?
Для начала давайте уточним, что такое источник истины.
Под источником истины понимается надежный источник, предоставляющий данные, которые должны быть представлены на экране и с которыми будет взаимодействовать пользователь.
экрана и с которыми будет взаимодействовать пользователь.

В нашем анализе данные тесно связаны с состояниями. Представления используют состояния для получения информации (данных), необходимой для
выполнения их работы.
На рисунке мы видим, как состояния находятся в соответствующих представлениях. Это означает, что каждое представление в указанной диаграмме является источником истины.
Даже имя переменной компонента UI TextField, о котором мы говорили ранее, может быть состоянием и, следовательно, тоже является источником истины.


> Разумно ли иметь так много источников истины в иерархии представлений?
Ответ - нет.
Рекомендуется ограничить источник истины одним компонентом (или минимально возможным), чтобы
Вы можете лучше контролировать поток и избегать несоответствий состояния.
Наличие единственного, четко определенного источника истины также помогает правильно реализовать ```однонаправленный поток данных```, который поддерживается декларативными представлениями, такими как ```Compose``` или ```SwiftUI```.

> А как уменьшить количество источников истины в моем проекте?
Это возможно за счет уменьшения количества представлений Stateful с помощью техники State hoisting, о которой говорилось
выше, и централизации состояния в одном представлении.

Как правило, делегат - это представление с самым высоким иерархический уровень, родительское представление.
Например, на рисунке показано, что существует только один источник истины, и это родительское представление.
С одной стороны, дочерние представления отвечают только за распространение событий, полученных при взаимодействии
с пользователем. С другой стороны, они получают состояния, которые будут рендерить представление (рекомпозиция), чтобы отразить
изменения в пользовательском интерфейсе.

![](image2.png)

> Есть ли другой вариант, кроме делегирования всей ответственности за работу с состояниями
только одному представлению?
Ответ - да.

Лучший вариант - передать эту ответственность держателю состояния или ```ViewModel```, которая выполняет эту роль. Давайте
более подробно в следующем разделе.

# ViewModel

## ViewModel как источник истины

Другой компонент призван управлять состоянием, чтобы не перегружать представление обязанностями. Подходящим элементом для этой цели является хорошо известная ```ViewModel```.

Как показано на рисунке 1.3, перемещение состояний из View в ViewModel создает разделение ответственности,
позволяя централизовать логику представления и ее влияние на состояние.

![](image3.png)


Несмотря на то, что этот компонент (ViewModel) является необязательным в реализации, я настоятельно рекомендую его
поскольку он дает множество преимуществ, таких как эффективное управление жизненным циклом между данными и
представлениями.
Для получения дополнительной информации об этом компоненте архитектуры я рекомендую ознакомиться с официальной документацией Google по ViewModels⁷.
Связь между представлением и ViewModel состоит только из двух типов сообщений - Events и States:


```События``` - это действия, которые сообщаются ```ViewModel``` любым ```View``` или ```Sub-View``` как следствие пользовательского
действия или взаимодействия с компонентами пользовательского интерфейса.
- Состояния представляют собой информацию (данные), которую ViewModel доставляет представлениям для их соответствующей
графической интерпретации.
Основная функция ```ViewModel``` - получать события, отправляемые из представлений, интерпретировать их, применять
бизнес-логику и преобразовывать их в состояния для передачи обратно в представления.
Задача представления - получить состояния, отправленные ViewModel, и преобразовать их в графическое представление пользовательского интерфейса
путем рекомпозиции.
Теперь, имея немного больше ясности об ответственности каждого компонента и сообщениях между ними,
давайте теперь проанализируем, что происходит с потоком информации


# Понимание потока данных, «Однонаправленный поток данных Паттерн»
Если мы упростим диаграмму на рисунке 1.3, то в результате получим следующую диаграмму на рисунке 1.4:


Это циклическое сообщение между представлением и ViewModel. Поток информации следует только в одном
направление, отсюда и название паттерна «Однонаправленный поток данных».
Внешние факторы, которые могут вносить события в этот цикл, - это взаимодействия с пользователем, такие как прокрутка списка, нажатие кнопки
щелчок на кнопке, а также взаимодействие с другими уровнями приложения, например ответ от хранилища или
ответ от пользователя, фоновый таймер или, возможно, поступление push-уведомления.
Цикл не может быть прерван, поскольку любое прерывание или задержка приведут к ухудшению пользовательского опыта.
Пользователь будет воспринимать приложение как медленное, заблокированное и некачественное.
Поэтому при проектировании следует по возможности учитывать следующие правила:
- Составной элемент, определяющий представление, должен быть идемпотентным и функциональным.
- На стороне представления не должно быть задач, замедляющих цикл. Любая задача, требующая длительной обработки
должна быть делегирована ViewModel, которая, благодаря реактивному программированию и Flow Coroutines, будет
выполнять эти задачи асинхронно


Теперь, когда вы имеете представление о потоке данных и сообщений, которыми обмениваются View и ViewModel,
логично спросить:
Как реализован канал связи между View и ViewModel?
Мы рассмотрим это далее.


Давайте соединим компоненты View и ViewModel
Как показано на рисунке 1.4, два типа каналов связи, которые необходимо реализовать, четко определены
определены.
Первый канал - это канал событий, который идет в направлении View -> ViewModel.
Для этой реализации требуется только, чтобы ViewModel раскрывала публичные операции, которые могут быть вызваны
которые могут быть вызваны представлением, как показано в следующем фрагменте кода 1.4.

```kotlin
//UI's Events
fun onNameChange(): (String) -> Unit = {
  name = it
}

fun onPhoneChange(): (String) -> Unit = {
  phone = it
}
```

Второй канал - это канал состояний, который идет в направлении ViewModel -> View.
Как пользовательский интерфейс узнает, что состояние изменилось?
Наблюдая за состояниями. Чтобы следить за состояниями, сначала ViewModel должна показать их UI через компонент
mutableStateOf, например:

```kotlin

 // UI's states
 var name by mutableStateOf("")
 private set
 var phone by mutableStateOf("")
 private set

```

```mutableStateOf``` не только позволит отображать состояние для представления, но и позволит представлению
подписаться на уведомление о любых изменениях в этом состоянии.
Давайте посмотрим на полную реализацию ViewModel и View (Composable):

```kotlin
class OrderViewModel : ViewModel() {
    // UI's states
    var name by mutableStateOf("")
    private set
    var phone by mutableStateOf("")
    private set

    //UI's Events
    fun onNameChange(): (String) -> Unit = {
        name = it
    }

    fun onPhoneChange(): (String) -> Unit = {
        phone = it
    }

    fun payOrder(): () -> Unit = {
        println("Order generated for $name and phone $phone")
    }
}
```


```kotlin
@Composable
fun OrderScreen(viewModel: OrderViewModel = viewModel()) {

ContactInformation(
name = viewModel.name,
onNameChange = viewModel.onNameChange(),
phone = viewModel.phone,
onPhoneChange = viewModel.onPhoneChange(),
payOrder = viewModel.payOrder()
 )
}

@Composable
fun ContactInformation(
    name: String,
    onNameChange: (String) -> Unit,
    phone: String,
    onPhoneChange: (String) -> Unit,
    payOrder: () -> Unit
) {


Column(
    modifier = Modifier
    .fillMaxSize()
    .padding(8.dp),
    horizontalAlignment = Alignment.CenterHorizontally
 ) {
 TextField(
    label = {
        Text("User name")
    },
    value = name,
    onValueChange = onNameChange
 )
 Spacer(Modifier.padding(5.dp))
TextField(
    label = {
    Text("Phone number")
    },
    value = phone,
    onValueChange = onPhoneChange
 )
 Spacer(Modifier.padding(5.dp))
 Button(
    onClick = payOrder,
 ) {
    Text("Pay order")
 }
 }
 }
```

До сих пор мы видели, что состояния, такие как имя и телефон, являются представлениями переменной ```String```; то есть состояние представляет собой
состояние представляет примитивную переменную. Однако мы можем расширить представление состояния на компоненты и
экранов.
В следующем разделе мы рассмотрим другие варианты представления состояний.

# Структуры, представленные в виде состояний

В Compose и в декларативных представлениях в целом состояния могут представлять различные типы структур пользовательского интерфейса, как показано на рисунке 1.5 ниже.

![](image5.png)

- Свойство состояния пользовательского интерфейса: Это примитивные переменные, представленные в виде состояний. На рисунке 1.5 к этому типу относятся поля ввода текста, такие как имя, телефон или адрес. 

- Состояние компонентного пользовательского интерфейса: Представляют собой состояния, связанные с компонентом, который группирует связанные элементы пользовательского интерфейса. Например, на экране заказа компонент под названием ```ContactInformationForm``` может группировать необходимые данные, такие как контактная информация. Этот компонент может иметь состояния NameValueChanged, PhoneValueChanged и SuccessValidated. - Состояние пользовательского интерфейса экрана: Представляет собой состояния, связанные с экраном, которые можно рассматривать как абсолютные и независимые состояния; например, экран под названием ```OrderScreen``` может иметь следующие состояния: Загрузка, Загружен успешно или Загрузка не удалась. Теперь давайте посмотрим, какие варианты реализации существуют в Android и Kotlin для определения этих состояний.


Свойство состояния UI - это состояние, объявленное на основе переменной примитивного типа, такой как String, Boolean, List или Int, среди прочих. Если оно объявлено во ViewModel (ViewModel как источник истины), то его определение может выглядеть следующим образом:

```kotlin
var name by mutableStateOf("")
private set

var phone by mutableStateOf("")
private set

var address by mutableStateOf("")
private set

var payEnable by mutableStateOf(false)
private set
```

Если он объявлен в View (View как источник истины), то его определение в Composable может быть таким:

```kotlin
var name by remember { mutableStateOf("") }
var phone by remember { mutableStateOf("") }
var address by remember { mutableStateOf("") }
var payEnable by remember { mutableStateOf(false) }
```

remember - это свойство Composable, которое позволяет временно удерживать состояние переменной во время рекомпозиции. Поскольку это Composable, данное свойство может быть определено только в декларативных представлениях, то есть в Composable-функциях. Всегда помните, что для использования делегирования через клавиатуру «by» необходимо импортировать:

```kotlin
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
```

В предыдущих примерах мы говорили только о представлении свойств или переменных через состояния с помощью компонента mutableStateOf. Однако возможно также, что потоки данных могут быть представлены в виде состояний и наблюдаться с помощью Composables. Эти дополнительные возможности связаны с Flow, LiveData и RxJava.


# Состояние компонента пользовательского интерфейса 

Когда у вас есть набор взаимосвязанных элементов пользовательского интерфейса, их состояния могут быть сгруппированы в единую структуру или компонент пользовательского интерфейса с единым состоянием. Например, на рисунке 1.5 элементы Имя пользователя, Номер телефона, Адрес и даже Кнопка оплаты заказа могут быть сгруппированы в один компонент пользовательского интерфейса, а их состояния представлены в одном состоянии, которое называется, например, FormUiState.


```kotlin
data class FormUiState(
    val nameValueChanged: String = "",
    val phoneValueChanged: String = ""
    val addressValueChanged: String = ""
)

 val FormUiState.successValidated: Boolean get() = nameValueChanged.length > 1  && phoneValueChanged.length > 3
```

В этом случае моделирование нескольких состояний в объединенном классе состояний работает очень хорошо, поскольку переменные связаны между собой и даже определяют значение других переменных. Например, это происходит с переменной successValidated, которая зависит от переменных nameValueChanged и phoneValueChanged. Консолидация состояний повышает эффективность реализации, централизует управление и упорядочивает код. Именно этот прием будет чаще всего использоваться в нашей реализации. 

# Состояние экранного пользовательского интерфейса 

Если требуется смоделировать состояния, которые могут быть независимыми и принадлежать к одному семейству, можно использовать следующее определение

```kotlin
sealed class OrderScreenUiState {
data class Success(val order: Order): OrderScreenUiState()
data class Failed(val message: String): OrderScreenUiState()
object Loading: OrderScreenUiState()
 }
```

Такой тип реализации уместен при работе с абсолютными и эксклюзивными состояниями; вы имеете одно состояние или другое, но не оба одновременно. Как правило, простые экраны такого типа, такие как OnboardignScreen или ResultScreen, могут быть смоделированы с помощью этих состояний. Если экран более сложный и содержит множество элементов пользовательского интерфейса, которые работают независимо и имеют множество взаимосвязей, я рекомендую читателю предпочесть определение состояний с помощью методов Property UI' state и Component UI' state.

## Моделирование и группировка событий

Возвращаясь к примеру с экраном заказа, мы рассмотрим моделирование событий и то, как их группировать по аналогии с состояниями. Рассмотрим экран, подобный тому, что показан на следующем рисунке 1.6:

![](image6.png)

ViewModel передает представлению четыре операции (события), каждая из которых используется элементом пользовательского интерфейса View. Анализ этих четырех событий связан с формой для ввода контактной информации пользователя, поэтому имеет смысл сгруппировать их в один тип событий, как показано на следующем рисунке 1.7:

![](image7.png)

Реализация для представления различных типов событий может быть такой:

```kotlin
sealed class ContactFormEvent {
data class OnNameChange(val name: String): FormUiEvent()
data class OnPhoneChange(val phone: String): FormUiEvent()
data class OnAddressChange(val address: String): FormUiEvent()
object PayOrder: FormUiEvent()
 }
```


Наконец, не стоит так строго подходить к упрощению состояний или событий. Необходимо проанализировать преимущества и недостатки каждого использования и принять соответствующие решения. Для связанных компонентов пользовательского интерфейса их группировка имеет большой смысл; для некоторых других сквозных элементов полезнее оставить их независимыми. 


# Резюме 

В этой первой главе мы рассмотрели основные концепции, используемые в современной разработке приложений для Android. Такие понятия, как ```состояния``` и ```события```, ```подъем состояний```, источник истины и однонаправленный поток данных, необходимо понять перед внедрением Jetpack Compose, ViewModels и других архитектурных компонентов, доступных для Android. Именно по этой причине мы начали с этих понятий в этой первой главе. В следующих главах мы рассмотрим определения архитектуры и дизайна в мобильном приложении, для чего будем использовать концепции, представленные в этой главе, в качестве справочника. В дальнейшем будет реализовано мобильное приложение под названием «Заказать сейчас», использующее в качестве концепции электронную коммерцию. В этом приложении будут присутствовать основные элементы электронной коммерции, такие как корзина, список товаров и процесс оформления заказа. Эта работа знакомит читателя с опытом проектирования и разработки, близким к реальному и продуктивному приложению. Но сначала мы применим концепции, изученные в этой главе, для реализации простой формы. Этому будет посвящена следующая глава, описанная ниже.




# Глава 2: Codelab - Практика работы с состояниями


Эта глава представляет собой лабораторную работу по применению концепций, изученных в главе 1: Принципы проектирования. Цель лабораторной работы заключается в следующих реализациях: - Создайте приложение, использующее View в качестве источника истины. - Модификация приложения для использования ViewModel в качестве источника истины. - Группировка состояний и событий для упрощения обмена сообщениями между View и ViewModel. Например, в этой лаборатории мы реализуем часть одного из экранов электронной коммерции. Эта электронная коммерция будет примером приложения, спроектированного и разработанного в книге Глава 3: OrderNow, A Real Application. Экраном будет OrderScreen, который содержит информацию о заказе, запрошенном пользователем, и другие контактные данные пользователя или покупателя. Для упрощения мы реализуем в лаборатории только часть экрана. Цель - отработать различные способы управления состояниями. В разделе «Оформление заказа» - глава 7 - читатель найдет полную реализацию экрана.


Задача состоит в том, чтобы реализовать форму с двумя полями: - Имя пользователя - Номер телефона. Кроме того, кнопка «Оплатить заказ» будет включаться или выключаться в зависимости от правильности проверки полей «Имя пользователя» и «Номер телефона». Ниже показаны различные варианты реализации.


# View как источник истины 

Первый шаг - определить, какие элементы пользовательского интерфейса могут изменяться и представлять состояния на экране. В данном случае это будут: - Текстовое значение, введенное для имени пользователя. - Текстовое значение, введенное для номера телефона. - Включение/выключение свойства кнопки «Оплатить заказ». Поэтому в View (Composables) мы можем представить свойства следующим образом:

```kotlin
var name by remember { mutableStateOf("") }
var phone by remember { mutableStateOf("") }
```

А как насчет состояния (включить/выключить) свойства кнопки «Оплатить заказ»? В данном случае это состояние является производным от двух других состояний: имени и телефона. Поэтому это состояние не требует дополнительного определения. Код представления может выглядеть следующим образом:

```kotlin
@Composable
fun OrderScreen() {

var name by remember { mutableStateOf("") }
var phone by remember { mutableStateOf("") }

ContactInformation(
name = name,
onNameChange = { name = it },
phone = phone,
onPhoneChange = { phone = it })
}

@Composable
fun ContactInformation(
name: String,
onNameChange: (String) -> Unit,
phone: String,
onPhoneChange: (String) -> Unit
) {

Column(
modifier = Modifier
.fillMaxSize()
.padding(8.dp),
 horizontalAlignment = Alignment.CenterHorizontally,
 ) {
 TextField(
 label = {
 Text("User name")
 },
 value = name,
 onValueChange = onNameChange
 )
 Spacer(Modifier.padding(5.dp))
 TextField(
 label = {
 Text("Phone number")
 },
 value = phone,
 onValueChange = onPhoneChange
 )
 Spacer(Modifier.padding(5.dp))
 Button(
 onClick = {
 println("Order generated for $name and phone $phone")
 },
 enabled = name.length > 3 && phone.length > 4
 ) {
 Text("Pay order")
 }
 }
 }
```

А как насчет событий? В данном примере экрана идентифицированными событиями являются: - Событие при изменении «Имени пользователя». - Событие при изменении «Номера телефона». - Событие при выборе (нажатии) кнопки «Оплатить заказ». Управление этими событиями осуществляется следующим образом:

```kotlin
//User name changed
onNameChange = { name = it }

 ...
 //Phone number changed
 onPhoneChange = { phone = it }

 //Pay order clicked
 Button(
 onClick = {
 println("Order generated for $name and phone $phone")
 },
 ...
 )
```

И состояния, и события управляются View, а это значит, что View - единственный источник истины на экране.



# «ViewModel» как источник истины 

Во втором варианте реализации мы представим еще один агент - ViewModel¹⁰. ViewModel, как я уже говорил в первой главе, - это архитектурный компонент, который мы должны включать в наши приложения. Этот компонент является ключом к разделению ответственности в представлениях и частью презентационного слоя мобильного приложения. ViewModel можно интегрировать двумя способами: с помощью ручной настройки или менеджера зависимостей.




В этой лабораторной работе мы включим его вручную, однако в главе 7: «Реализация функций» будет показано, как включить его через менеджер зависимостей Hilt¹¹. Как и в предыдущем варианте, первым делом необходимо определить состояния и события на экране. Поскольку они уже определены, следующим шагом будет передача их из View в ViewModel следующим образом:


```kotlin
class OrderViewModel : ViewModel() {

// UI's states
var name by mutableStateOf("")
private set
var phone by mutableStateOf("")
private set

//UI's Events
fun onNameChange(): (String) -> Unit = {
name = it
 }

fun onPhoneChange(): (String) -> Unit = {
phone = it
}

fun payOrder(): () -> Unit = {
println("Order generated for $name and phone $phone")
}
}

```

В предыдущем коде ViewModel мы видим определение состояний и событий. Как нам связать ViewModel с View? В представлении мы включаем определение ViewModel, и в то же время она инстанцируется следующим образом:

```kotlin
@Composable
fun OrderScreen(viewModel: OrderViewModel = viewModel()) {

ContactInformation(
    name = viewModel.name,
    onNameChange = viewModel.onNameChange(),
    phone = viewModel.phone,
    onPhoneChange = viewModel.onPhoneChange(),
    payOrder = viewModel.payOrder()
)
}
```

Пожалуйста, не забудьте! Чтобы включить ViewModel вручную, необходимо, чтобы в проекте были необходимые зависимости, которые Google документирует в ViewModel, объявляя зависимости¹²:

```kotlin
dependencies {
2 def lifecycle_version = "2.5.0-rc01"
3
4 // ViewModel
5 implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"
6
7 // ViewModel utilities for Compose
8 implementation "androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version"
9 }

```

Полная реализация этого представления будет выглядеть следующим образом: 

```kotlin
@Composable
2 fun OrderScreen(viewModel: OrderViewModel = viewModel()) {
3
4 ContactInformation(
5 name = viewModel.name,
6 onNameChange = viewModel.onNameChange(),
7 phone = viewModel.phone,
8 onPhoneChange = viewModel.onPhoneChange(),
9 payOrder = viewModel.payOrder()
10 )
11 }
12
13 @Composable
14 fun ContactInformation(
15 name: String,
16 onNameChange: (String) -> Unit,
17 phone: String,
18 onPhoneChange: (String) -> Unit,
19 payOrder: () -> Unit
20 ) {
21
22 Column(
    modifier = Modifier
24 .fillMaxSize()
25 .padding(8.dp),
26 horizontalAlignment = Alignment.CenterHorizontally
27 ) {
28 TextField(
29 label = {
30 Text("User name")
31 },
32 value = name,
33 onValueChange = onNameChange
34 )
35 Spacer(Modifier.padding(5.dp))
36 TextField(
37 label = {
38 Text("Phone number")
39 },
40 value = phone,
41 onValueChange = onPhoneChange
42 )
43 Spacer(Modifier.padding(5.dp))
44 Button(
45 onClick = payOrder,
46 enabled = name.length > 3 && phone.length > 4
47 ) {
48 Text("Pay order")
49 }
50 }
51 }
```

В этом втором варианте реализации мы видим, что и состояния, и события делегируются ViewModel; таким образом, ViewModel становится источником истины. С изменением источника истины дизайн приобретает гибкость в применении централизованной бизнес-логики или логики представления к ViewModel. На данный момент у нас есть правильная и рабочая реализация. Но ее можно улучшить за счет определения состояния компонентного пользовательского интерфейса, как мы увидим далее. 


# Группировка «состояний» 

В приведенном выше примере видно, что поля являются частью формы. Даже состояние кнопки зависит от полей формы. Поэтому имеет смысл сгруппировать эти элементы пользовательского интерфейса в один содержащий их элемент пользовательского интерфейса. Поскольку в примере всего три элемента пользовательского интерфейса, преимущества их группировки могут быть не столь очевидны; однако давайте подумаем об экране, на котором есть множество других разделов с множеством других элементов пользовательского интерфейса. Прежде всего, нужно сгруппировать состояния в структуре FormUiState следующим образом: 


```kotlin
data class FormUiState(
2 val name: String = "",
3 val phone: String = ""
4 )
5
6 val FormUiState.successValidated: Boolean get() = name.length > 3
7 && phone.length > 4
```

Читатель заметит, что группировка событий похожа на технику, описанную в разделе «Состояние экранного пользовательского интерфейса» первой главы. Помните, что это применимо, поскольку различные типы событий, которые мы определяем, связаны между собой, но могут быть взаимоисключающими и независимыми. В ViewModel сообщения упрощаются до одного следующим образом:

```kotlin
class OrderViewModel : ViewModel() {
2
3 // UI's states
4 var formUiState by mutableStateOf(FormUiState())
5 private set
6
7 //UI's Events
8 fun onFormEvent(formEvent: FormUiEvent) {
9 when (formEvent) {
10 is FormUiEvent.OnNameChange -> {
11 formUiState = formUiState.copy(name = formEvent.name)
12 }
13 is FormUiEvent.OnPhoneChange -> {
14 formUiState = formUiState.copy(phone = formEvent.phone)
15 }
16 is FormUiEvent.PayOrderClicked -> {
17 println("Sending form with parameters:
18 ${formUiState.name} and ${formUiState.phone}")
19 }
20 }
21 }
22 }
```

С точки зрения View, реализация будет такой:

```kotlin
@Composable
2 fun OrderScreen(viewModel: OrderViewModel = viewModel()) {
3
4 ContactInformation(
5 name = viewModel.formUiState.name,
6 onNameChange = { viewModel.onFormEvent(FormUiEvent.OnNameChange(it)) },
7 phone = viewModel.formUiState.phone,
8 onPhoneChange = { viewModel.onFormEvent(FormUiEvent.OnPhoneChange(it)) },
9 payOrder = { viewModel.onFormEvent(FormUiEvent.PayOrderClicked) },
10 isValidPayOrder = viewModel.formUiState.successValidated
11 )
12 }
13
14 @Composable
15 fun ContactInformation(
16 name: String,
17 onNameChange: (String) -> Unit,
18 phone: String,
onPhoneChange: (String) -> Unit,
20 payOrder: () -> Unit,
21 isValidPayOrder: Boolean
22 ) {
23
24 ...
25 }
```

Дополнительный бонус 

Некоторые читатели, возможно, заметили, что я поместил логику проверки полей в структуру состояния FormUiState. Поскольку логика зачастую сложнее, чем проверка длины символов, лучше всего делегировать задачу проверки и валидации во ViewModel. Итак, следующие изменения добавлены во ViewModel и FormUiState:

```kotlin
// Business's logic or maybe some UI's logic for update the state
2 companion object {
3 fun applyLogicToValidateInputs(name: String, phone: String): Boolean {
4 return name.length > 1 && phone.length > 3
5 }
6 }
```

```kotlin
data class FormUiState(
2 val name: String = "",
3 val phone: String = ""
4 )
5
6 val FormUiState.successValidated: Boolean get() =
7 OrderViewModel.applyLogicToValidateInputs(name, phone)
```

Теперь вся логика находится на стороне ViewModel. 


# Резюме 

В этой главе мы рассмотрели способы управления состояниями и событиями, используя представления или ViewModel в качестве источника истины. Кроме того, мы использовали некоторые приемы для лучшей организации состояний и событий в структурах; для более организованной и простой реализации. В следующей главе мы рассмотрим приложение «Заказать сейчас», электронную коммерцию, которое мы будем реализовывать на протяжении всей книги, чтобы объяснить концепции и методы разработки современных приложений для Android.




# Глава 3: OrderNow, реальное приложение 


## О приложении 

```OrderNow``` - это пример минимального жизнеспособного продукта (MVP) мобильного приложения для электронной коммерции, которое мы будем разрабатывать и реализовывать на протяжении всей этой книги. Мы будем использовать это приложение в качестве примера для применения концепций, изученных в каждой главе книги. Реализация решения для электронной коммерции позволит нам ближе познакомиться с задачами, которые ставит перед нами точное и продуктивное приложение. Ниже перечислены основные функции электронной коммерции, которые мы будем развивать в ```OrderNow```:
- Представление списка категорий.
- Представление списка товаров по категориям.
- Представление подробной информации о конкретном продукте.
- Управление товарами (добавление и удаление) в корзине.
- Просматривать список товаров, выбранных для покупки.
- Заполнение информации и данных для совершения покупки (оформление заказа).
- Моделирование процесса оплаты. 

# Экраны 

Экранами, относящимися к различным функциональным возможностям, являются:

- Главная 
- Список товаров 
- Детали товаров 
- Корзина 
- Оформление заказа 
- Размещение заказа


# Home, Product List and Product Detail


![](image8.png)


# Cart and Checkout

![](image9.png)

# Place Order


![](image10.png)






# Технологии

Этот раздел представляет собой краткое изложение технических характеристик OrderNow, чтобы читатель знал, какие инструменты
и руководство по проектированию, которые будут использоваться при реализации.
Помните, что это предложение по внедрению. Читатель может самостоятельно принять решение о замене или включении
другой инструмент, с которым у него есть опыт или с которым ему удобно работать.

# Руководство по проектированию и архитектуре
В главах «Глава 1: Принципы проектирования» и «Глава 4: Архитектура приложения» документируются рекомендации по проектированию и
архитектуры, то есть минимальной жизнеспособной архитектуры (MVA)¹⁶, которая будет использована для разработки OrderNow.
использована для разработки OrderNow.


Компоненты архитектуры 

- Compose¹⁷: Это будет фреймворк для реализации декларативных представлений в нашем презентационном слое. 
- ViewModel¹⁸: Архитектурный компонент в слое представления, который мы используем для инкапсуляции бизнес-логики. 
- Flow¹⁹: Мы будем использовать корутины Flow для реактивного программирования в нашем приложении. Flow позволит сообщениям между компонентами приложения, как синхронным, так и асинхронным, выполняться наиболее оптимальным образом. 
- Навигация²⁰: Архитектурный компонент, который мы будем использовать для реализации навигации по различным экранам нашего приложения. 

# Зависимости 
- Coil²¹: Библиотека для загрузки удаленных или локальных изображений в наше APP, на языке Kotlin и с поддержкой Jetpack Compose. 

За рамками книги 

Некоторые темы исключены из содержания книги не потому, что они менее важны, а скорее для того, чтобы сузить рамки и достичь конкретных целей. Попытка охватить все связанные с Android-приложением темы может привести к чрезмерному расширению содержания и отвлечь нас от основных концепций, которые должны быть ясны с самого начала. 
Следующие возможности не включены и выходят за рамки примера MVP:

 - Руководство по проектированию UI/UX.
 - Компоненты аутентификации и авторизации.
 - Тестирование. 
 - Доступность. 
 
 # Резюме 
 
 В этой небольшой главе кратко описаны технологии и компоненты, использованные при реализации ```OrderNow```. Читатель не только получит исходный код и попытается угадать, как он был построен, но и узнает о каждом решении, принятом на дизайнерском и техническом уровнях реализации. В следующей главе я опишу архитектуру и проектные решения в примере App.








# Глава 4: Архитектура приложения

Выбор стиля Архитектура, которой мы будем следовать при создании OrderNow, основана на передовом опыте и архитектурном руководстве, рекомендованном Google в Guide to app architecture²². Эти определения включают некоторые принципы Clean Architecture²³ для определения компонентов на различных уровнях. Определение слоев В приложении мы определим следующие основные слои: 

- ```UI Layer``` 
- ```Domain Layer``` 
- ```Data Layer``` 

## UI Layer 

Этот слой группирует элементы пользовательского интерфейса, представления (композитные функции), ViewModels и утилиты презентационного слоя, такие как приложения формата и анимации. При проектировании этого слоя необходимо учитывать следующие моменты:


При работе с состояниями следуйте принципам, описанным в главе 1:

Принципы проектирования.

 - Для каждого экрана будет реализована соответствующая ViewModel.
 - ViewModel также будут функционировать как держатели состояний, то есть менеджеры состояний.
 - Логика навигации будет делегирована представлению и будет зависеть от состояния APP.
 - Побочные эффекты должны сообщаться ViewModel.
 - ```ViewModel``` должны сохранять свои состояния при изменении конфигурации
 - Приветствуется использование представлений без состояния.

![](image11.png)


## Слой домена 


Хотя этот слой может быть необязательным, я рекомендую его включить, чтобы сохранить дизайн, соответствующий разделению обязанностей, продиктованному Clean Architecture. Этот слой группирует компоненты, называемые UseCases, которые управляют бизнес-логикой и всей той логикой, которую могут повторно использовать ViewModels. Этот слой также служит мостом между слоем пользовательского интерфейса и слоем данных. Компоненты типа Models также относятся к этому слою. Эти компоненты моделируют сущности или структуры данных, используемые слоем представления или слоем домена. Например, в OrderNow и Product, и Category представляют собой модели или сущности.

![](image12.png)


При проектировании этого слоя следует учитывать следующие соображения:

- Вся логика представления, дублируемая в представлениях, может быть помещена в UseCase.
- Компоненты, принадлежащие к этому слою, могут быть stateless; это компоненты, не требующие временного сохранения.
- Операции, выполняемые UseCase, должны быть безопасными для основной части.

- UseCases могут взаимодействовать друг с другом для организации операций use case.
- Каждый UseCases отвечает за одну и только одну операцию.
- Каждый UseCases может использовать один или несколько репозиториев.



## Уровень данных 

На этом уровне сгруппированы компоненты, называемые репозиториями, которые организуют и инкапсулируют логику интеграции с локальными и удаленными источниками данных. Как следует из названия, они следуют шаблону Repository²⁴. Другими компонентами этого слоя являются источники данных, мапперы и DTO. 

- Источник данных: Содержит логику интеграции с внешними или локальными источниками персистентности. 
- DTO: (Data Transfer Object)²⁵ Это структура, которая моделирует объект персистентности. Содержит определения, используемые механизмом персистентности. Чтобы другие уровни (UI и Domain) не унаследовали эти определения, эти типы сущностей переводятся в модели домена приложения с помощью мапперов. 
- Мапперы: Они преобразуют DTO в модели сущностей доменного слоя. 

При проектировании этого слоя рекомендуется учитывать следующие соображения: 

- Этот слой может использоваться в качестве источника истины. 
- Операции, выполняемые Репозиториями, должны быть безопасными для основных ресурсов. 
- Для каждого первичного типа сущности определяется один репозиторий, например, ProductRepository, CategoryRepository.

![](image13.png)

## Общая архитектура 

Общая схема с различными интегрированными слоями выглядит следующим образом:

![](image14.png)


О других слоях Другими вспомогательными слоями, дополняющими основные слои архитектуры, будут: - Main: Содержит базовые артефакты приложения, такие как MainActivity, Application, ApplicationState и другие. - Общий: Содержит артефакты, относящиеся к различным приложениям, такие как определения навигации, утилиты, используемые для других слоев, менеджер зависимостей и т. д. По поводу использования портов Clean Architecture рекомендует включать порты между границами различных слоев²⁶. Эта техника позволяет инвертировать управление, развязывая компоненты, которые взаимодействуют между границами каждого слоя. Такой подход повышает уровень ремонтопригодности и адаптивности конструкции. В нашем примере приложения (OrderNow) будут добавлены порты между слоем домена и слоем данных


![](image15.png)



# Организация каталогов 


В нашем примере OrderNow для простоты слои будут организованы монолитно через каталоги в одном модуле. Я оставляю на усмотрение читателя, если позже в своих проектах он решит разделить слои, выделив для каждого из них отдельный модуль. Организация по каталогам осуществляется с помощью двух определений: - В слое UI будет использоваться организация по функциям. - В Domain Layer и Data Layer будет использоваться организация по компонентам.


![](image16.png)


Номенклатура и элементы именования 

Для именования компонентов мы будем использовать следующие правила Использование суффиксов Суффикс будет использоваться в имени компонента только в том случае, если:

- По имени содержащего пакета нельзя определить его тип.
- Необходимо указать тип структуры, которую представляет компонент, например ProductRepository.
- Чтобы избежать путаницы между типами компонентов, например, модель может называться Category, а ее хранилище - CategoryRepository. 

![](image17.png)

Именование пакетов Имена пакетов приложений должны быть строчными, без разделителей и заглавных букв.

![](image18.png)


Именование компонентов Для названия компонентов типа UseCases в качестве префикса используется действие, представляющее операцию в случае использования (do, get, update, save, send, delete, add).


![](image19.png)

## Именование композитных функций

![](image20.png)

Для определения компонентов пользовательского интерфейса, то есть функций Composables, будут использоваться следующие обозначения, за основу которых взята документация Google²⁷ в руководстве по архитектуре: Screen: Суффикс, используемый для композитов, которые представляют весь экран. UI: Суффикс, используемый для компонентов, которые объединяют состояния представления (UI State) с графическим представлением компонентов (UI Elements). Elements: Суффикс, используемый для составных элементов, определяющих компоненты библиотеки пользовательского интерфейса (кнопки, макеты, флажки, текстовые поля и т. д.), из которых состоит представление. Preview: Префикс, используемый для композитов предварительного просмотра представлений (Elements). Составные элементы экрана и пользовательского интерфейса также могут быть предварительно просмотрены, но это становится более сложным из-за зависимости от состояний и других переменных. Следует помнить, что могут быть исключения, когда не обязательно определять все типы композитов и опускать определение некоторых. В зависимости от степени сложности экранов будет решено, какие из них применимы, а какие нет. 

# Резюме 

В этой главе я хотел описать определения архитектуры, которым необходимо следовать перед началом реализации. Также были разъяснены правила, используемые для организации проекта приложения. Должен оговориться, что определения, приведенные в этой главе, являются рекомендациями. Читатель сможет внести свои коррективы или использовать те соглашения и правила, которые ему больше подходят или с которыми он чувствует себя комфортно в своих реализациях. В следующей главе мы приступим к реализации ```OrderNow```, и первое, что будет построено, - это его скелет, то есть основная структура. 


# Глава 5: Скелет: Основная структура Создание экранов и ViewModels 


В предыдущих главах мы уже разобрали теоретические концепции и организацию, которую мы придадим проекту OrderNow. В этой главе мы начнем с реализации начальной структуры и шаблона, который будет объединять все части приложения. 

Первым шагом будет добавление следующих основных экранов с соответствующими ViewModels:

- Главная 
- Список товаров 
- Детализация товаров 
- Корзина 

Пример добавленных элементов показан на следующем рисунке 5.1:

![](image21.png)


Мы будем использовать менеджер зависимостей Hilt²⁹ в приложении, чтобы привязать каждую ViewModel к соответствующему экрану.
Для этого мы должны сначала установить Hilt в приложение, как указано в статье Google Установка Hilt³⁰.
В процессе установки Hilt будет запрошено определение класса типа Application, который в
нашем примере это будет OrderNowApplication, как показано ниже:


```kotlin
@HiltAndroidApp
2 class OrderNowApplication: Application()
```
Не забудьте также зарегистрировать класс OrderNowApplication в файле AndroidManifiest.xml: 

```xml
<application
2 android:name=".main.OrderNowApplication"
3 android:allowBackup="true"
4 ... >

```

Кроме того, мы устанавливаем в проект библиотеку Navigation Compose, которая позволит представлению (Composable) получать экземпляр соответствующей ViewModel во время навигации:

```
dependencies {
2 implementation 'androidx.hilt:hilt-navigation-compose:1.0.0'
3 }
```

После того как предыдущая настройка в проекте выполнена правильно, мы можем внедрить ViewModel в представление следующим образом³¹:

```kotlin
@HiltViewModel
2 class HomeViewModel @Inject constructor() : ViewModel() {
3 ...
4 }
```

```kotlin
@Composable
2 fun HomeScreen(viewModel: HomeViewModel = hiltViewModel()
3 ) {
4 ...
5 }
```

Каждый экран будет связан с соответствующей ViewModel через менеджер зависимостей Hilt. До этого момента мы интегрировали следующие компоненты архитектуры: Compose, Navigation и ViewModel. Это идеальное сочетание инструментов с помощью Jetpack, и в последующих главах мы увидим его потенциал в мобильной разработке. Спасибо, команда Google, вы лучшие!



# Паттерны пользовательского интерфейса: TopAppBar и BottomAppBar 


С помощью компонента Scaffold мы можем реализовать в наших приложениях два наиболее распространенных паттерна пользовательского интерфейса в Material Design: TopAppBar и BottomAppBar. Scaffold³³ - это детальное представление (композитное), которое позволит нам реализовать эти паттерны следующим образом: 

```kotlin
Scaffold(
2 topBar = {
3 TopAppBar { /* Top app bar content */ }
4 },
5 bottomBar = {
6 BottomAppBar { /* Bottom app bar content */ }
7 }
8 ) { contentPadding ->
9 // Screen content
10 }
```
Легко, не правда ли? В фрагменте кода 5.6 мы определяем topBar, bottomBar и (еще не добавленное) содержимое экрана. В Scaffold секции topBar и bottomBar являются необязательными; то есть определение некоторых из этих частей можно опустить. Кроме того, в Scaffold есть еще два компонента, которые мы можем объявить:

- scaffoldState - snackbarHost В следующей главе мы увидим, как используется каждый из них. А сейчас давайте ограничимся определением topBar и bottomBar. Теперь, когда мы знаем, как включить эти шаблоны пользовательского интерфейса в наше приложение, следующим шагом будет создание представлений (composables), представляющих TopAppBar и BottomAppBar. Организуется каталог под названием patterns, и в него добавляются два представления, OrderNowTopBar и OrderNowBottomBar, следующим образом: 

![](image22.png)



# OrderNowTopBar 

Реализация OrderNowTopBar очень проста. Изначально нам нужно реализовать его следующим образом:

```kotlin
@Composable
2 fun OrderNowTopBar() {
3 TopAppBar(
4 title = {
5 Text(
6 text = stringResource(id = AppString.app_name),
7 textAlign = TextAlign.Center,
8 modifier = Modifier.fillMaxWidth()
9 )
10 },
backgroundColor = MaterialTheme.colors.background,
12 contentColor = contentColorFor(MaterialTheme.colors.background)
13 )
14 }
```

Предыдущая реализация пока не содержит таких элементов, как опция возврата назад; однако в разделе «Добавление „Назад“ на панель TopAppBar» в главе 7 она будет включать такую опцию навигации с помощью стратегии, использующей состояние.


# OrderNowBottomBar 

Реализация OrderNowBottomBar может быть немного более сложной, поскольку нам нужно включить навигацию между экранами. Однако мы оставим эту деталь реализации для следующей главы, Navegación en la aplicación. Пока же мы приведем статическое определение без навигации.


```kotlin
@Composable
2 fun OrderNowBottomBar() {
3 val selectedIndex = remember { mutableStateOf(0) }
4 BottomNavigation(
5 backgroundColor = MaterialTheme.colors.background,
6 contentColor = contentColorFor(MaterialTheme.colors.background),
7 elevation = 10.dp
8 ) {
9 BottomNavigationItem(icon = {
10 Icon(imageVector = Icons.Default.Home, "")
11 },
12 label = { Text(text = "Home") },
13 selected = (selectedIndex.value == 0),
14 unselectedContentColor = Color.Gray,
15 selectedContentColor = orange,
16 onClick = {
17 selectedIndex.value = 0
18 })
19
20 BottomNavigationItem(icon = {
21 Icon(imageVector = Icons.Default.ShoppingCart, "")
22 },
23 label = { Text(text = "Cart") },
24 selected = (selectedIndex.value == 1),
25 unselectedContentColor = Color.Gray,
26 selectedContentColor = orange,
27 onClick = {
28 selectedIndex.value = 1
})
30 }
31 }
```

На данный момент у нас уже есть определения экранов, ViewModels и Scaffold (который включает OrderNowBottomBar и OrderNowTopBar). Следующий шаг - собрать все части воедино, и мы сделаем это в следующем разделе.


# Собираем все вместе 

Первой задачей является создание каталога под названием main. Эта директория будет сквозной и будет содержать базовые классы или структуры приложения. Внутри этой директории мы разместим класс Application, переместим туда MainActivity и главный экран приложения, который мы назовем OrderNowScreen, как показано на следующем изображении.

![](image23.png)

Теперь мы изменим класс MainActivity.kt так, чтобы он загружал экран входа в приложение OrderNowScreen следующим образом:

```kotlin
@AndroidEntryPoint
2 class MainActivity : ComponentActivity() {
3 override fun onCreate(savedInstanceState: Bundle?) {
4 super.onCreate(savedInstanceState)
5 setContent {
6 OrderNowScreen()
7 }
8 }
9 }
```

Затем в представлении OrderNowScreen мы определяем Scaffold нашего приложения следующим образом:

```kotlin
@Composable
2 fun OrderNowScreen() {
3 InitialSkeletonTheme {
4 Surface(
5 modifier = Modifier.fillMaxSize(),
6 color = MaterialTheme.colors.background
7 ) {
8 Scaffold(
9 topBar = { OrderNowTopBar() },
10 bottomBar = { OrderNowBottomBar() }
11 ) { contentPadding ->
12 println(contentPadding)
13 }
14 }
15 }
16 }
```

Когда вы запустите приложение, результат должен быть похож на следующее изображение:

![](image24.png)

# Резюме

В этой главе мы создали начальную структуру проекта OrderNow. Определенные и реализованные здесь компоненты станут основой для продолжения работы над навигацией в следующей главе. По мере продвижения по главам мы будем улучшать реализацию каждого компонента OrderNow, чтобы в результате наша электронная коммерция была спроектирована и реализована наилучшим образом. 