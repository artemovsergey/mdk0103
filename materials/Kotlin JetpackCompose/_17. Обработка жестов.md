# Обработка жестов
## Жесты нажатия


Jetpack Compose предоставляет функционал для работы с распространенными жестами (касание, двойное касание, длительное нажатие и перетаскивание, масштабирование, вращение, смахивание и т.д.). Причем в некоторых случаях Compose предоставляет два способа обнаружения жестов. Один из подходов предполагает использование модификаторов обнаружения жестов. Другой подход - применение функций интерфейса PointerInputScope, которые требуют дополнительного написания кода, но предоставляют более продвинутые возможности работы с жестами.

Первый подход уже был ранее частично рассмотрен. В частности, с помощью модификатора clickable можно обнаружить касание на компоненте. Этот модификатор принимает функцию (лямбду), которая выполняется при касании/нажатии на компоненте, к которому применяется этот модификатор. Например:

```kotlin
Text(
    "Click",  
    Modifier.clickable { 
        // здесь обработка нажатия 
    }
)
```

Проблема данного модификатора состоит в том, что он не может различать различные типы жестов - касания, нажатия, длинные нажатия и двойные нажатия. Для этого уровня точности нам нужно использовать функцию detectTapGestures() класса PointerInputScope. Эта функция применяется к компоненту через модификатор pointerInput(), который дает нам доступ к PointerInputScope следующим образом:

```kotlin
Text(
    "Click",
    Modifier
        .pointerInput(Unit) {
            detectTapGestures(
                onPress = { /* обработка нажатия */ },
                onDoubleTap = { /* обработка двойного нажатия */ },
                onLongPress = { /* обработка долгого нажатия */ },
                onTap = { /* обработка простого касания */ }
            )
        }
)
```

Рассмотрим небольшой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var tapType by remember { mutableStateOf("Undefined") }
 
            Column(Modifier.fillMaxSize()) {
                Box(
                    Modifier
                        .padding(10.dp)
                        .background(Color.DarkGray)
                        .size(200.dp)
                        .pointerInput(Unit) {
                            detectTapGestures(
                                onPress = { tapType = "onPress" },
                                onDoubleTap = { tapType = "onDoubleTap" },
                                onLongPress = { tapType = "onLongPress" },
                                onTap = { tapType = "onTap" }
                            )
                        }
                )
                Text(tapType, Modifier.padding(10.dp), fontSize = 25.sp)
            }
        }
    }
}
```

В данном случае по нажатию на темно-сервый квадрат в модиифкаторе pointerInput перехватываем тип нажатия и выводим его в текстовое поле.

![](https://metanit.com/kotlin/jetpack/pics/18.1.png)








# Петаскивание

Модификатор draggable() позволяет определить жесты перетаскивания на компоненте. Этот модификатор сохраняет смещение (или дельту) движения перетаскивания от исходной точки по мере его возникновения и сохраняет его в состоянии, которое создается с помощью функции rememberDraggableState(). Это состояние затем можно использовать, например, для перемещения перетаскиваемого компонента в соответствии с жестом. Определение функции модификатора:

```kotlin
Modifier.draggable(
    state: DraggableState,
    orientation: Orientation,
    enabled: Boolean = true,
    interactionSource: MutableInteractionSource? = null,
    startDragImmediately: Boolean = false,
    onDragStarted: suspend CoroutineScope.(startedPosition: Offset) -> Unit = {},
    onDragStopped: suspend CoroutineScope.(velocity: Float) -> Unit = {},
    reverseDirection: Boolean = false
)
```

Параметры модификатора:

state: состояние типа DraggableState, которое хранит информацию об операции перетаскивания.

orientation: направоение пертаскивания. Может быть горизонтальным (значение Orientation.Horizontal), либо вертикальным (Orientation.Vertical)

enabled: доступна ли операция перетаскивания

interactionSource: объект MutableInteractionSource, который будет использоваться для генерации DragInteraction.Start при начале перетаскивания.

startDragImmediately: если установлено значение true, то перетаскивание начнется немедленно. Предназначено для того, чтобы конечные пользователи могли "поймать" анимируемый компонент, нажав на него.

onDragStarted: suspend-функция, которая вызывает при начале перетаскивания

onDragStopped: suspend-функция, которая вызывает после завершения перетаскивания.

reverseDirection: изменяет направление прокрутки на обратное (прокрутка сверху вниз будет вести себя как снизу вверх, а слева направо — как справа налево).

При вызове модификатора draggable() необходимо указать как минимум два параиметра - состояние перемещения и его тип - по горизонтали или по вертикали.

Рассмотрим небольшой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.draggable
import androidx.compose.foundation.gestures.rememberDraggableState
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlin.math.roundToInt
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var xOffset by remember { mutableStateOf(0f) }
            Column(Modifier.fillMaxSize()) {
                Box(
                    Modifier
                        .offset { IntOffset(xOffset.roundToInt(), 20) }
                        .background(Color.DarkGray)
                        .size(150.dp)
                        .draggable(
                            orientation = Orientation.Horizontal,
                            state = rememberDraggableState { distance ->
                                xOffset += distance
                            }
                        )
                )
                Text("xOffset: $xOffset", Modifier.padding(10.dp), fontSize=22.sp)
            }
        }
    }
}
```

В данном случае применяется перетаскивание по горизонтали. Для его отслеживания определяем сначала состояние xOffset:

```kotlin
var xOffset by remember { mutableStateOf(0f) }
```

Для перетаскивания определяем компонент Box, x-координата которого будет привязана к состоянию xOffset:

```kotlin
Box(
    Modifier
        .offset { IntOffset(xOffset.roundToInt(), 20) }
```

Далее к этому компоненту Box применяется модификатор draggable, который использует горизонтальную ориентацию. Параметр состояния устанавливается путем вызова функции rememberDraggableState(), в которой концевая лямбда-выражение используется для получения текущего значения дельты перемещения для получения обновленного состояния xOffset. Это, в свою очередь, приводит к перемещению поля в направлении жеста перетаскивания:

```kotlin
.draggable(
    orientation = Orientation.Horizontal,
    state = rememberDraggableState { distance ->
        xOffset += distance
    }
)
```

И для большей наглядности определен компонент Text, который выводит значение xOffset:

![](https://metanit.com/kotlin/jetpack/pics/18.2.png)








# Перетаскивание с помощью PointerInputScope

В прошлой теме был рассмотрен модификатор draggable(), который позволяет нам реализовать перетаскивание компонента. Однако этот модификатор имеет ограничение: одновременно он может использовать либо перетаскивание по горизонтали, либо по вертикали. Функция detectDragGestures() типа PointerInputScope решает эту проблему и позволяет нам одновременно поддерживать операции горизонтального и вертикального перетаскивания. Эта функция имеет следующие параметры:

```kotlin
suspend fun PointerInputScope.detectDragGestures(
    onDragStart: (Offset) -> Unit = { },
    onDragEnd: () -> Unit = { },
    onDragCancel: () -> Unit = { },
    onDrag: (change: PointerInputChange, dragAmount: Offset) -> Unit
): Unit
```

- onDragStart: функция, которая вызывается при начале перетаскивания

- onDragEnd: функция, которая вызывается после завершения перетаскивания

- onDragCancel: функция, которая вызывается при отмене перетаскивания

- onDrag: функция, которая вызывается при перетаскивания

Нам достаточно задать последний параметр для управления перетаскиваемым компонентом. И обработка перетаскивания в общем случае будет выглядеть примерно следующим образом:

```kotlin
Modifier.pointerInput(Unit) {
    detectDragGestures { _, distance ->
        xOffset += distance.x
        yOffset += distance.y
    }
}
```

Рассмотрим небольшой пример:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.draggable
import androidx.compose.foundation.gestures.rememberDraggableState
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.material3.Text
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlin.math.roundToInt
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var xOffset by remember { mutableStateOf(0f) }
            var yOffset by remember { mutableStateOf(0f) }
             
            Column(Modifier.fillMaxSize()) {
                Text("xOffset: $xOffset ; yOffset: $yOffset", Modifier.padding(10.dp), fontSize=22.sp)
                Box(
                    Modifier
                        .offset { IntOffset(xOffset.roundToInt(), yOffset.roundToInt()) }
                        .background(Color.DarkGray)
                        .size(150.dp)
                        .pointerInput(Unit) {
                            detectDragGestures { _, distance ->
                                xOffset += distance.x
                                yOffset += distance.y
                            }
                        }
                )
            }
        }
    }
}
```

Для отслеживания перетаскивания как по горизонтали, так и по вертикали, определяются две переменных состояния для хранения смещений по оси X и Y:

```kotlin
var xOffset by remember { mutableStateOf(0f) }
var yOffset by remember { mutableStateOf(0f) }
```

К их значениям привязаны координаты компонента Box:

```kotlin
Box(
    Modifier.offset { IntOffset(xOffset.roundToInt(), yOffset.roundToInt()) }
```

В лямбда-выражение в функции detectDragGestures передается параметр distance, который представляет объект Offset и из которого мы можем получить последние значения смещения перетаскивания по осям x и y. Они добавляются к состояниям xOffset и yOffset соответственно, в результате чего компонент Box следует за движением перетаскивания по экрану:

```kotlin
.pointerInput(Unit) {
    detectDragGestures { _, distance ->
        xOffset += distance.x
        yOffset += distance.y
    }
}
```

И для наглядности координаты перемещения выводятся на экран ыв компоненте Text:

![](https://metanit.com/kotlin/jetpack/pics/18.3.png)




# Перетаскивание по опорным точкам

Кроме обычного возможности обычного перетаскивания Jetpack Compose также позволяет перетаскивать компоненты вдоль некоторой фиксированной линии, которая основана на двух или более опорных точках (anchor points). Каждая опорная точка имеет фиксированные положения на экране, соответственно вся ось перетаскивания также фиксирована.

Точка между двумя опорными точками называется порогом (threshold). Перетаскиваемый компонент вернется к начальной опорной точке, если перетаскивание закончится до достижения порогового значения. Если, с другой стороны, перетаскивание заканчивается после прохождения точки перехода, компонент продолжит движение, пока не достигнет следующей опорной точки.

Для использования перетаскивания по опорным точкам нужно добавить в проект библиотеку foundation. Для этого откроем файл libs.versions.toml и внесем в нем изменения в две секции:

```
[versions]
foundation = "1.6.4"

.........................

[libraries]
androidx-foundation = { module = "androidx.compose.foundation:foundation", version.ref = "foundation" }
```

Затем в файл build.gradle.kts(Module: app) добавим зависимость библиотеки foundation:

```
...............
dependencies {
    implementation(libs.androidx.foundation)
..........................
```

И для применения изменений нажмем на кнопку Sync Now

## Основные элементы перетаскивания вдоль фиксированной оси
Для обработчки перетаскивания вдоль фиксированной оси к компоненту, для которого надо обработать перетаскивание, применяется модификатор anchoredDraggable():

```kotlin
@ExperimentalFoundationApi
fun <T : Any?> Modifier.anchoredDraggable(
    state: AnchoredDraggableState<T>,
    orientation: Orientation,
    enabled: Boolean = true,
    reverseDirection: Boolean = false,
    interactionSource: MutableInteractionSource? = null,
    startDragImmediately: Boolean = state.isAnimationRunning
): Modifier
```

Его параметры:

- state: состояние типа AnchoredDraggableState<T>, которое хранит информацию о перемещении

- orientation: направление перетаскивания

- enabled: доступно ли перетаскивание

- reverseDirection: в каком направлении идет перетаскивание

- interactionSource: объект MutableInteractionSource, который передается во внутренний модификатор Modifier.draggable

- startDragImmediately: если установлено значение true, то перетаскивание начнется немедленно. Предназначено для того, чтобы конечные пользователи могли "поймать" анимируемый компонент, нажав на него.

Перетаскиваемые опорные точки объявляются с помощью фабрики DraggableAnchors. Координаты этих точек определяются в пикселях в виде значений Float. Например, следующий код создает объект DraggableAnchors, который состоит из трех опорных точек, расположенных в начале, центре и конце пути перетаскивания:

```kotlin
enum class Anchors {
    Left,
    Center,
    Right
}
 
val anchors = DraggableAnchors {
    Anchors.Left at 0f
    Anchors.Center at widthPx / 2
    Anchors.Right at widthPx
}
```

Пороги объявляются как лямбда-выражения, которые возвращают пороговую позицию. При вызове лямбда-выражения в него передается значение, которое представляет расстояние между исходной и конечной опорными точками. Это расстояние можно использовать для расчета пороговой точки на пути перетаскивания. Например, следующий код объявляет порог в точке, составляющей 70% расстояния между двумя опорными точками:

```kotlin
{ distance: Float -> distance * 0.7f }
```

После объявления опорных точек и порога они используются для создания объекта AnchoredDraggableState, синтаксис которого следующий:

```kotlin
val state = remember {
    AnchoredDraggableState(
        initialValue = [позиция начальной опорной точки],
        anchors = DraggableAnchors {
            [определение всех опорных точек]
        },
        positionalThreshold = [вычисление порога],
        velocityThreshold = [пороговая скорость],
        animationSpec = [анимация]
    )
}
```

Конструктор AnchoredDraggableState принимает ряд параметров:

- intialValue: начальная опорная точка перетаскиваемого элемента, в которой перетаскиваемый элемент появится при первом отображении

- anchors: объект DraggableAnchors, который содержит опорные точки

- positionalThreshold: лямбда вычисления порога

- velocityThreshold: дополнительная настройка, определяющая скорость в dp в секунду, которую должна превысить скорость перетаскивания, чтобы перейти в следующее состояние

- animationSpec: применяет эффекты анимации к операции перетаскивания

При перетаскивании позиция перемещаемого компонента автоматически не обновляется. Нам ее надо обновлять вручную. Для этого мы можем использовать модификатор offset(), который устанавливает координаты компонента. Для установки позиции в этот модификатор можно передать текущее смещения, которое можно получить из состояния AnchoredDraggableState с помощью вызова метода requireOffset(). Результатом будет текущая позиция по оси X или Y, в зависимости от того, является ли направоление перетаскивания горизонтальным или вертикальным. Например, при горизонтальном перетаскивании установка позиции могла бы выглядеть так:

```kotlin
Box(Modifier.offset { IntOffset( x = state .requireOffset().roundToInt(), y = 0) })
```

## Пример перетаскивания
В качестве простейшего примера перетаскивания по опорным точкам рассмотрим следующее приложение:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.core.tween
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.foundation.gestures.AnchoredDraggableState
import androidx.compose.foundation.gestures.DraggableAnchors
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.anchoredDraggable
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.ui.unit.IntOffset
import kotlin.math.roundToInt
 
enum class Anchors {
    Start,
    Center,
    End
}
 
class MainActivity : ComponentActivity() {
 
    @OptIn(ExperimentalFoundationApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val density = LocalDensity.current
            val parentBoxWidth = 320.dp
            val boxSize = 50.dp
            val widthPx = with(density) {(parentBoxWidth - boxSize).toPx() }
            val state = remember {
                AnchoredDraggableState(
                    initialValue = Anchors.Start,
                    anchors = DraggableAnchors {
                        Anchors.Start at 0f
                        Anchors.Center at widthPx / 2
                        Anchors.End at widthPx
                    },
 
                    positionalThreshold = { distance: Float -> distance * 0.5f },
                    velocityThreshold = { with(density) { 100.dp.toPx() } },
                    animationSpec = tween()
                )
            }
            Box(Modifier.padding(20.dp).width(parentBoxWidth)){
                Box(Modifier.width(parentBoxWidth).height(5.dp).background(Color.DarkGray).align(Alignment.CenterStart))
                Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.CenterStart))
                Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.Center))
                Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.CenterEnd))
                Box(
                    Modifier
                        .offset {
                            IntOffset(
                                x = state
                                    .requireOffset()
                                    .roundToInt(),
                                y = 0,
                            )
                        }
                        .anchoredDraggable(
                            state,
                            Orientation.Horizontal
                        )
                        .size(boxSize)
                        .background(Color.LightGray)
                )
            }
        }
    }
}
```
В итоге у нас получится ось с тремя точками, по которым мы сможем перемещать светло-серый компонент Box:

![](https://metanit.com/kotlin/jetpack/pics/18.7.png)

Итак, здесь мы определяем три опорных точки:

```kotlin
enum class Anchors {
    Start,
    Center,
    End
}
```
Сначала определяем несколько базовых переменных, которые будут применяться при рассчетах:

```kotlin
val density = LocalDensity.current
val parentBoxWidth = 320.dp
val boxSize = 50.dp
val widthPx = with(density) {(parentBoxWidth - boxSize).toPx() }
```

Переменная density представляет плотность текущего экрана и необходима для перевода из единиц dp в стандартные пиксели. Переменная parentBoxWidth хранит ширину контейнера, а также длину оси, по которой будет перемещаться компонент. Переменная boxSize хранит ширину и высоту компонента (ширина равна высоте). Наконец, ширина перетаскиваемой области в пикселях - переменная widthPx рассчитывается путем вычитания ширины перетаскиваемого компонента из ширины родительского контейнера.

Ширина перетаскиваемого компонента вычитается, чтобы учесть тот факт, что перетаскиваемый компонент будет центрирован по опорным точкам, оставляя отступ в половину ширины перетаскиваемого компонента на первой и последней опорных точках (эти две половины объединяются, и получается полная ширина перетаскиваемого компонента).

Далее с помошью вызова AnchoredDraggableState определяется состояния перетасиквания:

```kotlin
val state = remember {
    AnchoredDraggableState(
        initialValue = Anchors.Start,
        anchors = DraggableAnchors {
            Anchors.Start at 0f
            Anchors.Center at widthPx / 2
            Anchors.End at widthPx
        },
        positionalThreshold = { distance: Float -> distance * 0.5f },
        velocityThreshold = { with(density) { 100.dp.toPx() } },
        animationSpec = tween()
    )
}
```

В конструктор класса AnchoredDraggableState передается позиция начальной опорной точки, а также объект DraggableAnchors с тремя опорными точками. Через параметр positionalThreshold задаем порог, который расположен по середине между соседними опорными точками.

Стоит отметить, что на момент написания статьи класс AnchoredDraggableState представляет экспериментальную функциональность, поэтому к методу onCreate() в MainActivity применяется аннотация @ExperimentalFoundationApi:

```kotlin
class MainActivity : ComponentActivity() {
 
    @OptIn(ExperimentalFoundationApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
```

Компонент верхнего уровня, который содержит интерфейс, представляет компонент Box:

```kotlin
Box(Modifier.padding(20.dp).width(parentBoxWidth)){
    Box(Modifier.width(parentBoxWidth).height(5.dp).background(Color.DarkGray).align(Alignment.CenterStart))
    Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.CenterStart))
    Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.Center))
    Box(Modifier.size(10.dp).background(Color.DarkGray, CircleShape).align(Alignment.CenterEnd))
```

Этот Box имеет ширину, равную parentBoxWidth. Внутри этого компонента с помощью дополнительных компонентов Box отрисована ось перемещения с тремя точками.

Затем определяется компонент Box, который собственно будет перемещаться вдоль оси:

```kotlin
Box(
    Modifier
        .offset {
            IntOffset(
                x = state
                    .requireOffset()
                    .roundToInt(),
                y = 0,
            )
        }
        .anchoredDraggable(
            state,
            Orientation.Horizontal,
        )
        .size(boxSize)
        .background(Color.LightGray)
)
```

Сначала к этому компоненту применяется модификатор offset() для управления положением. Для получения координаты x применяется метод requireOffset() состояния. Затем смещение используется для позиционирования Box вдоль оси X.

Затем Box становится перетаскиваемым путем применения модификатора аnchoredDraggable(), в который передается состояние перетаскивания и направление (по горизонтали).


# Прокрутка

Прокрутка или скроллинг представляет движение пальцем по вертикали или по горизонтали. Ранее мы уже рассматривали прокрутку в статье Создание прокрутки, в частности, мы рассматривали, как с помощью модификаторов horizontalScroll() и verticalScroll() можно определить прокрутку соответственно по горизонтали и вертикали. Благодаря этим модификаторам нам не надо думать о реализации логики прокрутки, все делеается автоматически. Тем не менее мы можем задать и свою собственную логику прокрутки, применяя модификатор scrollable().

Для управления прокруткой применяется состояние, которое создается с помощью функции rememberScrollableState(). В нее передается функция, которая дает нам доступ к расстоянию, пройденному жестом прокрутки. Данное расстояние можно использовать для регулировки смещения одного или нескольких компонентов на экране. Например:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.gestures.rememberScrollableState
import androidx.compose.foundation.gestures.scrollable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import kotlin.math.roundToInt
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var offset by remember { mutableStateOf(0f) }
            Box(Modifier
                .fillMaxSize()
                .scrollable(
                    orientation = Orientation.Vertical,
                    state = rememberScrollableState { distance ->
                        offset += distance
                        distance
                    }
                )
            ) {
                Box(Modifier
                    .size(150.dp)
                    .padding(10.dp)
                    .offset { IntOffset(0, offset.roundToInt()) }
                    .background(Color.DarkGray))
            }
        }
    }
}
```

В данном случае мы управляем прокруткой внутри элемента Box, который занимает всю поверхность экрана. Для отслеживания позиции прокрутки устанавливается переменная offset.

```kotlin
var offset by remember { mutableStateOf(0f) }
```

В компоненте Box применяем модификатор scrollable():

```kotlin
.scrollable(
    orientation = Orientation.Vertical,
    state = rememberScrollableState { distance ->
        offset += distance
        distance
    }
)
```

В rememberScrollableState передается функция, которая определяет параметр distanse. Этот параметр представляет объект Offset, из которого мы можем получить последние значения смещения при прокрутке. Затем это смещение добавляется к состоянияю offset.

Вложенный компонент Box, который представляет темно-серый квадрат размером 150х150, использует значение offset для установки положения по оси y

```kotlin
Box(Modifier
    .size(150.dp)
    .padding(10.dp)
    .offset { IntOffset(0, offset.roundToInt()) }
    .background(Color.DarkGray))
```

Таким образом, при прокрутке будет изменяться позиция вложенного компонента Box:

![](https://metanit.com/kotlin/jetpack/pics/18.4.png)







# Масштабирование, вращение и перемещение


## Масштабирование
С помощью двух пальцев можно выполнить масштабирование контента и создать эффекта увеличения (при разведении пальцев) или уменьшения масштаба (при сведении пальцев). Этот тип жестов обрабатывается с помощью модификатора transformable(), который принимает в качестве параметра состояние типа TransformableState:

```kotlin
fun Modifier.transformable(
    state: TransformableState,
    lockRotationOnZoomPan: Boolean = false,
    enabled: Boolean = true
): Modifier
```

Для создания объекта TransformableState применяется функция rememberTransformableState(), которая принимает функцию с тремя параметрами:

```kotlin
(zoomChange: Float, panChange: Offset, rotationChange: Float) -> Unit
```


- zoomChange: значение Float, которое обновляется при выполнении жестов масштабирования.

- panChange: значение Offset, которое содержит текущие значения смещения x и y. Это значение обновляется, когда с помощью жестов производится перемещение целевого компонента.

- rotationChange: значение Float, которое представляет текущее изменение угла с помощью жестов вращения.

При вызове функции rememberTransformableState() необходимо объявить все три параметра, даже если их не предполагается использовать. Типичное объявление TransformableState, которое отслеживает изменения масштаба, может выглядеть следующим образом:

```kotlin
var scale by remember { mutableStateOf(1f) }
 
val state = rememberTransformableState { 
    scaleChange, offsetChange, rotationChange -> scale *= scaleChange
}
```

Затем созданное состояние можно передать в вызов модификатора transformable():

```kotlin
Composable(modifier = Modifier.transformable(state = state) {
 
    }
)
```

Например, рассмотрим следующее приложение:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var scale by remember { mutableStateOf(1f) }
 
            val state = rememberTransformableState {
                scaleChange, offsetChange, rotationChange -> scale *= scaleChange
            }
 
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Box(Modifier
                    .graphicsLayer(scaleX = scale, scaleY = scale)
                    .transformable(state = state)
                    .background(Color.DarkGray)
                    .size(150.dp)
                )
            }
        }
    }
}
```

Здесь внутренний компонент Box использует модификатор transformable() для отслеживания масштабирования. По мере выполнения жеста масштабирования состояние масштаба - переменная scale будет обновляться. Чтобы отразить эти изменения, мы обращаемся к графическому слою компонента, установив параметры scaleX и scaleY в текущее состояние масштаба:

```kotlin
Box(Modifier
    .graphicsLayer(scaleX = scale, scaleY = scale)
```

Таким образом, с помощью жеста масштабирования мы сможем изменять размер вложенного компонента Box:

![](https://metanit.com/kotlin/jetpack/pics/18.5.png)

## Вращение
Аналогично с помощью того же модификатора transformable() можно обрабатывать жесты вращения:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var angle by remember { mutableStateOf(0f) }
            val state = rememberTransformableState {
                scaleChange, offsetChange, rotationChange -> angle += rotationChange
            }
 
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Box(Modifier
                    .graphicsLayer(rotationZ = angle)
                    .transformable(state = state)
                    .background(Color.DarkGray)
                    .size(200.dp)
                )
            }
        }
    }
}
```

В данном случае для отслеживания угла поворота определяем переменную angle и затем изменяем ее, прибавляя к ней значение из rotationChange. А у компонента Box устанавливаем угол поворота с помощью параметра rotationZ модификатора graphicsLayer

![](https://metanit.com/kotlin/jetpack/pics/18.6.png)


## Перемещение
И последний тип трансформаций - перемещение компонента жестами делается аналогично:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var offset by remember { mutableStateOf(Offset.Zero)}
            val state = rememberTransformableState {
                scaleChange, offsetChange, rotationChange -> offset += offsetChange
            }
 
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Box(Modifier
                    .graphicsLayer(
                        translationX = offset.x,
                        translationY = offset.y
                    )
                    .transformable(state = state)
                    .background(Color.DarkGray)
                    .size(200.dp)
                )
            }
        }
    }
}
```

Здесь для хранения данных о перемещении определяем переменную offset:

```kotlin
var offset by remember { mutableStateOf(Offset.Zero)}
```

Причем эта переменная представляет объект Offset и будет содержать смещение сразу по обоим осям - X и Y.

При обработке перемещения к этой переменной прибавляем значения перемещения из параметра offsetChange:

```kotlin
val state = rememberTransformableState {
    scaleChange, offsetChange, rotationChange -> offset += offsetChange
}
```

Для установки привязки компонента Box к значениям из переменной offset используем параметры translationX и translationY функции-модификатора graphicsLayer():

```kotlin
Box(Modifier
    .graphicsLayer(
        translationX = offset.x,
        translationY = offset.y
)
```

При необходимости можно объединить обработку нескольких типов жестов:

```kotlin
package com.example.helloapp
 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.rememberTransformableState
import androidx.compose.foundation.gestures.transformable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
 
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
 
 
class MainActivity : ComponentActivity() {
 
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            var scale by remember { mutableStateOf(1f) }
            var angle by remember { mutableStateOf(0f) }
            var offset by remember { mutableStateOf(Offset.Zero)}
            val state = rememberTransformableState {
                scaleChange, offsetChange, rotationChange ->
                    scale *= scaleChange
                    angle += rotationChange
                    offset += offsetChange
            }
 
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Box(Modifier
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        rotationZ = angle,
                        translationX = offset.x,
                        translationY = offset.y
                    )
                    .transformable(state = state)
                    .background(Color.DarkGray)
                    .size(200.dp)
                )
            }
        }
    }
}
```


